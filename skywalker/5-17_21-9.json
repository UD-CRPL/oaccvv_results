var jsonResults = {
    "configs": [
        {
            "CC": "nvc",
            "CCFlags": [
                "-acc",
                "-ta=tesla",
                "-Minfo=all"
            ],
            "CC_ACC_Version": "2.6",
            "CPP": "nvc",
            "CPPFlags": [
                "-acc",
                "-ta=tesla",
                "-Minfo=all"
            ],
            "CPP_ACC_Version": "2.6",
            "FC": "",
            "FCFlags": [
                "-acc",
                "-ta=tesla",
                "-Minfo=all"
            ],
            "FC_ACC_Version": null,
            "PostCompileCommands": [],
            "PostRunCommands": [],
            "PreCompileCommands": [],
            "PreRunCommands": [],
            "build_dir": "/usa/chrismun/openacc/build",
            "config_id": -1,
            "config_name": "init_config.txt",
            "env": null,
            "exclude_tags": [],
            "exclude_tests": [
                "acc_testsuite.Fh",
                "acc_testsuite.h",
                "acc_testsuite_declare.h"
            ],
            "export_format": "json",
            "fast": false,
            "id": 1,
            "include_by_default": true,
            "include_tags": [],
            "include_tests": [],
            "keep_build_dir": false,
            "keep_mutated_tests": false,
            "keep_partial_results": false,
            "keep_policy": "on-error",
            "mutated_test_dir": "/usa/chrismun/openacc/build/mutated_tests",
            "mutators": [],
            "partial": false,
            "partial_results_dir": "/usa/chrismun/openacc/build/partial_results",
            "runtime_prefix": "",
            "seed": null,
            "system_name": null,
            "tag_evaluation": null,
            "test_dir": "/usa/chrismun/openacc/Tests",
            "timeout": 10
        }
    ],
    "runs": {
        "acc_async_test.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_async_test.c/acc_async_test.c0 /usa/chrismun/openacc/Tests/acc_async_test.c",
                    "config": 1,
                    "errors": "test1:\n     23, Generating enter data copyin(b[:n],a[:n],d[:n])\n         Generating enter data create(e[:n],c[:n])\n         Generating present(a[:n],c[:n],b[:n])\n         Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     30, Generating present(c[:n],e[:n],d[:n])\n         Generating Tesla code\n         32, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     38, Generating exit data copyout(e[:n])\ntest2:\n     67, Generating copyin(a[:n]) [if not already present]\n         Generating create(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n         Generating copyout(e[:n]) [if not already present]\n         Generating copyin(d[:n]) [if not already present]\n     69, Generating present(a[:n],b[:n],c[:n])\n         Generating Tesla code\n         71, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     76, Generating present(c[:n],e[:n],d[:n])\n         Generating Tesla code\n         78, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest3:\n    113, Generating copyin(a[:n]) [if not already present]\n         Generating create(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n         Generating copyout(e[:n]) [if not already present]\n         Generating copyin(d[:n]) [if not already present]\n    115, Generating present(a[:n],b[:n],c[:n])\n         Generating Tesla code\n        117, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    122, Generating present(c[:n],e[:n],d[:n])\n         Generating Tesla code\n        124, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.971293209004216
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.118595749954693,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_async_test_all.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_async_test_all.c/acc_async_test_all.c0 /usa/chrismun/openacc/Tests/acc_async_test_all.c",
                    "config": 1,
                    "errors": "test1:\n     25, Generating enter data create(e[:10][:n],d[:10][:n],c[:10][:n],b[:10][:n],a[:10][:n])\n     28, Generating update device(b[x][:n],d[x][:n],a[x][:n])\n     31, Generating present(a[x][:n],c[x][:n],b[x][:n])\n         Generating Tesla code\n         33, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     38, Generating present(c[x][:n],e[x][:n],d[x][:n])\n         Generating Tesla code\n         40, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     45, Generating update self(e[x][:n])\n     54, Generating exit data delete(e[:10][:n],d[:10][:n],c[:10][:n],b[:10][:n],a[:10][:n])\ntest2:\n     92, Generating copyin(a[:n*10]) [if not already present]\n         Generating copyout(c[:n*10]) [if not already present]\n         Generating copyin(b[:n*10]) [if not already present]\n         Generating copyout(e[:n*10]) [if not already present]\n         Generating copyin(d[:n*10]) [if not already present]\n     93, Generating present(a[:n*10],b[:n*10],c[:n*10])\n     95, Generating Tesla code\n         97, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    102, Generating present(c[:n*10],e[:n*10],d[:n*10])\n         Generating Tesla code\n        104, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest3:\n    154, Generating copyin(a[:10][:n]) [if not already present]\n         Generating copyout(c[:10][:n]) [if not already present]\n         Generating copyin(b[:10][:n]) [if not already present]\n         Generating copyout(e[:10][:n]) [if not already present]\n         Generating copyin(d[:10][:n]) [if not already present]\n    158, Generating present(a[:10][:n],b[:10][:n],c[:10][:n])\n         Generating Tesla code\n        160, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    165, Generating present(c[:10][:n],e[:10][:n],d[:10][:n])\n         Generating Tesla code\n        167, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 3.021110706962645
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "0 out of 1000\n",
                    "result": 0,
                    "runtime": 2.319405412999913,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyin.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -o /usa/chrismun/openacc/build/acc_copyin.c/acc_copyin.c0 /usa/chrismun/openacc/Tests/acc_copyin.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_copyin.c\", line 338: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1203345539979637
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0087562509579584,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -o /usa/chrismun/openacc/build/acc_copyin.c/acc_copyin.c1 /usa/chrismun/openacc/Tests/acc_copyin.c",
                    "config": 1,
                    "errors": "test1:\n     21, Generating copy(c[:n]) [if not already present]\n     23, Generating present(b[:n],a[:n])\n         Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.819961223984137
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018149310024455,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT3 -DT4 -DT5 -DT6 -DT7 -o /usa/chrismun/openacc/build/acc_copyin.c/acc_copyin.c2 /usa/chrismun/openacc/Tests/acc_copyin.c",
                    "config": 1,
                    "errors": "test2:\n     63, Generating copy(c[:n]) [if not already present]\n     65, Generating present(b[:n],a[:n])\n         Generating Tesla code\n         67, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     71, Generating exit data copyout(b[:n],a[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7696874930988997
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018380829016678,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -DT5 -DT6 -DT7 -o /usa/chrismun/openacc/build/acc_copyin.c/acc_copyin.c3 /usa/chrismun/openacc/Tests/acc_copyin.c",
                    "config": 1,
                    "errors": "test3:\n     99, Generating enter data copyin(dev_test[:1])\n         Generating present(dev_test[:1])\n         Generating Tesla code\n    121, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n    123, Generating Tesla code\n        125, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870395026053302
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0680242279777303,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT5 -DT6 -DT7 -o /usa/chrismun/openacc/build/acc_copyin.c/acc_copyin.c4 /usa/chrismun/openacc/Tests/acc_copyin.c",
                    "config": 1,
                    "errors": "test4:\n    169, Generating copy(c[:n]) [if not already present]\n    171, Generating present(b[:n],a[:n])\n         Generating Tesla code\n        173, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    177, Generating exit data delete(b[:n],a[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.819689650903456
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0689202519133687,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT6 -DT7 -o /usa/chrismun/openacc/build/acc_copyin.c/acc_copyin.c5 /usa/chrismun/openacc/Tests/acc_copyin.c",
                    "config": 1,
                    "errors": "test5:\n    209, Generating copyout(c[:n]) [if not already present]\n         Generating present(b[:n],a[:n])\n    211, Generating Tesla code\n        213, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    217, Generating exit data delete(b[:n],a[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8197201680159196
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068238703068346,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT7 -o /usa/chrismun/openacc/build/acc_copyin.c/acc_copyin.c6 /usa/chrismun/openacc/Tests/acc_copyin.c",
                    "config": 1,
                    "errors": "test6:\n    251, Generating copyout(c[:n]) [if not already present]\n    253, Generating present(b[:n],a[:n])\n         Generating Tesla code\n        255, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    259, Generating exit data delete(b[:n],a[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8193986320402473
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0691795899765566,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -o /usa/chrismun/openacc/build/acc_copyin.c/acc_copyin.c7 /usa/chrismun/openacc/Tests/acc_copyin.c",
                    "config": 1,
                    "errors": "test7:\n    288, Generating enter data copyin(dev_test[:1])\n         Generating present(dev_test[:1])\n         Generating Tesla code\n    313, Generating copyout(c[:n]) [if not already present]\n    315, Generating present(b[:n],a[:n])\n         Generating Tesla code\n        317, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    321, Generating exit data delete(b[:n],a[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.869862843072042
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018972215941176,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_copyin.c/acc_copyin.c8 /usa/chrismun/openacc/Tests/acc_copyin.c",
                    "config": 1,
                    "errors": "test1:\n     21, Generating copy(c[:n]) [if not already present]\n     23, Generating present(b[:n],a[:n])\n         Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     63, Generating copy(c[:n]) [if not already present]\n     65, Generating present(b[:n],a[:n])\n         Generating Tesla code\n         67, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     71, Generating exit data copyout(b[:n],a[:n])\ntest3:\n     99, Generating enter data copyin(dev_test[:1])\n         Generating present(dev_test[:1])\n         Generating Tesla code\n    121, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n    123, Generating Tesla code\n        125, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest4:\n    169, Generating copy(c[:n]) [if not already present]\n    171, Generating present(b[:n],a[:n])\n         Generating Tesla code\n        173, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    177, Generating exit data delete(b[:n],a[:n])\ntest5:\n    209, Generating copyout(c[:n]) [if not already present]\n         Generating present(b[:n],a[:n])\n    211, Generating Tesla code\n        213, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    217, Generating exit data delete(b[:n],a[:n])\ntest6:\n    251, Generating copyout(c[:n]) [if not already present]\n    253, Generating present(b[:n],a[:n])\n         Generating Tesla code\n        255, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    259, Generating exit data delete(b[:n],a[:n])\ntest7:\n    288, Generating enter data copyin(dev_test[:1])\n         Generating present(dev_test[:1])\n         Generating Tesla code\n    313, Generating copyout(c[:n]) [if not already present]\n    315, Generating present(b[:n],a[:n])\n         Generating Tesla code\n        317, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    321, Generating exit data delete(b[:n],a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 3.0199646230321378
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0190103569766507,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyin_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -o /usa/chrismun/openacc/build/acc_copyin_async.c/acc_copyin_async.c0 /usa/chrismun/openacc/Tests/acc_copyin_async.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_copyin_async.c\", line 261: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0686245219549164
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008345013950020075,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -DT5 -o /usa/chrismun/openacc/build/acc_copyin_async.c/acc_copyin_async.c1 /usa/chrismun/openacc/Tests/acc_copyin_async.c",
                    "config": 1,
                    "errors": "test1:\n     23, Generating copyout(c[:n]) [if not already present]\n         Generating present(a[:n],b[:n])\n     25, Generating Tesla code\n         27, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     32, Generating Tesla code\n         34, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     39, Generating Tesla code\n         41, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     48, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.769560604938306
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0682857310166582,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT3 -DT4 -DT5 -o /usa/chrismun/openacc/build/acc_copyin_async.c/acc_copyin_async.c2 /usa/chrismun/openacc/Tests/acc_copyin_async.c",
                    "config": 1,
                    "errors": "test2:\n     78, Generating copyout(c[:n]) [if not already present]\n     81, Generating present(b[:n],a[:n])\n         Generating Tesla code\n         83, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     87, Generating exit data delete(b[:n],a[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8199418879812583
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0686188210966066,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -DT5 -o /usa/chrismun/openacc/build/acc_copyin_async.c/acc_copyin_async.c3 /usa/chrismun/openacc/Tests/acc_copyin_async.c",
                    "config": 1,
                    "errors": "test3:\n    120, Generating copyout(c[:n]) [if not already present]\n    123, Generating present(b[:n],a[:n])\n         Generating Tesla code\n        125, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    129, Generating exit data delete(b[:n],a[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8206652919761837
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0683502939064056,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT5 -o /usa/chrismun/openacc/build/acc_copyin_async.c/acc_copyin_async.c4 /usa/chrismun/openacc/Tests/acc_copyin_async.c",
                    "config": 1,
                    "errors": "test4:\n    164, Generating enter data create(c[:n])\n         Generating copyin(a[:n],b[:n],d[:n]) [if not already present]\n         Generating copyout(e[:n]) [if not already present]\n    166, Generating present(c[:n])\n         Generating Tesla code\n        168, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    175, Generating exit data delete(c[:n])\n         Generating present(c[:n])\n         Generating Tesla code\n        177, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    181, Generating exit data copyout(c[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820311745046638
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "hostptr=0x207f900,stride=1,size=100,extent=-1,eltsize=8,name=c,flags=0x200=present,async=1,threadid=1\nPresent table dump for device[1]: NVIDIA Tesla GPU 0, compute capability 7.0, threadid=1\nhost:0x207f2a0 device:0x7f7dc3afa400 size:800 presentcount:1+0 line:164 name:a\nhost:0x207f5d0 device:0x7f7dc3afa800 size:800 presentcount:1+0 line:164 name:b\nhost:0x207fc30 device:0x7f7dc3afac00 size:800 presentcount:1+0 line:164 name:d\nhost:0x207ff60 device:0x7f7dc3afb000 size:800 presentcount:1+0 line:164 name:e\nallocated block device:0x7f7dc3afa400 size:1024 thread:1\nallocated block device:0x7f7dc3afa800 size:1024 thread:1\nallocated block device:0x7f7dc3afac00 size:1024 thread:1\nallocated block device:0x7f7dc3afb000 size:1024 thread:1\ndeleted block   device:0x7f7dc3afa000 size:1024 threadid=1  draining\nFATAL ERROR: data in PRESENT clause was not found on device 1: name=c host:0x207f900\n file:/usa/chrismun/openacc/Tests/acc_copyin_async.c test4 line:175\n\n",
                    "export": false,
                    "output": "",
                    "result": 1,
                    "runtime": 2.068714853026904,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/acc_copyin_async.c/acc_copyin_async.c5 /usa/chrismun/openacc/Tests/acc_copyin_async.c",
                    "config": 1,
                    "errors": "test5:\n    213, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    235, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n    238, Generating Tesla code\n        240, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    244, Generating exit data delete(b[:n],a[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8349960759514943
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0681935970205814,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT4 -o /usa/chrismun/openacc/build/acc_copyin_async.c/acc_copyin_async.c6 /usa/chrismun/openacc/Tests/acc_copyin_async.c",
                    "config": 1,
                    "errors": "test1:\n     23, Generating copyout(c[:n]) [if not already present]\n         Generating present(a[:n],b[:n])\n     25, Generating Tesla code\n         27, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     32, Generating Tesla code\n         34, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     39, Generating Tesla code\n         41, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     48, FMA (fused multiply-add) instruction(s) generated\ntest2:\n     78, Generating copyout(c[:n]) [if not already present]\n     81, Generating present(b[:n],a[:n])\n         Generating Tesla code\n         83, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     87, Generating exit data delete(b[:n],a[:n])\ntest3:\n    120, Generating copyout(c[:n]) [if not already present]\n    123, Generating present(b[:n],a[:n])\n         Generating Tesla code\n        125, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    129, Generating exit data delete(b[:n],a[:n])\ntest5:\n    213, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    235, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n    238, Generating Tesla code\n        240, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    244, Generating exit data delete(b[:n],a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.920920631964691
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1186926619848236,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyout.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_copyout.c/acc_copyout.c0 /usa/chrismun/openacc/Tests/acc_copyout.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n     22, Generating Tesla code\n         24, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     60, Generating enter data create(c[:n])\n         Generating copyin(b[:n],a[:n]) [if not already present]\n         Generating present(c[:n])\n     62, Generating Tesla code\n         64, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.819931517005898
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018616171902977,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyout_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/acc_copyout_async.c/acc_copyout_async.c0 /usa/chrismun/openacc/Tests/acc_copyout_async.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_copyout_async.c\", line 191: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.118781300028786
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008511688909493387,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/acc_copyout_async.c/acc_copyout_async.c1 /usa/chrismun/openacc/Tests/acc_copyout_async.c",
                    "config": 1,
                    "errors": "test1:\n     26, Generating enter data create(c[:n],f[:n])\n         Generating copyin(a[:n],b[:n],d[:n],e[:n]) [if not already present]\n     28, Generating present(c[:n])\n         Generating Tesla code\n         30, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     35, Generating present(f[:n])\n         Generating Tesla code\n         37, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7697642470011488
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1187798379687592,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT3 -DT4 -o /usa/chrismun/openacc/build/acc_copyout_async.c/acc_copyout_async.c2 /usa/chrismun/openacc/Tests/acc_copyout_async.c",
                    "config": 1,
                    "errors": "test2:\n     78, Generating enter data create(c[:n])\n         Generating copyin(b[:n],a[:n]) [if not already present]\n     80, Generating present(c[:n])\n         Generating Tesla code\n         82, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.769554883008823
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068586239940487,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -o /usa/chrismun/openacc/build/acc_copyout_async.c/acc_copyout_async.c3 /usa/chrismun/openacc/Tests/acc_copyout_async.c",
                    "config": 1,
                    "errors": "test3:\n    120, Generating enter data create(c[:n])\n         Generating copyin(b[:n],a[:n]) [if not already present]\n    122, Generating present(c[:n])\n         Generating Tesla code\n        124, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.769422502955422
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068951478926465,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -o /usa/chrismun/openacc/build/acc_copyout_async.c/acc_copyout_async.c4 /usa/chrismun/openacc/Tests/acc_copyout_async.c",
                    "config": 1,
                    "errors": "test4:\n    159, Generating enter data create(c[:n])\n         Generating copyin(b[:n],a[:n]) [if not already present]\n    161, Generating present(c[:n])\n         Generating Tesla code\n        163, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    168, Generating enter data copyin(c[:n])\n    170, Generating present(c[:n])\n         Generating Tesla code\n        172, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    180, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8694862379925326
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1189343489240855,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_copyout_async.c/acc_copyout_async.c5 /usa/chrismun/openacc/Tests/acc_copyout_async.c",
                    "config": 1,
                    "errors": "test1:\n     26, Generating enter data create(c[:n],f[:n])\n         Generating copyin(a[:n],b[:n],d[:n],e[:n]) [if not already present]\n     28, Generating present(c[:n])\n         Generating Tesla code\n         30, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     35, Generating present(f[:n])\n         Generating Tesla code\n         37, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     78, Generating enter data create(c[:n])\n         Generating copyin(b[:n],a[:n]) [if not already present]\n     80, Generating present(c[:n])\n         Generating Tesla code\n         82, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest3:\n    120, Generating enter data create(c[:n])\n         Generating copyin(b[:n],a[:n]) [if not already present]\n    122, Generating present(c[:n])\n         Generating Tesla code\n        124, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest4:\n    159, Generating enter data create(c[:n])\n         Generating copyin(b[:n],a[:n]) [if not already present]\n    161, Generating present(c[:n])\n         Generating Tesla code\n        163, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    168, Generating enter data copyin(c[:n])\n    170, Generating present(c[:n])\n         Generating Tesla code\n        172, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    180, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9698499739170074
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.11876633297652,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyout_finalize.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_copyout_finalize.c/acc_copyout_finalize.c0 /usa/chrismun/openacc/Tests/acc_copyout_finalize.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_copyout_finalize.c\", line 30: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\n\"/usa/chrismun/openacc/Tests/acc_copyout_finalize.c\", line 68: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\n\"/usa/chrismun/openacc/Tests/acc_copyout_finalize.c\", line 106: warning: function \"acc_copyout_finalize\" declared implicitly\n          acc_copyout_finalize(c, n * sizeof(real_t));\n          ^\n\ntest1:\n     21, Generating enter data create(c[:n])\n         Generating copyin(b[:n],a[:n]) [if not already present]\n         Generating present(c[:n])\n     23, Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     59, Generating enter data copyin(c[:n])\n         Generating copyin(a[:n],b[:n]) [if not already present]\n     61, Generating present(b[:n],a[:n])\n         Generating Tesla code\n         63, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     61, Generating implicit copyout(c[:n]) [if not already present]\ntest3:\n     98, Generating enter data copyin(c[:n])\n         Generating copyin(a[:n],b[:n]) [if not already present]\n    100, Generating present(c[:n])\n         Generating Tesla code\n        102, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    109, Generating enter data copyin(c[:n])\n         Generating present(c[:n])\n         Generating Tesla code\n        111, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    115, Generating exit data copyout(c[:n])\n    119, FMA (fused multiply-add) instruction(s) generated\n/usr/bin/ld: /tmp/nvcE6ULbAykdyktl.o: in function `test1':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize.c:30: undefined reference to `acc_copyout_finalize'\n/usr/bin/ld: /tmp/nvcE6ULbAykdyktl.o: in function `test2':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize.c:68: undefined reference to `acc_copyout_finalize'\n/usr/bin/ld: /tmp/nvcE6ULbAykdyktl.o: in function `test3':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize.c:106: undefined reference to `acc_copyout_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.970336672035046
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/acc_copyout_finalize.c/acc_copyout_finalize.c1 /usa/chrismun/openacc/Tests/acc_copyout_finalize.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_copyout_finalize.c\", line 68: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\n\"/usa/chrismun/openacc/Tests/acc_copyout_finalize.c\", line 106: warning: function \"acc_copyout_finalize\" declared implicitly\n          acc_copyout_finalize(c, n * sizeof(real_t));\n          ^\n\ntest2:\n     59, Generating enter data copyin(c[:n])\n         Generating copyin(a[:n],b[:n]) [if not already present]\n     61, Generating present(b[:n],a[:n])\n         Generating Tesla code\n         63, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     61, Generating implicit copyout(c[:n]) [if not already present]\ntest3:\n     98, Generating enter data copyin(c[:n])\n         Generating copyin(a[:n],b[:n]) [if not already present]\n    100, Generating present(c[:n])\n         Generating Tesla code\n        102, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    109, Generating enter data copyin(c[:n])\n         Generating present(c[:n])\n         Generating Tesla code\n        111, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    115, Generating exit data copyout(c[:n])\n    119, FMA (fused multiply-add) instruction(s) generated\n/usr/bin/ld: /tmp/nvc5FVLbRAMaGBnV.o: in function `test2':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize.c:68: undefined reference to `acc_copyout_finalize'\n/usr/bin/ld: /tmp/nvc5FVLbRAMaGBnV.o: in function `test3':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize.c:106: undefined reference to `acc_copyout_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.8700112310471013
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/acc_copyout_finalize.c/acc_copyout_finalize.c2 /usa/chrismun/openacc/Tests/acc_copyout_finalize.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_copyout_finalize.c\", line 30: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\n\"/usa/chrismun/openacc/Tests/acc_copyout_finalize.c\", line 106: warning: function \"acc_copyout_finalize\" declared implicitly\n          acc_copyout_finalize(c, n * sizeof(real_t));\n          ^\n\ntest1:\n     21, Generating enter data create(c[:n])\n         Generating copyin(b[:n],a[:n]) [if not already present]\n         Generating present(c[:n])\n     23, Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest3:\n     98, Generating enter data copyin(c[:n])\n         Generating copyin(a[:n],b[:n]) [if not already present]\n    100, Generating present(c[:n])\n         Generating Tesla code\n        102, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    109, Generating enter data copyin(c[:n])\n         Generating present(c[:n])\n         Generating Tesla code\n        111, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    115, Generating exit data copyout(c[:n])\n    119, FMA (fused multiply-add) instruction(s) generated\n/usr/bin/ld: /tmp/nvc0dWLbCAGm18Hi.o: in function `test1':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize.c:30: undefined reference to `acc_copyout_finalize'\n/usr/bin/ld: /tmp/nvc0dWLbCAGm18Hi.o: in function `test3':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize.c:106: undefined reference to `acc_copyout_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.870033464045264
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/acc_copyout_finalize.c/acc_copyout_finalize.c3 /usa/chrismun/openacc/Tests/acc_copyout_finalize.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_copyout_finalize.c\", line 68: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\n\"/usa/chrismun/openacc/Tests/acc_copyout_finalize.c\", line 106: warning: function \"acc_copyout_finalize\" declared implicitly\n          acc_copyout_finalize(c, n * sizeof(real_t));\n          ^\n\ntest2:\n     59, Generating enter data copyin(c[:n])\n         Generating copyin(a[:n],b[:n]) [if not already present]\n     61, Generating present(b[:n],a[:n])\n         Generating Tesla code\n         63, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     61, Generating implicit copyout(c[:n]) [if not already present]\ntest3:\n     98, Generating enter data copyin(c[:n])\n         Generating copyin(a[:n],b[:n]) [if not already present]\n    100, Generating present(c[:n])\n         Generating Tesla code\n        102, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    109, Generating enter data copyin(c[:n])\n         Generating present(c[:n])\n         Generating Tesla code\n        111, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    115, Generating exit data copyout(c[:n])\n    119, FMA (fused multiply-add) instruction(s) generated\n/usr/bin/ld: /tmp/nvcVNWLbn6XmgLQi.o: in function `test2':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize.c:68: undefined reference to `acc_copyout_finalize'\n/usr/bin/ld: /tmp/nvcVNWLbn6XmgLQi.o: in function `test3':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize.c:106: undefined reference to `acc_copyout_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.820234501035884
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT3 -o /usa/chrismun/openacc/build/acc_copyout_finalize.c/acc_copyout_finalize.c4 /usa/chrismun/openacc/Tests/acc_copyout_finalize.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_copyout_finalize.c\", line 30: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\n\"/usa/chrismun/openacc/Tests/acc_copyout_finalize.c\", line 68: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\ntest1:\n     21, Generating enter data create(c[:n])\n         Generating copyin(b[:n],a[:n]) [if not already present]\n         Generating present(c[:n])\n     23, Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     59, Generating enter data copyin(c[:n])\n         Generating copyin(a[:n],b[:n]) [if not already present]\n     61, Generating present(b[:n],a[:n])\n         Generating Tesla code\n         63, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     61, Generating implicit copyout(c[:n]) [if not already present]\n/usr/bin/ld: /tmp/nvcQlXLb_fDSBStN.o: in function `test1':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize.c:30: undefined reference to `acc_copyout_finalize'\n/usr/bin/ld: /tmp/nvcQlXLb_fDSBStN.o: in function `test2':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize.c:68: undefined reference to `acc_copyout_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.820398930925876
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/acc_copyout_finalize.c/acc_copyout_finalize.c5 /usa/chrismun/openacc/Tests/acc_copyout_finalize.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_copyout_finalize.c\", line 68: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\n\"/usa/chrismun/openacc/Tests/acc_copyout_finalize.c\", line 106: warning: function \"acc_copyout_finalize\" declared implicitly\n          acc_copyout_finalize(c, n * sizeof(real_t));\n          ^\n\ntest2:\n     59, Generating enter data copyin(c[:n])\n         Generating copyin(a[:n],b[:n]) [if not already present]\n     61, Generating present(b[:n],a[:n])\n         Generating Tesla code\n         63, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     61, Generating implicit copyout(c[:n]) [if not already present]\ntest3:\n     98, Generating enter data copyin(c[:n])\n         Generating copyin(a[:n],b[:n]) [if not already present]\n    100, Generating present(c[:n])\n         Generating Tesla code\n        102, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    109, Generating enter data copyin(c[:n])\n         Generating present(c[:n])\n         Generating Tesla code\n        111, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    115, Generating exit data copyout(c[:n])\n    119, FMA (fused multiply-add) instruction(s) generated\n/usr/bin/ld: /tmp/nvcyVXLbi2yK3hfm.o: in function `test2':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize.c:68: undefined reference to `acc_copyout_finalize'\n/usr/bin/ld: /tmp/nvcyVXLbi2yK3hfm.o: in function `test3':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize.c:106: undefined reference to `acc_copyout_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.8711181519320235
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/acc_copyout_finalize.c/acc_copyout_finalize.c6 /usa/chrismun/openacc/Tests/acc_copyout_finalize.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_copyout_finalize.c\", line 30: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\n\"/usa/chrismun/openacc/Tests/acc_copyout_finalize.c\", line 106: warning: function \"acc_copyout_finalize\" declared implicitly\n          acc_copyout_finalize(c, n * sizeof(real_t));\n          ^\n\ntest1:\n     21, Generating enter data create(c[:n])\n         Generating copyin(b[:n],a[:n]) [if not already present]\n         Generating present(c[:n])\n     23, Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest3:\n     98, Generating enter data copyin(c[:n])\n         Generating copyin(a[:n],b[:n]) [if not already present]\n    100, Generating present(c[:n])\n         Generating Tesla code\n        102, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    109, Generating enter data copyin(c[:n])\n         Generating present(c[:n])\n         Generating Tesla code\n        111, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    115, Generating exit data copyout(c[:n])\n    119, FMA (fused multiply-add) instruction(s) generated\n/usr/bin/ld: /tmp/nvcatYLbayXkH9mI.o: in function `test1':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize.c:30: undefined reference to `acc_copyout_finalize'\n/usr/bin/ld: /tmp/nvcatYLbayXkH9mI.o: in function `test3':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize.c:106: undefined reference to `acc_copyout_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.8698518299497664
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/acc_copyout_finalize.c/acc_copyout_finalize.c7 /usa/chrismun/openacc/Tests/acc_copyout_finalize.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_copyout_finalize.c\", line 68: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\n\"/usa/chrismun/openacc/Tests/acc_copyout_finalize.c\", line 106: warning: function \"acc_copyout_finalize\" declared implicitly\n          acc_copyout_finalize(c, n * sizeof(real_t));\n          ^\n\ntest2:\n     59, Generating enter data copyin(c[:n])\n         Generating copyin(a[:n],b[:n]) [if not already present]\n     61, Generating present(b[:n],a[:n])\n         Generating Tesla code\n         63, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     61, Generating implicit copyout(c[:n]) [if not already present]\ntest3:\n     98, Generating enter data copyin(c[:n])\n         Generating copyin(a[:n],b[:n]) [if not already present]\n    100, Generating present(c[:n])\n         Generating Tesla code\n        102, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    109, Generating enter data copyin(c[:n])\n         Generating present(c[:n])\n         Generating Tesla code\n        111, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    115, Generating exit data copyout(c[:n])\n    119, FMA (fused multiply-add) instruction(s) generated\n/usr/bin/ld: /tmp/nvc73YLbXdQ8YurX.o: in function `test2':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize.c:68: undefined reference to `acc_copyout_finalize'\n/usr/bin/ld: /tmp/nvc73YLbXdQ8YurX.o: in function `test3':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize.c:106: undefined reference to `acc_copyout_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": true,
                    "output": "",
                    "result": 2,
                    "runtime": 2.8702619350515306
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": true,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyout_finalize_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/acc_copyout_finalize_async.c/acc_copyout_finalize_async.c0 /usa/chrismun/openacc/Tests/acc_copyout_finalize_async.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_copyout_finalize_async.c\", line 195: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1690060979453847
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00878896308131516,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/acc_copyout_finalize_async.c/acc_copyout_finalize_async.c1 /usa/chrismun/openacc/Tests/acc_copyout_finalize_async.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_copyout_finalize_async.c\", line 42: warning: function \"acc_copyout_finalize_async\" declared implicitly\n          acc_copyout_finalize_async(c, n * sizeof(real_t), 1);\n          ^\n\ntest1:\n     27, Generating enter data create(f[:n],c[:n])\n         Generating copyin(a[:n],b[:n],e[:n],d[:n]) [if not already present]\n         Generating present(f[:n],c[:n])\n     29, Generating Tesla code\n         31, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     36, Generating Tesla code\n         38, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n/usr/bin/ld: /tmp/nvcMa0LbYJw-SMO5.o: in function `test1':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize_async.c:42: undefined reference to `acc_copyout_finalize_async'\n/usr/bin/ld: /usa/chrismun/openacc/Tests/acc_copyout_finalize_async.c:43: undefined reference to `acc_copyout_finalize_async'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.8194758370518684
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT3 -DT4 -o /usa/chrismun/openacc/build/acc_copyout_finalize_async.c/acc_copyout_finalize_async.c2 /usa/chrismun/openacc/Tests/acc_copyout_finalize_async.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_copyout_finalize_async.c\", line 88: warning: function \"acc_copyout_finalize_async\" declared implicitly\n          acc_copyout_finalize_async(c, n * sizeof(real_t), def_async_var);\n          ^\n\ntest2:\n     80, Generating enter data create(c[:n])\n         Generating copyin(b[:n],a[:n]) [if not already present]\n     82, Generating present(c[:n])\n         Generating Tesla code\n         84, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n/usr/bin/ld: /tmp/nvcuK0Lb8dEwogBd.o: in function `test2':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize_async.c:88: undefined reference to `acc_copyout_finalize_async'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.77068366704043
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -o /usa/chrismun/openacc/build/acc_copyout_finalize_async.c/acc_copyout_finalize_async.c3 /usa/chrismun/openacc/Tests/acc_copyout_finalize_async.c",
                    "config": 1,
                    "errors": "test3:\n    123, Generating enter data create(c[:n])\n         Generating copyin(b[:n],a[:n]) [if not already present]\n    125, Generating present(c[:n])\n         Generating Tesla code\n        127, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7707458939403296
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0685415089828894,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -o /usa/chrismun/openacc/build/acc_copyout_finalize_async.c/acc_copyout_finalize_async.c4 /usa/chrismun/openacc/Tests/acc_copyout_finalize_async.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_copyout_finalize_async.c\", line 171: warning: function \"acc_copyout_finalize_async\" declared implicitly\n          acc_copyout_finalize_async(c, n * sizeof(real_t), 1);\n          ^\n\ntest4:\n    163, Generating enter data create(c[:n])\n         Generating copyin(b[:n],a[:n]) [if not already present]\n    165, Generating present(c[:n])\n         Generating Tesla code\n        167, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    174, Generating enter data copyin(c[:n])\n         Generating present(c[:n])\n         Generating Tesla code\n        176, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    183, FMA (fused multiply-add) instruction(s) generated\n/usr/bin/ld: /tmp/nvcSb2Lbec152RLp.o: in function `test4':\n/usa/chrismun/openacc/Tests/acc_copyout_finalize_async.c:171: undefined reference to `acc_copyout_finalize_async'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.7696203970117494
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -o /usa/chrismun/openacc/build/acc_copyout_finalize_async.c/acc_copyout_finalize_async.c5 /usa/chrismun/openacc/Tests/acc_copyout_finalize_async.c",
                    "config": 1,
                    "errors": "test3:\n    123, Generating enter data create(c[:n])\n         Generating copyin(b[:n],a[:n]) [if not already present]\n    125, Generating present(c[:n])\n         Generating Tesla code\n        127, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8193097229814157
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0688184070168063,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_create.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -o /usa/chrismun/openacc/build/acc_create.c/acc_create.c0 /usa/chrismun/openacc/Tests/acc_create.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_create.c\", line 217: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1336924890056252
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00840739207342267,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -DT5 -o /usa/chrismun/openacc/build/acc_create.c/acc_create.c1 /usa/chrismun/openacc/Tests/acc_create.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating copyin(a[:n],b[:n]) [if not already present]\n     22, Generating present(c[:n])\n         Generating Tesla code\n         24, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820538316038437
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0187130470294505,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT3 -DT4 -DT5 -o /usa/chrismun/openacc/build/acc_create.c/acc_create.c2 /usa/chrismun/openacc/Tests/acc_create.c",
                    "config": 1,
                    "errors": "test2:\n     60, Generating copyin(b[:n],a[:n]) [if not already present]\n     62, Generating present(c[:n])\n         Generating Tesla code\n         64, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     68, Generating exit data copyout(c[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7698923910502344
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018537553958595,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -DT5 -o /usa/chrismun/openacc/build/acc_create.c/acc_create.c3 /usa/chrismun/openacc/Tests/acc_create.c",
                    "config": 1,
                    "errors": "test3:\n    100, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n    102, Generating Tesla code\n        104, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    108, Generating exit data copyout(c[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7696480290032923
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018649774021469,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT5 -o /usa/chrismun/openacc/build/acc_create.c/acc_create.c4 /usa/chrismun/openacc/Tests/acc_create.c",
                    "config": 1,
                    "errors": "test4:\n    140, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n    142, Generating Tesla code\n        144, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    148, Generating exit data copyout(c[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.769571366952732
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068509256001562,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/acc_create.c/acc_create.c5 /usa/chrismun/openacc/Tests/acc_create.c",
                    "config": 1,
                    "errors": "test5:\n    175, Generating enter data copyin(dev_test[:1])\n         Generating present(dev_test[:1])\n         Generating Tesla code\n    183, Generating enter data copyin(c[:n])\n    186, Memory zero idiom, loop replaced by call to __c_mzero8\n    191, Generating copyin(b[:n],a[:n]) [if not already present]\n    193, Generating present(c[:n])\n         Generating Tesla code\n        195, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    199, Generating exit data delete(c[:n])\n         Generating exit data copyout(c[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8198466759640723
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failing in Thread:1\ncall to cuMemcpyDtoHAsync returned error 1: Invalid value\n\n",
                    "export": false,
                    "output": "",
                    "result": 1,
                    "runtime": 2.068717126036063,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT5 -o /usa/chrismun/openacc/build/acc_create.c/acc_create.c6 /usa/chrismun/openacc/Tests/acc_create.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating copyin(a[:n],b[:n]) [if not already present]\n     22, Generating present(c[:n])\n         Generating Tesla code\n         24, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     60, Generating copyin(b[:n],a[:n]) [if not already present]\n     62, Generating present(c[:n])\n         Generating Tesla code\n         64, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     68, Generating exit data copyout(c[:n])\ntest3:\n    100, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n    102, Generating Tesla code\n        104, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    108, Generating exit data copyout(c[:n])\ntest4:\n    140, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n    142, Generating Tesla code\n        144, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    148, Generating exit data copyout(c[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9203231639694422
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.01845842495095,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_create_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -o /usa/chrismun/openacc/build/acc_create_async.c/acc_create_async.c0 /usa/chrismun/openacc/Tests/acc_create_async.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_create_async.c\", line 255: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068966959952377
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008716846001334488,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -DT5 -o /usa/chrismun/openacc/build/acc_create_async.c/acc_create_async.c1 /usa/chrismun/openacc/Tests/acc_create_async.c",
                    "config": 1,
                    "errors": "test1:\n     24, Generating copyin(a[:n],b[:n],e[:n],d[:n]) [if not already present]\n     28, Generating present(f[:n],c[:n])\n     30, Generating Tesla code\n         32, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     37, Generating Tesla code\n         39, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     45, Generating exit data copyout(f[:n],c[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.819414432044141
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069197384058498,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT3 -DT4 -DT5 -o /usa/chrismun/openacc/build/acc_create_async.c/acc_create_async.c2 /usa/chrismun/openacc/Tests/acc_create_async.c",
                    "config": 1,
                    "errors": "test2:\n     80, Generating copyin(b[:n],a[:n]) [if not already present]\n     83, Generating present(c[:n])\n         Generating Tesla code\n         85, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     89, Generating exit data copyout(c[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8198042860021815
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068319434998557,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -DT5 -o /usa/chrismun/openacc/build/acc_create_async.c/acc_create_async.c3 /usa/chrismun/openacc/Tests/acc_create_async.c",
                    "config": 1,
                    "errors": "test3:\n    121, Generating copyin(b[:n],a[:n]) [if not already present]\n    124, Generating present(c[:n])\n         Generating Tesla code\n        126, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    130, Generating exit data copyout(c[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7692322509828955
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0186433740891516,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT5 -o /usa/chrismun/openacc/build/acc_create_async.c/acc_create_async.c4 /usa/chrismun/openacc/Tests/acc_create_async.c",
                    "config": 1,
                    "errors": "test4:\n    165, Generating enter data create(c[:n])\n         Generating copyin(a[:n],b[:n],d[:n]) [if not already present]\n         Generating copyout(e[:n]) [if not already present]\n    167, Generating present(c[:n])\n         Generating Tesla code\n        169, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    176, Generating exit data delete(c[:n])\n         Generating present(c[:n])\n         Generating Tesla code\n        178, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    182, Generating exit data copyout(c[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8190988959977403
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "hostptr=0x2239900,stride=1,size=100,extent=-1,eltsize=8,name=c,flags=0x200=present,async=1,threadid=1\nPresent table dump for device[1]: NVIDIA Tesla GPU 0, compute capability 7.0, threadid=1\nhost:0x22392a0 device:0x7fe435afa400 size:800 presentcount:1+0 line:165 name:a\nhost:0x22395d0 device:0x7fe435afa800 size:800 presentcount:1+0 line:165 name:b\nhost:0x2239c30 device:0x7fe435afac00 size:800 presentcount:1+0 line:165 name:d\nhost:0x2239f60 device:0x7fe435afb000 size:800 presentcount:1+0 line:165 name:e\nallocated block device:0x7fe435afa400 size:1024 thread:1\nallocated block device:0x7fe435afa800 size:1024 thread:1\nallocated block device:0x7fe435afac00 size:1024 thread:1\nallocated block device:0x7fe435afb000 size:1024 thread:1\ndeleted block   device:0x7fe435afa000 size:1024 threadid=1  draining\nFATAL ERROR: data in PRESENT clause was not found on device 1: name=c host:0x2239900\n file:/usa/chrismun/openacc/Tests/acc_create_async.c test4 line:176\n\n",
                    "export": false,
                    "output": "",
                    "result": 1,
                    "runtime": 2.069599312962964,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/acc_create_async.c/acc_create_async.c5 /usa/chrismun/openacc/Tests/acc_create_async.c",
                    "config": 1,
                    "errors": "test5:\n    209, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    222, Generating enter data create(c[:n])\n         Generating copyin(b[:n],a[:n]) [if not already present]\n    224, Generating present(c[:n])\n         Generating Tesla code\n        226, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    232, Generating present(c[:n])\n         Generating Tesla code\n        234, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    240, Generating exit data copyout(c[:n])\n    243, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8701864829054102
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068981535034254,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT4 -o /usa/chrismun/openacc/build/acc_create_async.c/acc_create_async.c6 /usa/chrismun/openacc/Tests/acc_create_async.c",
                    "config": 1,
                    "errors": "test1:\n     24, Generating copyin(a[:n],b[:n],e[:n],d[:n]) [if not already present]\n     28, Generating present(f[:n],c[:n])\n     30, Generating Tesla code\n         32, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     37, Generating Tesla code\n         39, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     45, Generating exit data copyout(f[:n],c[:n])\ntest2:\n     80, Generating copyin(b[:n],a[:n]) [if not already present]\n     83, Generating present(c[:n])\n         Generating Tesla code\n         85, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     89, Generating exit data copyout(c[:n])\ntest3:\n    121, Generating copyin(b[:n],a[:n]) [if not already present]\n    124, Generating present(c[:n])\n         Generating Tesla code\n        126, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    130, Generating exit data copyout(c[:n])\ntest5:\n    209, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    222, Generating enter data create(c[:n])\n         Generating copyin(b[:n],a[:n]) [if not already present]\n    224, Generating present(c[:n])\n         Generating Tesla code\n        226, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    232, Generating present(c[:n])\n         Generating Tesla code\n        234, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    240, Generating exit data copyout(c[:n])\n    243, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9701374350115657
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068895183969289,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_delete.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_delete.c/acc_delete.c0 /usa/chrismun/openacc/Tests/acc_delete.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating enter data copyin(b[:n],a[:n])\n         Generating copyout(c[:n]) [if not already present]\n     22, Generating present(b[:n],a[:n])\n         Generating Tesla code\n         24, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     62, Generating copyout(c[:n]) [if not already present]\n     64, Generating present(b[:n],a[:n])\n         Generating Tesla code\n         66, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820135992951691
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018570157000795,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_delete_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_delete_async.c/acc_delete_async.c0 /usa/chrismun/openacc/Tests/acc_delete_async.c",
                    "config": 1,
                    "errors": "test1:\n     26, Generating enter data copyin(e[:n],d[:n],b[:n],a[:n])\n         Generating present(a[:n],b[:n],d[:n],e[:n])\n         Generating copyout(f[:n],c[:n]) [if not already present]\n     28, Generating Tesla code\n         30, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     35, Generating Tesla code\n         37, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     77, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     90, Generating enter data copyin(c[:n],b[:n],a[:n])\n         Generating present(a[:n],c[:n],b[:n])\n     92, Generating Tesla code\n         94, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    102, Generating enter data copyin(c[:n])\n         Generating present(a[:n],c[:n],b[:n])\n    104, Generating Tesla code\n        106, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    110, Generating exit data copyout(c[:n])\n         Generating exit data delete(b[:n],a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9215385800926015
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0683590889675543,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_delete_finalize.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_delete_finalize.c/acc_delete_finalize.c0 /usa/chrismun/openacc/Tests/acc_delete_finalize.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_delete_finalize.c\", line 31: warning: function \"acc_delete_finalize\" declared implicitly\n      acc_delete_finalize(a, n * sizeof(real_t));\n      ^\n\n\"/usa/chrismun/openacc/Tests/acc_delete_finalize.c\", line 75: warning: function \"acc_delete_finalize\" declared implicitly\n      acc_delete_finalize(a, n * sizeof(real_t));\n      ^\n\ntest1:\n     21, Generating enter data copyin(b[:n],a[:n])\n         Generating copyout(c[:n]) [if not already present]\n     23, Generating present(b[:n],a[:n])\n         Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     65, Generating copyout(c[:n]) [if not already present]\n     67, Generating present(b[:n],a[:n])\n         Generating Tesla code\n         69, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n/usr/bin/ld: /tmp/nvcCjfMbuD0aQS6t.o: in function `test1':\n/usa/chrismun/openacc/Tests/acc_delete_finalize.c:31: undefined reference to `acc_delete_finalize'\n/usr/bin/ld: /usa/chrismun/openacc/Tests/acc_delete_finalize.c:32: undefined reference to `acc_delete_finalize'\n/usr/bin/ld: /tmp/nvcCjfMbuD0aQS6t.o: in function `test2':\n/usa/chrismun/openacc/Tests/acc_delete_finalize.c:75: undefined reference to `acc_delete_finalize'\n/usr/bin/ld: /usa/chrismun/openacc/Tests/acc_delete_finalize.c:76: undefined reference to `acc_delete_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.91996216296684
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/acc_delete_finalize.c/acc_delete_finalize.c1 /usa/chrismun/openacc/Tests/acc_delete_finalize.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_delete_finalize.c\", line 75: warning: function \"acc_delete_finalize\" declared implicitly\n      acc_delete_finalize(a, n * sizeof(real_t));\n      ^\n\ntest2:\n     65, Generating copyout(c[:n]) [if not already present]\n     67, Generating present(b[:n],a[:n])\n         Generating Tesla code\n         69, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n/usr/bin/ld: /tmp/nvckTfMbETH777Nj.o: in function `test2':\n/usa/chrismun/openacc/Tests/acc_delete_finalize.c:75: undefined reference to `acc_delete_finalize'\n/usr/bin/ld: /usa/chrismun/openacc/Tests/acc_delete_finalize.c:76: undefined reference to `acc_delete_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.8205975650344044
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/acc_delete_finalize.c/acc_delete_finalize.c2 /usa/chrismun/openacc/Tests/acc_delete_finalize.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_delete_finalize.c\", line 31: warning: function \"acc_delete_finalize\" declared implicitly\n      acc_delete_finalize(a, n * sizeof(real_t));\n      ^\n\ntest1:\n     21, Generating enter data copyin(b[:n],a[:n])\n         Generating copyout(c[:n]) [if not already present]\n     23, Generating present(b[:n],a[:n])\n         Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n/usr/bin/ld: /tmp/nvcprgMbTzwYMOqX.o: in function `test1':\n/usa/chrismun/openacc/Tests/acc_delete_finalize.c:31: undefined reference to `acc_delete_finalize'\n/usr/bin/ld: /usa/chrismun/openacc/Tests/acc_delete_finalize.c:32: undefined reference to `acc_delete_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.821021766983904
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/acc_delete_finalize.c/acc_delete_finalize.c3 /usa/chrismun/openacc/Tests/acc_delete_finalize.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_delete_finalize.c\", line 75: warning: function \"acc_delete_finalize\" declared implicitly\n      acc_delete_finalize(a, n * sizeof(real_t));\n      ^\n\ntest2:\n     65, Generating copyout(c[:n]) [if not already present]\n     67, Generating present(b[:n],a[:n])\n         Generating Tesla code\n         69, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n/usr/bin/ld: /tmp/nvcu1gMb8baCvKXY.o: in function `test2':\n/usa/chrismun/openacc/Tests/acc_delete_finalize.c:75: undefined reference to `acc_delete_finalize'\n/usr/bin/ld: /usa/chrismun/openacc/Tests/acc_delete_finalize.c:76: undefined reference to `acc_delete_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": true,
                    "output": "",
                    "result": 2,
                    "runtime": 2.8204187270021066
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": true,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_delete_finalize_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_delete_finalize_async.c/acc_delete_finalize_async.c0 /usa/chrismun/openacc/Tests/acc_delete_finalize_async.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_delete_finalize_async.c\", line 42: warning: function \"acc_delete_finalize_async\" declared implicitly\n          acc_delete_finalize_async(a, n * sizeof(real_t), 1);\n          ^\n\n\"/usa/chrismun/openacc/Tests/acc_delete_finalize_async.c\", line 101: warning: function \"acc_delete_finalize_async\" declared implicitly\n          acc_delete_finalize_async(c, n * sizeof(real_t), 1);\n          ^\n\ntest1:\n     27, Generating enter data copyin(e[:n],d[:n],b[:n],a[:n])\n         Generating present(a[:n],b[:n],d[:n],e[:n])\n         Generating copyout(f[:n],c[:n]) [if not already present]\n     29, Generating Tesla code\n         31, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     36, Generating Tesla code\n         38, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     78, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     92, Generating enter data copyin(c[:n],b[:n],a[:n])\n         Generating present(a[:n],c[:n],b[:n])\n     94, Generating Tesla code\n         96, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    104, Generating enter data copyin(c[:n])\n         Generating present(a[:n],c[:n],b[:n])\n    106, Generating Tesla code\n        108, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    112, Generating exit data copyout(c[:n])\n         Generating exit data delete(b[:n],a[:n])\n/usr/bin/ld: /tmp/nvcJBhMbPkttxc8N.o: in function `test1':\n/usa/chrismun/openacc/Tests/acc_delete_finalize_async.c:42: undefined reference to `acc_delete_finalize_async'\n/usr/bin/ld: /usa/chrismun/openacc/Tests/acc_delete_finalize_async.c:43: undefined reference to `acc_delete_finalize_async'\n/usr/bin/ld: /usa/chrismun/openacc/Tests/acc_delete_finalize_async.c:44: undefined reference to `acc_delete_finalize_async'\n/usr/bin/ld: /usa/chrismun/openacc/Tests/acc_delete_finalize_async.c:45: undefined reference to `acc_delete_finalize_async'\n/usr/bin/ld: /tmp/nvcJBhMbPkttxc8N.o: in function `test2':\n/usa/chrismun/openacc/Tests/acc_delete_finalize_async.c:101: undefined reference to `acc_delete_finalize_async'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.920618803007528
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/acc_delete_finalize_async.c/acc_delete_finalize_async.c1 /usa/chrismun/openacc/Tests/acc_delete_finalize_async.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_delete_finalize_async.c\", line 101: warning: function \"acc_delete_finalize_async\" declared implicitly\n          acc_delete_finalize_async(c, n * sizeof(real_t), 1);\n          ^\n\ntest2:\n     78, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     92, Generating enter data copyin(c[:n],b[:n],a[:n])\n         Generating present(a[:n],c[:n],b[:n])\n     94, Generating Tesla code\n         96, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    104, Generating enter data copyin(c[:n])\n         Generating present(a[:n],c[:n],b[:n])\n    106, Generating Tesla code\n        108, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    112, Generating exit data copyout(c[:n])\n         Generating exit data delete(b[:n],a[:n])\n/usr/bin/ld: /tmp/nvc0-hMbCKyb1Cmk.o: in function `test2':\n/usa/chrismun/openacc/Tests/acc_delete_finalize_async.c:101: undefined reference to `acc_delete_finalize_async'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.8209752299590036
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/acc_delete_finalize_async.c/acc_delete_finalize_async.c2 /usa/chrismun/openacc/Tests/acc_delete_finalize_async.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_delete_finalize_async.c\", line 42: warning: function \"acc_delete_finalize_async\" declared implicitly\n          acc_delete_finalize_async(a, n * sizeof(real_t), 1);\n          ^\n\ntest1:\n     27, Generating enter data copyin(e[:n],d[:n],b[:n],a[:n])\n         Generating present(a[:n],b[:n],d[:n],e[:n])\n         Generating copyout(f[:n],c[:n]) [if not already present]\n     29, Generating Tesla code\n         31, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     36, Generating Tesla code\n         38, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n/usr/bin/ld: /tmp/nvc5JiMbRKUhGNtI.o: in function `test1':\n/usa/chrismun/openacc/Tests/acc_delete_finalize_async.c:42: undefined reference to `acc_delete_finalize_async'\n/usr/bin/ld: /usa/chrismun/openacc/Tests/acc_delete_finalize_async.c:43: undefined reference to `acc_delete_finalize_async'\n/usr/bin/ld: /usa/chrismun/openacc/Tests/acc_delete_finalize_async.c:44: undefined reference to `acc_delete_finalize_async'\n/usr/bin/ld: /usa/chrismun/openacc/Tests/acc_delete_finalize_async.c:45: undefined reference to `acc_delete_finalize_async'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.869946007966064
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/acc_delete_finalize_async.c/acc_delete_finalize_async.c3 /usa/chrismun/openacc/Tests/acc_delete_finalize_async.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_delete_finalize_async.c\", line 101: warning: function \"acc_delete_finalize_async\" declared implicitly\n          acc_delete_finalize_async(c, n * sizeof(real_t), 1);\n          ^\n\ntest2:\n     78, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     92, Generating enter data copyin(c[:n],b[:n],a[:n])\n         Generating present(a[:n],c[:n],b[:n])\n     94, Generating Tesla code\n         96, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    104, Generating enter data copyin(c[:n])\n         Generating present(a[:n],c[:n],b[:n])\n    106, Generating Tesla code\n        108, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    112, Generating exit data copyout(c[:n])\n         Generating exit data delete(b[:n],a[:n])\n/usr/bin/ld: /tmp/nvcIhjMbMKe9tSIb.o: in function `test2':\n/usa/chrismun/openacc/Tests/acc_delete_finalize_async.c:101: undefined reference to `acc_delete_finalize_async'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": true,
                    "output": "",
                    "result": 2,
                    "runtime": 2.821223519043997
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": true,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_deviceptr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_deviceptr.c/acc_deviceptr.c0 /usa/chrismun/openacc/Tests/acc_deviceptr.c",
                    "config": 1,
                    "errors": "test1:\n     21, Generating enter data copyin(b[:n])\n         Generating enter data create(c[:n])\n         Generating enter data copyin(a[:n])\n     28, Generating Tesla code\n         30, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     34, Generating exit data delete(a[:n])\n         Generating exit data copyout(c[:n])\n         Generating exit data delete(b[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820567248039879
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018613216932863,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_free.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_free.c/acc_free.c0 /usa/chrismun/openacc/Tests/acc_free.c",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1187395619926974
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068836501915939,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_get_default_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_get_default_async.c/acc_get_default_async.c0 /usa/chrismun/openacc/Tests/acc_get_default_async.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     20, Generating Tesla code\n         22, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8707283249823377
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0186860639369115,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_get_device_num.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_get_device_num.c/acc_get_device_num.c0 /usa/chrismun/openacc/Tests/acc_get_device_num.c",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.11891503399238
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.2691137799993157,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_get_num_devices.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_get_num_devices.c/acc_get_num_devices.c0 /usa/chrismun/openacc/Tests/acc_get_num_devices.c",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.118774497997947
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 1.8682839660905302,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_get_property.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_get_property.c/acc_get_property.c0 /usa/chrismun/openacc/Tests/acc_get_property.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_get_property.c\", line 8: warning: variable \"returned_string1\" was set but never used\n          const char* returned_string1;\n                      ^\n\n\"/usa/chrismun/openacc/Tests/acc_get_property.c\", line 9: warning: variable \"returned_string2\" was set but never used\n          const char* returned_string2;\n                      ^\n\n\"/usa/chrismun/openacc/Tests/acc_get_property.c\", line 10: warning: variable \"returned_string3\" was set but never used\n          const char* returned_string3;\n                      ^\n\n\"/usa/chrismun/openacc/Tests/acc_get_property.c\", line 11: warning: variable \"returned_int\" was set but never used\n          int returned_int;\n              ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1187783459899947
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0187756930245087,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_hostptr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_hostptr.c/acc_hostptr.c0 /usa/chrismun/openacc/Tests/acc_hostptr.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_hostptr.c\", line 7: warning: variable \"a_ptr\" was set but never used\n      real_t *a_ptr;\n              ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1189829929498956
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0186852540355176,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_init.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_init.c/acc_init.c0 /usa/chrismun/openacc/Tests/acc_init.c",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.118934180936776
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0184409809298813,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_is_present.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_is_present.c/acc_is_present.c0 /usa/chrismun/openacc/Tests/acc_is_present.c",
                    "config": 1,
                    "errors": "test1:\n     12, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     17, Generating enter data create(a[:n])\n     22, Generating exit data delete(a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7704623279860243
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018908043974079,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_malloc.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_malloc.c/acc_malloc.c0 /usa/chrismun/openacc/Tests/acc_malloc.c",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1190058150095865
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 2.0188331010285765,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_map_data.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_map_data.c/acc_map_data.c0 /usa/chrismun/openacc/Tests/acc_map_data.c",
                    "config": 1,
                    "errors": "test1:\n     21, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n     23, Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     29, Generating update self(c[:n])\ntest2:\n     65, Generating copyin(b[:n],a[:n]) [if not already present]\n         Generating present(e[:n],c[:n])\n     67, Generating Tesla code\n         69, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     74, Generating Tesla code\n         76, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     80, Generating update self(c[:n],e[:n])\n     89, FMA (fused multiply-add) instruction(s) generated\ntest3:\n    118, Generating copyin(a[:n],b[:n]) [if not already present]\n    120, Generating Tesla code\n        122, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    130, Generating copyin(b[:n],a[:n]) [if not already present]\n         Generating present(c[:n])\n    132, Generating Tesla code\n        134, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    138, Generating update self(c[:n])\n    143, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9202452659374103
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1187620139680803,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_memcpy_device.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_memcpy_device.c/acc_memcpy_device.c0 /usa/chrismun/openacc/Tests/acc_memcpy_device.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating enter data create(c[:n],b[:n],a[:n])\n     25, Generating present(a[:n],c[:n],b[:n])\n     27, Generating Tesla code\n         29, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     33, Generating exit data copyout(b[:n],a[:n],c[:n])\n     51, Generating exit data delete(hostdata[:n*3])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8191209259675816
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failing in Thread:1\ncall to cuMemcpyDtoDAsync returned error 1: Invalid value\n\n",
                    "export": false,
                    "output": "",
                    "result": 1,
                    "runtime": 2.0189784769900143,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/acc_memcpy_device.c/acc_memcpy_device.c1 /usa/chrismun/openacc/Tests/acc_memcpy_device.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_memcpy_device.c\", line 57: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1191288880072534
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008703190949745476,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_memcpy_from_device.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_memcpy_from_device.c/acc_memcpy_from_device.c0 /usa/chrismun/openacc/Tests/acc_memcpy_from_device.c",
                    "config": 1,
                    "errors": "test1:\n     23, Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     50, Generating exit data delete(hostdata[:n*3])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7699377050157636
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068843415006995,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_memcpy_from_device_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_memcpy_from_device_async.c/acc_memcpy_from_device_async.c0 /usa/chrismun/openacc/Tests/acc_memcpy_from_device_async.c",
                    "config": 1,
                    "errors": "test1:\n     26, Memory copy idiom, loop replaced by call to __c_mcopy8\n     35, Generating Tesla code\n         37, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     43, Generating Tesla code\n         45, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     51, Generating Tesla code\n         53, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     59, Generating Tesla code\n         61, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     67, Generating Tesla code\n         69, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     75, Generating Tesla code\n         77, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     86, FMA (fused multiply-add) instruction(s) generated\n     92, FMA (fused multiply-add) instruction(s) generated\n     98, FMA (fused multiply-add) instruction(s) generated\n    104, FMA (fused multiply-add) instruction(s) generated\n    123, Generating exit data delete(hostdata[:n*6])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8702251760987565
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.2192240129224956,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_memcpy_to_device.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_memcpy_to_device.c/acc_memcpy_to_device.c0 /usa/chrismun/openacc/Tests/acc_memcpy_to_device.c",
                    "config": 1,
                    "errors": "test1:\n     27, Generating Tesla code\n         29, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     33, Generating exit data copyout(hostdata[:n*3])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8199902180349454
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068517058971338,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_memcpy_to_device_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_memcpy_to_device_async.c/acc_memcpy_to_device_async.c0 /usa/chrismun/openacc/Tests/acc_memcpy_to_device_async.c",
                    "config": 1,
                    "errors": "test1:\n     47, Generating Tesla code\n         49, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     54, Generating Tesla code\n         56, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     61, Generating Tesla code\n         63, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     68, Generating Tesla code\n         70, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     75, Generating Tesla code\n         77, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     82, Generating Tesla code\n         84, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     88, Generating update self(hostdata[n*5:n],hostdata[n+n:n])\n     95, FMA (fused multiply-add) instruction(s) generated\n    102, FMA (fused multiply-add) instruction(s) generated\n    109, Generating exit data delete(hostdata[:n*6])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8706193800317124
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.168593178037554,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_on_device.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_on_device.c/acc_on_device.c0 /usa/chrismun/openacc/Tests/acc_on_device.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_on_device.c\", line 13: warning: enumerated type mixed with another type\n                  if (acc_on_device(device_type) == 0){\n                                    ^\n\ntest1:\n     10, Generating copy(err) [if not already present]\n     12, Scalar last value needed after loop for err at line 28\n         Generating Tesla code\n     21, Scalar last value needed after loop for err at line 28\n         Generating Tesla code\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820135301910341
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018887513084337,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_set_default_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_set_default_async.c/acc_set_default_async.c0 /usa/chrismun/openacc/Tests/acc_set_default_async.c",
                    "config": 1,
                    "errors": "test1:\n     21, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     32, Generating Tesla code\n         34, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     39, Generating Tesla code\n         41, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     49, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8701821650611237
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018640827969648,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_set_device_num.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_set_device_num.c/acc_set_device_num.c0 /usa/chrismun/openacc/Tests/acc_set_device_num.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating enter data copyin(a[:n])\n     24, Generating present(a[:n])\n     26, Generating Tesla code\n         28, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     35, Generating exit data copyout(a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7698336909525096
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.3192059149732813,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_set_device_type.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_set_device_type.c/acc_set_device_type.c0 /usa/chrismun/openacc/Tests/acc_set_device_type.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/acc_set_device_type.c\", line 9: warning: enumerated type mixed with another type\n      acc_set_device_type(device_type);\n                          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1184970049653202
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0188173620263115,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_shutdown.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_shutdown.c/acc_shutdown.c0 /usa/chrismun/openacc/Tests/acc_shutdown.c",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.119140548980795
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 1.918232231051661,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_unmap_data.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_unmap_data.c/acc_unmap_data.c0 /usa/chrismun/openacc/Tests/acc_unmap_data.c",
                    "config": 1,
                    "errors": "test1:\n     21, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n     23, Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     29, Generating update self(c[:n])\ntest2:\n     65, Generating copyin(b[:n],a[:n]) [if not already present]\n         Generating present(e[:n],c[:n])\n     67, Generating Tesla code\n         69, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     74, Generating Tesla code\n         76, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     80, Generating update self(c[:n],e[:n])\n     89, FMA (fused multiply-add) instruction(s) generated\ntest3:\n    118, Generating copyin(a[:n],b[:n]) [if not already present]\n    120, Generating Tesla code\n        122, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    130, Generating copyin(b[:n],a[:n]) [if not already present]\n         Generating present(c[:n])\n    132, Generating Tesla code\n        134, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    138, Generating update self(c[:n])\n    143, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.920133425970562
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0188594119390473,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_update_device.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_update_device.c/acc_update_device.c0 /usa/chrismun/openacc/Tests/acc_update_device.c",
                    "config": 1,
                    "errors": "test1:\n     14, Generating enter data copyin(devtest[:1])\n         Generating Tesla code\n         Generating implicit copyout(devtest[0]) [if not already present]\n     25, Generating copyout(c[:n]) [if not already present]\n         Generating create(b[:n],a[:n]) [if not already present]\n     29, Generating Tesla code\n         31, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     59, Generating enter data copyin(devtest[:1])\n         Generating Tesla code\n         Generating implicit copyout(devtest[0]) [if not already present]\n     71, Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n],a[:n]) [if not already present]\n     73, Generating Tesla code\n         75, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     81, Generating Tesla code\n         83, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     89, Generating Tesla code\n         91, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870065615978092
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0680251800222322,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_update_device_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_update_device_async.c/acc_update_device_async.c0 /usa/chrismun/openacc/Tests/acc_update_device_async.c",
                    "config": 1,
                    "errors": "test1:\n     17, Generating enter data copyin(devtest[:1])\n         Generating Tesla code\n         Generating implicit copyout(devtest[0]) [if not already present]\n     32, Generating copyout(c[:n]) [if not already present]\n         Generating create(b[:n],a[:n]) [if not already present]\n     35, Generating Tesla code\n         37, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     43, Generating Tesla code\n         45, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     50, Generating Tesla code\n         52, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     60, FMA (fused multiply-add) instruction(s) generated\ntest2:\n     84, Generating enter data copyin(devtest[:1])\n         Generating Tesla code\n         Generating implicit copyout(devtest[0]) [if not already present]\n     96, Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n],a[:n]) [if not already present]\n     98, Generating Tesla code\n        100, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    106, Generating Tesla code\n        108, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    114, Generating Tesla code\n        116, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870352428057231
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.117900977958925,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_update_self.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_update_self.c/acc_update_self.c0 /usa/chrismun/openacc/Tests/acc_update_self.c",
                    "config": 1,
                    "errors": "test1:\n     17, Generating copyin(b[:n]) [if not already present]\n         Generating create(c[:n]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     19, Generating Tesla code\n         21, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     53, Generating copyin(b[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     55, Generating Tesla code\n         57, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     63, Generating Tesla code\n         65, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     71, Generating Tesla code\n         73, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.82048268802464
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018805428990163,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_update_self_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_update_self_async.c/acc_update_self_async.c0 /usa/chrismun/openacc/Tests/acc_update_self_async.c",
                    "config": 1,
                    "errors": "test1:\n     16, Generating enter data copyin(devtest[:1])\n         Generating Tesla code\n         Generating implicit copyout(devtest[0]) [if not already present]\n     30, Generating copyin(b[:n]) [if not already present]\n         Generating create(c[:n],d[:n]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     32, Generating Tesla code\n         34, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     39, Generating Tesla code\n         41, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     54, FMA (fused multiply-add) instruction(s) generated\ntest2:\n     77, Generating enter data copyin(devtest[:1])\n         Generating Tesla code\n         Generating implicit copyout(devtest[0]) [if not already present]\n     89, Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n],a[:n]) [if not already present]\n     91, Generating Tesla code\n         93, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     99, Generating Tesla code\n        101, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    107, Generating Tesla code\n        109, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    114, Generating Tesla code\n        116, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    121, Generating Tesla code\n        123, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    132, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870470799971372
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1188240800984204,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_wait.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_wait.c/acc_wait.c0 /usa/chrismun/openacc/Tests/acc_wait.c",
                    "config": 1,
                    "errors": "test1:\n     23, Generating enter data copyin(b[:n],a[:n],d[:n])\n         Generating enter data create(e[:n],c[:n])\n         Generating present(a[:n],c[:n],b[:n])\n         Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     30, Generating present(c[:n],e[:n],d[:n])\n         Generating Tesla code\n         32, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     38, Generating exit data copyout(e[:n])\n     47, Generating exit data delete(d[:n],c[:n],b[:n],a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.869904680061154
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068592121009715,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_wait_all.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_wait_all.c/acc_wait_all.c0 /usa/chrismun/openacc/Tests/acc_wait_all.c",
                    "config": 1,
                    "errors": "test1:\n     25, Generating copyin(a[:n],b[:n],c[:n]) [if not already present]\n         Generating copyout(d[:n]) [if not already present]\n     27, Generating Tesla code\n         29, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     34, Generating Tesla code\n         36, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     41, Generating Tesla code\n         43, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     49, Generating Tesla code\n         51, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     58, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.87070073292125
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018626483040862,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_wait_all_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_wait_all_async.c/acc_wait_all_async.c0 /usa/chrismun/openacc/Tests/acc_wait_all_async.c",
                    "config": 1,
                    "errors": "test1:\n     39, Generating copyin(a[:n]) [if not already present]\n         Generating create(c[:n]) [if not already present]\n         Generating copyin(d[:n]) [if not already present]\n         Generating create(f[:n]) [if not already present]\n         Generating copyin(g[:n],b[:n],e[:n],h[:n]) [if not already present]\n         Generating create(i[:n]) [if not already present]\n         Generating copyout(k[:n]) [if not already present]\n         Generating create(j[:n]) [if not already present]\n     41, Generating Tesla code\n         43, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     48, Generating Tesla code\n         50, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     55, Generating Tesla code\n         57, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     63, Generating Tesla code\n         65, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     70, Generating Tesla code\n         71, #pragma acc loop seq\n     71, Complex loop carried dependence of c->,b-> prevents parallelization\n         Loop carried dependence of a-> prevents parallelization\n         Loop carried backward dependence of a-> prevents vectorization\n     76, Generating Tesla code\n         77, #pragma acc loop seq\n     77, Complex loop carried dependence of f->,e-> prevents parallelization\n         Loop carried dependence of d-> prevents parallelization\n         Loop carried backward dependence of d-> prevents vectorization\n     82, Generating Tesla code\n         83, #pragma acc loop seq\n     83, Complex loop carried dependence of i->,h-> prevents parallelization\n         Loop carried dependence of g-> prevents parallelization\n         Loop carried backward dependence of g-> prevents vectorization\n     89, Generating Tesla code\n         91, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    101, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.920352587942034
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0687832511030138,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_wait_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/acc_wait_async.c/acc_wait_async.c0 /usa/chrismun/openacc/Tests/acc_wait_async.c",
                    "config": 1,
                    "errors": "test1:\n     29, Generating copyin(a[:n]) [if not already present]\n         Generating create(c[:n]) [if not already present]\n         Generating copyin(d[:n]) [if not already present]\n         Generating create(f[:n]) [if not already present]\n         Generating copyin(b[:n],e[:n],g[:n]) [if not already present]\n         Generating copyout(i[:n]) [if not already present]\n         Generating create(h[:n]) [if not already present]\n     31, Generating Tesla code\n         33, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     39, Generating Tesla code\n         41, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     46, Generating Tesla code\n         48, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     54, Generating Tesla code\n         56, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8195059249410406
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018809649045579,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_bitand_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_bitand_equals.c/atomic_bitand_equals.c0 /usa/chrismun/openacc/Tests/atomic_bitand_equals.c",
                    "config": 1,
                    "errors": "test1:\n     26, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     28, Generating Tesla code\n         30, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7701012660982087
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 2.0688671600073576,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_bitor_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_bitor_equals.c/atomic_bitor_equals.c0 /usa/chrismun/openacc/Tests/atomic_bitor_equals.c",
                    "config": 1,
                    "errors": "test1:\n     18, Memory zero idiom, loop replaced by call to __c_mzero4\n     24, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     26, Generating Tesla code\n         28, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8195149110397324
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0187112039420754,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_bitxor_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_bitxor_equals.c/atomic_bitxor_equals.c0 /usa/chrismun/openacc/Tests/atomic_bitxor_equals.c",
                    "config": 1,
                    "errors": "test1:\n     24, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     26, Generating Tesla code\n         28, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8200279290322214
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0687201929977164,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_bitand_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_bitand_equals.c/atomic_capture_bitand_equals.c0 /usa/chrismun/openacc/Tests/atomic_capture_bitand_equals.c",
                    "config": 1,
                    "errors": "NVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_bitand_equals.c: 70)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_bitand_equals.c: 70)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_bitand_equals.c: 70)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_bitand_equals.c: 70)\ntest1:\n     64, Generating copyout(b[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     66, Generating Tesla code\n         68, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0184260129462928
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_bitand_equals.c/atomic_capture_bitand_equals.c1 /usa/chrismun/openacc/Tests/atomic_capture_bitand_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_bitand_equals.c\", line 103: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1186788680497557
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008802858996205032,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_bitor_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_bitor_equals.c/atomic_capture_bitor_equals.c0 /usa/chrismun/openacc/Tests/atomic_capture_bitor_equals.c",
                    "config": 1,
                    "errors": "NVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_bitor_equals.c: 66)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_bitor_equals.c: 66)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_bitor_equals.c: 66)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_bitor_equals.c: 66)\ntest1:\n     55, Memory zero idiom, loop replaced by call to __c_mzero4\n     60, Generating copyout(b[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     62, Generating Tesla code\n         64, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0185609289910644
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_bitor_equals.c/atomic_capture_bitor_equals.c1 /usa/chrismun/openacc/Tests/atomic_capture_bitor_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_bitor_equals.c\", line 96: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1185587220825255
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008352458011358976,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_bitxor_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_bitxor_equals.c/atomic_capture_bitxor_equals.c0 /usa/chrismun/openacc/Tests/atomic_capture_bitxor_equals.c",
                    "config": 1,
                    "errors": "NVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_bitxor_equals.c: 63)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_bitxor_equals.c: 63)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_bitxor_equals.c: 63)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_bitxor_equals.c: 63)\ntest1:\n     57, Generating copyout(b[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     59, Generating Tesla code\n         61, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0183110979851335
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_bitxor_equals.c/atomic_capture_bitxor_equals.c1 /usa/chrismun/openacc/Tests/atomic_capture_bitxor_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_bitxor_equals.c\", line 94: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1190947209252045
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008690276998095214,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_divided_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_divided_equals.c/atomic_capture_divided_equals.c0 /usa/chrismun/openacc/Tests/atomic_capture_divided_equals.c",
                    "config": 1,
                    "errors": "NVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_divided_equals.c: 68)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_divided_equals.c: 68)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_divided_equals.c: 68)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_divided_equals.c: 68)\ntest1:\n     62, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     64, Generating Tesla code\n         66, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.121390632004477
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_divided_equals.c/atomic_capture_divided_equals.c1 /usa/chrismun/openacc/Tests/atomic_capture_divided_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_divided_equals.c\", line 102: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1193770159734413
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008758425945416093,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_bitand_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_expr_bitand_x.c/atomic_capture_expr_bitand_x.c0 /usa/chrismun/openacc/Tests/atomic_capture_expr_bitand_x.c",
                    "config": 1,
                    "errors": "NVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_expr_bitand_x.c: 66)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_expr_bitand_x.c: 66)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_expr_bitand_x.c: 66)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_expr_bitand_x.c: 66)\ntest1:\n     60, Generating copyout(b[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     62, Generating Tesla code\n         64, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.018726559006609
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_expr_bitand_x.c/atomic_capture_expr_bitand_x.c1 /usa/chrismun/openacc/Tests/atomic_capture_expr_bitand_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_expr_bitand_x.c\", line 101: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1185110609512776
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008773843990638852,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_bitor_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_expr_bitor_x.c/atomic_capture_expr_bitor_x.c0 /usa/chrismun/openacc/Tests/atomic_capture_expr_bitor_x.c",
                    "config": 1,
                    "errors": "NVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_expr_bitor_x.c: 63)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_expr_bitor_x.c: 63)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_expr_bitor_x.c: 63)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_expr_bitor_x.c: 63)\ntest1:\n     51, Memory zero idiom, loop replaced by call to __c_mzero4\n     57, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     59, Generating Tesla code\n         61, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0188473579473794
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_expr_bitor_x.c/atomic_capture_expr_bitor_x.c1 /usa/chrismun/openacc/Tests/atomic_capture_expr_bitor_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_expr_bitor_x.c\", line 93: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1188461129786447
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008746172999963164,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_bitxor_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_expr_bitxor_x.c/atomic_capture_expr_bitxor_x.c0 /usa/chrismun/openacc/Tests/atomic_capture_expr_bitxor_x.c",
                    "config": 1,
                    "errors": "NVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_expr_bitxor_x.c: 63)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_expr_bitxor_x.c: 63)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_expr_bitxor_x.c: 63)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_expr_bitxor_x.c: 63)\ntest1:\n     57, Generating copyout(b[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     59, Generating Tesla code\n         61, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.026392124942504
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_expr_bitxor_x.c/atomic_capture_expr_bitxor_x.c1 /usa/chrismun/openacc/Tests/atomic_capture_expr_bitxor_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_expr_bitxor_x.c\", line 94: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1693025580607355
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008474158006720245,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_divided_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_expr_divided_x.c/atomic_capture_expr_divided_x.c0 /usa/chrismun/openacc/Tests/atomic_capture_expr_divided_x.c",
                    "config": 1,
                    "errors": "possible_result:\n     41, Memory copy idiom, loop replaced by call to __c_mcopy8\n     44, Memory copy idiom, loop replaced by call to __c_mcopy8\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_expr_divided_x.c: 87)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_expr_divided_x.c: 87)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_expr_divided_x.c: 87)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_expr_divided_x.c: 87)\ntest1:\n     76, Memory set idiom, loop replaced by call to __c_mset8\n     81, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     83, Generating Tesla code\n         85, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.019031228031963
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_expr_divided_x.c/atomic_capture_expr_divided_x.c1 /usa/chrismun/openacc/Tests/atomic_capture_expr_divided_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_expr_divided_x.c\", line 120: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\npossible_result:\n     41, Memory copy idiom, loop replaced by call to __c_mcopy8\n     44, Memory copy idiom, loop replaced by call to __c_mcopy8\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1688807120081037
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00882663403172046,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_lshift_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_expr_lshift_x.c/atomic_capture_expr_lshift_x.c0 /usa/chrismun/openacc/Tests/atomic_capture_expr_lshift_x.c",
                    "config": 1,
                    "errors": "NVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_expr_lshift_x.c: 57)\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_expr_lshift_x.c: 57)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_expr_lshift_x.c: 57)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_expr_lshift_x.c: 57)\ntest1:\n     49, Generating copyin(a[:n*3]) [if not already present]\n         Generating copyout(c[:n*3]) [if not already present]\n         Generating copy(b[:n]) [if not already present]\n     51, Generating Tesla code\n         53, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         55, #pragma acc loop seq\n     55, Loop is parallelizable\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.01851024501957
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_expr_lshift_x.c/atomic_capture_expr_lshift_x.c1 /usa/chrismun/openacc/Tests/atomic_capture_expr_lshift_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_expr_lshift_x.c\", line 90: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.118928167037666
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008408103953115642,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_minus_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_expr_minus_x.c/atomic_capture_expr_minus_x.c0 /usa/chrismun/openacc/Tests/atomic_capture_expr_minus_x.c",
                    "config": 1,
                    "errors": "possible_result:\n     42, Memory copy idiom, loop replaced by call to __c_mcopy8\n     45, Memory copy idiom, loop replaced by call to __c_mcopy8\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_expr_minus_x.c: 86)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_expr_minus_x.c: 86)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_expr_minus_x.c: 86)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_expr_minus_x.c: 86)\ntest1:\n     75, Memory zero idiom, loop replaced by call to __c_mzero8\n     80, Generating copyout(b[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     82, Generating Tesla code\n         84, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.018171323928982
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_expr_minus_x.c/atomic_capture_expr_minus_x.c1 /usa/chrismun/openacc/Tests/atomic_capture_expr_minus_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_expr_minus_x.c\", line 118: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\npossible_result:\n     42, Memory copy idiom, loop replaced by call to __c_mcopy8\n     45, Memory copy idiom, loop replaced by call to __c_mcopy8\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1189952560234815
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008671370916999876,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_multiply_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_expr_multiply_x.c/atomic_capture_expr_multiply_x.c0 /usa/chrismun/openacc/Tests/atomic_capture_expr_multiply_x.c",
                    "config": 1,
                    "errors": "is_possible:\n      9, FMA (fused multiply-add) instruction(s) generated\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_expr_multiply_x.c: 61)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_expr_multiply_x.c: 61)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_expr_multiply_x.c: 61)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_expr_multiply_x.c: 61)\ntest1:\n     55, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     57, Generating Tesla code\n         59, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0188667559996247
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_expr_multiply_x.c/atomic_capture_expr_multiply_x.c1 /usa/chrismun/openacc/Tests/atomic_capture_expr_multiply_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_expr_multiply_x.c\", line 92: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\nis_possible:\n      9, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.119325860054232
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008332090103067458,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_plus_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_expr_plus_x.c/atomic_capture_expr_plus_x.c0 /usa/chrismun/openacc/Tests/atomic_capture_expr_plus_x.c",
                    "config": 1,
                    "errors": "NVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_expr_plus_x.c: 61)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_expr_plus_x.c: 61)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_expr_plus_x.c: 61)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_expr_plus_x.c: 61)\ntest1:\n     55, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copy(totals[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     57, Generating Tesla code\n         59, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0188161979895085
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_expr_plus_x.c/atomic_capture_expr_plus_x.c1 /usa/chrismun/openacc/Tests/atomic_capture_expr_plus_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_expr_plus_x.c\", line 92: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068449339014478
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008808248909190297,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_rshift_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_expr_rshift_x.c/atomic_capture_expr_rshift_x.c0 /usa/chrismun/openacc/Tests/atomic_capture_expr_rshift_x.c",
                    "config": 1,
                    "errors": "NVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_expr_rshift_x.c: 57)\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_expr_rshift_x.c: 57)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_expr_rshift_x.c: 57)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_expr_rshift_x.c: 57)\ntest1:\n     49, Generating copyin(a[:n*3]) [if not already present]\n         Generating copyout(c[:n*3]) [if not already present]\n         Generating copy(b[:n]) [if not already present]\n     51, Generating Tesla code\n         53, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         55, #pragma acc loop seq\n     55, Loop is parallelizable\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0690379320876673
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_expr_rshift_x.c/atomic_capture_expr_rshift_x.c1 /usa/chrismun/openacc/Tests/atomic_capture_expr_rshift_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_expr_rshift_x.c\", line 90: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.119062001002021
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00872007291764021,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_lshift_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_lshift_equals.c/atomic_capture_lshift_equals.c0 /usa/chrismun/openacc/Tests/atomic_capture_lshift_equals.c",
                    "config": 1,
                    "errors": "NVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_lshift_equals.c: 62)\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_lshift_equals.c: 62)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_lshift_equals.c: 62)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_lshift_equals.c: 62)\ntest1:\n     52, Generating copy(a[:n]) [if not already present]\n         Generating copyout(c[:n*7]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     54, Generating Tesla code\n         56, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         58, #pragma acc loop seq\n     58, Loop is parallelizable\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0190107179805636
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_lshift_equals.c/atomic_capture_lshift_equals.c1 /usa/chrismun/openacc/Tests/atomic_capture_lshift_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_lshift_equals.c\", line 92: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1185043660225347
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00873140397015959,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_minus_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_minus_equals.c/atomic_capture_minus_equals.c0 /usa/chrismun/openacc/Tests/atomic_capture_minus_equals.c",
                    "config": 1,
                    "errors": "NVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_minus_equals.c: 60)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_minus_equals.c: 60)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_minus_equals.c: 60)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_minus_equals.c: 60)\ntest1:\n     54, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     56, Generating Tesla code\n         58, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0186880209948868
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_minus_equals.c/atomic_capture_minus_equals.c1 /usa/chrismun/openacc/Tests/atomic_capture_minus_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_minus_equals.c\", line 90: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.118607251904905
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008363088010810316,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_multiply_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_multiply_equals.c/atomic_capture_multiply_equals.c0 /usa/chrismun/openacc/Tests/atomic_capture_multiply_equals.c",
                    "config": 1,
                    "errors": "is_possible:\n      9, FMA (fused multiply-add) instruction(s) generated\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_multiply_equals.c: 61)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_multiply_equals.c: 61)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_multiply_equals.c: 61)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_multiply_equals.c: 61)\ntest1:\n     55, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     57, Generating Tesla code\n         59, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0184530050028116
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_multiply_equals.c/atomic_capture_multiply_equals.c1 /usa/chrismun/openacc/Tests/atomic_capture_multiply_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_multiply_equals.c\", line 92: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\nis_possible:\n      9, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1186491909902543
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008852061931975186,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_plus_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_plus_equals.c/atomic_capture_plus_equals.c0 /usa/chrismun/openacc/Tests/atomic_capture_plus_equals.c",
                    "config": 1,
                    "errors": "NVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_plus_equals.c: 61)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_plus_equals.c: 61)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_plus_equals.c: 61)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_plus_equals.c: 61)\ntest1:\n     55, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     57, Generating Tesla code\n         59, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     67, FMA (fused multiply-add) instruction(s) generated\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0183533480158076
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_plus_equals.c/atomic_capture_plus_equals.c1 /usa/chrismun/openacc/Tests/atomic_capture_plus_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_plus_equals.c\", line 92: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1188974200049415
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008330086013302207,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_postdecrement.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_postdecrement.c/atomic_capture_postdecrement.c0 /usa/chrismun/openacc/Tests/atomic_capture_postdecrement.c",
                    "config": 1,
                    "errors": "test1:\n     23, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copy(distribution[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     25, Generating Tesla code\n         27, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7702411089558154
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0184960259357467,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_postincrement.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_postincrement.c/atomic_capture_postincrement.c0 /usa/chrismun/openacc/Tests/atomic_capture_postincrement.c",
                    "config": 1,
                    "errors": "test1:\n     23, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copy(distribution[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     25, Generating Tesla code\n         27, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820332536008209
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0689066749764606,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_predecrement.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_predecrement.c/atomic_capture_predecrement.c0 /usa/chrismun/openacc/Tests/atomic_capture_predecrement.c",
                    "config": 1,
                    "errors": "NVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_predecrement.c: 29)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_predecrement.c: 29)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_predecrement.c: 29)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_predecrement.c: 29)\ntest1:\n     23, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copy(distribution[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     25, Generating Tesla code\n         27, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.018436482991092
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_predecrement.c/atomic_capture_predecrement.c1 /usa/chrismun/openacc/Tests/atomic_capture_predecrement.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_predecrement.c\", line 66: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1186380619183183
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008339534047991037,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_preincrement.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_preincrement.c/atomic_capture_preincrement.c0 /usa/chrismun/openacc/Tests/atomic_capture_preincrement.c",
                    "config": 1,
                    "errors": "NVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_preincrement.c: 29)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_preincrement.c: 29)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_preincrement.c: 29)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_preincrement.c: 29)\ntest1:\n     23, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copy(distribution[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     25, Generating Tesla code\n         27, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0686137119773775
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_preincrement.c/atomic_capture_preincrement.c1 /usa/chrismun/openacc/Tests/atomic_capture_preincrement.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_preincrement.c\", line 66: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1188356219790876
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008818178088404238,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_rshift_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_capture_rshift_equals.c/atomic_capture_rshift_equals.c0 /usa/chrismun/openacc/Tests/atomic_capture_rshift_equals.c",
                    "config": 1,
                    "errors": "NVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_rshift_equals.c: 62)\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/usa/chrismun/openacc/Tests/atomic_capture_rshift_equals.c: 62)\nNVC++-S-0155-Invalid atomic update expression  (/usa/chrismun/openacc/Tests/atomic_capture_rshift_equals.c: 62)\nNVC++-S-0155-Invalid atomic capture.  (/usa/chrismun/openacc/Tests/atomic_capture_rshift_equals.c: 62)\ntest1:\n     52, Generating copy(a[:n]) [if not already present]\n         Generating copyout(c[:n*7]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     54, Generating Tesla code\n         56, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         58, #pragma acc loop seq\n     58, Loop is parallelizable\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0685089849866927
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_capture_rshift_equals.c/atomic_capture_rshift_equals.c1 /usa/chrismun/openacc/Tests/atomic_capture_rshift_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_capture_rshift_equals.c\", line 92: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0683625659439713
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008705275016836822,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_divided_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_divided_equals.c/atomic_divided_equals.c0 /usa/chrismun/openacc/Tests/atomic_divided_equals.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.819865864003077
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018738663988188,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_bitand_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_expr_bitand_x.c/atomic_expr_bitand_x.c0 /usa/chrismun/openacc/Tests/atomic_expr_bitand_x.c",
                    "config": 1,
                    "errors": "test1:\n     27, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     29, Generating Tesla code\n         31, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820678198011592
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0680757249938324,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_bitor_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_expr_bitor_x.c/atomic_expr_bitor_x.c0 /usa/chrismun/openacc/Tests/atomic_expr_bitor_x.c",
                    "config": 1,
                    "errors": "test1:\n     18, Memory zero idiom, loop replaced by call to __c_mzero4\n     24, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     26, Generating Tesla code\n         28, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7697215089574456
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018612696090713,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_bitxor_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_expr_bitxor_x.c/atomic_expr_bitxor_x.c0 /usa/chrismun/openacc/Tests/atomic_expr_bitxor_x.c",
                    "config": 1,
                    "errors": "test1:\n     24, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     26, Generating Tesla code\n         28, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.819701452041045
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0185731219826266,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_divided_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_expr_divided_x.c/atomic_expr_divided_x.c0 /usa/chrismun/openacc/Tests/atomic_expr_divided_x.c",
                    "config": 1,
                    "errors": "possible_result:\n     13, Memory copy idiom, loop replaced by call to __c_mcopy8\n     16, Memory copy idiom, loop replaced by call to __c_mcopy8\ntest1:\n     43, Memory set idiom, loop replaced by call to __c_mset8\n     48, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n     50, Generating Tesla code\n         52, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8706240199971944
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0191241210559383,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_lshift_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_expr_lshift_x.c/atomic_expr_lshift_x.c0 /usa/chrismun/openacc/Tests/atomic_expr_lshift_x.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating copyin(a[:n*3]) [if not already present]\n         Generating copy(b[:n]) [if not already present]\n     22, Generating Tesla code\n         24, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop seq\n     26, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8197934669442475
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 2.0686744960257784,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_minus_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_expr_minus_x.c/atomic_expr_minus_x.c0 /usa/chrismun/openacc/Tests/atomic_expr_minus_x.c",
                    "config": 1,
                    "errors": "possible_result:\n     13, Memory copy idiom, loop replaced by call to __c_mcopy8\n     16, Memory copy idiom, loop replaced by call to __c_mcopy8\ntest1:\n     41, Memory zero idiom, loop replaced by call to __c_mzero8\n     46, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     48, Generating Tesla code\n         50, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8701645999681205
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0682061120169237,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_multiply_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_expr_multiply_x.c/atomic_expr_multiply_x.c0 /usa/chrismun/openacc/Tests/atomic_expr_multiply_x.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8695034919073805
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068435045075603,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_plus_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_expr_plus_x.c/atomic_expr_plus_x.c0 /usa/chrismun/openacc/Tests/atomic_expr_plus_x.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang /* blockIdx.x */\n         28, #pragma acc loop vector(128) /* threadIdx.x */\n     28, Loop is parallelizable\n     37, Zero trip check eliminated\n     38, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8204455099767074
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 2.018856987939216,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_rshift_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_expr_rshift_x.c/atomic_expr_rshift_x.c0 /usa/chrismun/openacc/Tests/atomic_expr_rshift_x.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating copyin(a[:n*3]) [if not already present]\n         Generating copy(b[:n]) [if not already present]\n     22, Generating Tesla code\n         24, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop seq\n     26, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8198787790024653
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 2.0692429600749165,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_lshift_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_lshift_equals.c/atomic_lshift_equals.c0 /usa/chrismun/openacc/Tests/atomic_lshift_equals.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating copy(a[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     22, Generating Tesla code\n         24, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop seq\n     26, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820317436940968
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068440123926848,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_minus_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_minus_equals.c/atomic_minus_equals.c0 /usa/chrismun/openacc/Tests/atomic_minus_equals.c",
                    "config": 1,
                    "errors": "test1:\n     21, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     23, Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.869985242956318
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018724858062342,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_multiply_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_multiply_equals.c/atomic_multiply_equals.c0 /usa/chrismun/openacc/Tests/atomic_multiply_equals.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9202730999095365
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0182650700444356,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_plus_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_plus_equals.c/atomic_plus_equals.c0 /usa/chrismun/openacc/Tests/atomic_plus_equals.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     34, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8708011830458418
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018832130008377,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_postdecrement.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_postdecrement.c/atomic_postdecrement.c0 /usa/chrismun/openacc/Tests/atomic_postdecrement.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(distribution[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.769571173004806
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0180786959826946,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_postincrement.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_postincrement.c/atomic_postincrement.c0 /usa/chrismun/openacc/Tests/atomic_postincrement.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(distribution[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang /* blockIdx.x */\n         28, #pragma acc loop vector(128) /* threadIdx.x */\n     28, Loop is parallelizable\n     37, Zero trip check eliminated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8203083589905873
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.06905134790577,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_predecrement.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_predecrement.c/atomic_predecrement.c0 /usa/chrismun/openacc/Tests/atomic_predecrement.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(distribution[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang /* blockIdx.x */\n         28, #pragma acc loop vector(128) /* threadIdx.x */\n     28, Loop is parallelizable\n     37, Zero trip check eliminated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870719729922712
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0691338650649413,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_preincrement.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_preincrement.c/atomic_preincrement.c0 /usa/chrismun/openacc/Tests/atomic_preincrement.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(distribution[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang /* blockIdx.x */\n         28, #pragma acc loop vector(128) /* threadIdx.x */\n     28, Loop is parallelizable\n     37, Zero trip check eliminated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8199897080194205
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068194188992493,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_rshift_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_rshift_equals.c/atomic_rshift_equals.c0 /usa/chrismun/openacc/Tests/atomic_rshift_equals.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating copy(a[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     22, Generating Tesla code\n         24, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop seq\n     26, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8203224459430203
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018466721056029,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_assign.c/atomic_structured_assign_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_assign.c\", line 24: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0185065149562433
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_assign.c/atomic_structured_assign_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_assign.c\", line 48: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069110419950448
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008710275054909289,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_bitand_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_bitand_equals.c/atomic_structured_assign_bitand_equals.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_bitand_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_bitand_equals.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_assign_bitand_equals.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_assign_bitand_equals.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_bitand_equals.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.018214453011751
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_bitand_equals.c/atomic_structured_assign_bitand_equals.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_bitand_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_bitand_equals.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1191302710212767
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008686078013852239,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_bitor_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_bitor_equals.c/atomic_structured_assign_bitor_equals.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_bitor_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_bitor_equals.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_assign_bitor_equals.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_assign_bitor_equals.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_bitor_equals.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.967731386073865
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_bitor_equals.c/atomic_structured_assign_bitor_equals.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_bitor_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_bitor_equals.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1187984040006995
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008439332013949752,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_bitxor_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_bitxor_equals.c/atomic_structured_assign_bitxor_equals.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_bitxor_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_bitxor_equals.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_assign_bitxor_equals.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_assign_bitxor_equals.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_bitxor_equals.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0189716450404376
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_bitxor_equals.c/atomic_structured_assign_bitxor_equals.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_bitxor_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_bitxor_equals.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.118658037041314
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00836853904183954,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_divided_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_divided_equals.c/atomic_structured_assign_divided_equals.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_divided_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_divided_equals.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_divided_equals.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9686863230308518
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_divided_equals.c/atomic_structured_assign_divided_equals.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_divided_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_divided_equals.c\", line 105: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1199000040069222
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008417490986175835,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_expr_bitand_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_expr_bitand_x.c/atomic_structured_assign_expr_bitand_x.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitand_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitand_x.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitand_x.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitand_x.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitand_x.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9686168909538537
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_expr_bitand_x.c/atomic_structured_assign_expr_bitand_x.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitand_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitand_x.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.169128939975053
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008321308996528387,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_expr_bitor_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_expr_bitor_x.c/atomic_structured_assign_expr_bitor_x.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitor_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitor_x.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitor_x.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitor_x.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitor_x.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.019008424016647
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_expr_bitor_x.c/atomic_structured_assign_expr_bitor_x.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitor_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitor_x.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1183829170186073
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008778712945058942,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_expr_bitxor_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_expr_bitxor_x.c/atomic_structured_assign_expr_bitxor_x.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitxor_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitxor_x.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitxor_x.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitxor_x.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitxor_x.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9682825889904052
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_expr_bitxor_x.c/atomic_structured_assign_expr_bitxor_x.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitxor_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_bitxor_x.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.118950539967045
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008719431003555655,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_expr_divided_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_expr_divided_x.c/atomic_structured_assign_expr_divided_x.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_expr_divided_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_divided_x.c\", line 93: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_divided_x.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0180419479729608
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_expr_divided_x.c/atomic_structured_assign_expr_divided_x.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_expr_divided_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_divided_x.c\", line 132: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1691089529776946
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008793221088126302,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_expr_multiply_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_expr_multiply_x.c/atomic_structured_assign_expr_multiply_x.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_expr_multiply_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_multiply_x.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_multiply_x.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.969086678000167
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_expr_multiply_x.c/atomic_structured_assign_expr_multiply_x.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_expr_multiply_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_multiply_x.c\", line 95: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.11873971298337
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00832475593779236,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_expr_plus_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_expr_plus_x.c/atomic_structured_assign_expr_plus_x.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_expr_plus_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_plus_x.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_plus_x.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9686872059246525
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_expr_plus_x.c/atomic_structured_assign_expr_plus_x.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_expr_plus_x.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_expr_plus_x.c\", line 95: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068609393085353
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008644409012049437,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_lshift_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_lshift_equals.c/atomic_structured_assign_lshift_equals.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_lshift_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_lshift_equals.c\", line 67: error: extra text after expected end of preprocessing directive\n                          #pragma acc atomic update capture\n                                                    ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_lshift_equals.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9684376349905506
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_lshift_equals.c/atomic_structured_assign_lshift_equals.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_lshift_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_lshift_equals.c\", line 101: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1188176680589095
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008765128091908991,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_minus_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_minus_equals.c/atomic_structured_assign_minus_equals.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_minus_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_minus_equals.c\", line 59: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_minus_equals.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9690399499377236
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_minus_equals.c/atomic_structured_assign_minus_equals.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_minus_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_minus_equals.c\", line 93: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1187400609487668
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008357318001799285,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_multiply_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_multiply_equals.c/atomic_structured_assign_multiply_equals.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_multiply_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_multiply_equals.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_multiply_equals.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9686952279880643
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_multiply_equals.c/atomic_structured_assign_multiply_equals.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_multiply_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_multiply_equals.c\", line 95: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1187342000193894
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008709372021257877,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_plus_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_plus_equals.c/atomic_structured_assign_plus_equals.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_plus_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_plus_equals.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_plus_equals.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0235511240316555
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_plus_equals.c/atomic_structured_assign_plus_equals.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_plus_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_plus_equals.c\", line 95: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1690528739709407
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008705666055902839,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_postdecrement.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_postdecrement.c/atomic_structured_assign_postdecrement.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_postdecrement.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_postdecrement.c\", line 29: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_postdecrement.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0188886449905112
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_postdecrement.c/atomic_structured_assign_postdecrement.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_postdecrement.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_postdecrement.c\", line 69: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069280127994716
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008602219983004034,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_postincrement.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_postincrement.c/atomic_structured_assign_postincrement.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_postincrement.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_postincrement.c\", line 29: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_postincrement.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9684172649867833
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_postincrement.c/atomic_structured_assign_postincrement.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_postincrement.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_postincrement.c\", line 69: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1189904629718512
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008367217029444873,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_predecrement.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_predecrement.c/atomic_structured_assign_predecrement.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_predecrement.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_predecrement.c\", line 29: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_predecrement.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9687022420112044
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_predecrement.c/atomic_structured_assign_predecrement.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_predecrement.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_predecrement.c\", line 69: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0684365160996094
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008656693040393293,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_preincrement.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_preincrement.c/atomic_structured_assign_preincrement.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_preincrement.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_preincrement.c\", line 29: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_preincrement.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9683887399733067
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_preincrement.c/atomic_structured_assign_preincrement.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_preincrement.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_preincrement.c\", line 69: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1189740230329335
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008765808888711035,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_rshift_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_rshift_equals.c/atomic_structured_assign_rshift_equals.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_rshift_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_rshift_equals.c\", line 69: error: extra text after expected end of preprocessing directive\n                          #pragma acc atomic update capture\n                                                    ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_rshift_equals.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9683968760073185
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_rshift_equals.c/atomic_structured_assign_rshift_equals.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_rshift_equals.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_rshift_equals.c\", line 103: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068798057967797
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00878055696375668,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_x_bitand_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_x_bitand_expr.c/atomic_structured_assign_x_bitand_expr.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitand_expr.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitand_expr.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitand_expr.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitand_expr.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitand_expr.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.018662238959223
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_x_bitand_expr.c/atomic_structured_assign_x_bitand_expr.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitand_expr.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitand_expr.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.11877219309099
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008801215910352767,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_x_bitor_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_x_bitor_expr.c/atomic_structured_assign_x_bitor_expr.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitor_expr.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitor_expr.c\", line 68: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitor_expr.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitor_expr.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitor_expr.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.018835055991076
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_x_bitor_expr.c/atomic_structured_assign_x_bitor_expr.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitor_expr.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitor_expr.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0686876899562776
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008833225001581013,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_x_bitxor_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_x_bitxor_expr.c/atomic_structured_assign_x_bitxor_expr.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitxor_expr.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitxor_expr.c\", line 68: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitxor_expr.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitxor_expr.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitxor_expr.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9680850150762126
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_x_bitxor_expr.c/atomic_structured_assign_x_bitxor_expr.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitxor_expr.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_bitxor_expr.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1189271740149707
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00857128098141402,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_x_divided_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_x_divided_expr.c/atomic_structured_assign_x_divided_expr.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_x_divided_expr.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_divided_expr.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_divided_expr.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9686038859654218
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_x_divided_expr.c/atomic_structured_assign_x_divided_expr.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_x_divided_expr.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_divided_expr.c\", line 105: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1185649880208075
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0083717149682343,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_x_lshift_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_x_lshift_expr.c/atomic_structured_assign_x_lshift_expr.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_x_lshift_expr.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_lshift_expr.c\", line 67: error: extra text after expected end of preprocessing directive\n                          #pragma acc atomic update capture\n                                                    ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_lshift_expr.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0182972999755293
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_x_lshift_expr.c/atomic_structured_assign_x_lshift_expr.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_x_lshift_expr.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_lshift_expr.c\", line 101: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0687953550368547
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00881743710488081,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_x_minus_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_x_minus_expr.c/atomic_structured_assign_x_minus_expr.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_x_minus_expr.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_minus_expr.c\", line 59: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_minus_expr.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0192157549317926
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_x_minus_expr.c/atomic_structured_assign_x_minus_expr.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_x_minus_expr.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_minus_expr.c\", line 93: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.119099159957841
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008300860994495451,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_x_multiply_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_x_multiply_expr.c/atomic_structured_assign_x_multiply_expr.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_x_multiply_expr.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_multiply_expr.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_multiply_expr.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.968116155010648
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_x_multiply_expr.c/atomic_structured_assign_x_multiply_expr.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_x_multiply_expr.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_multiply_expr.c\", line 95: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.11863236699719
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008442498976364732,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_x_plus_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_x_plus_expr.c/atomic_structured_assign_x_plus_expr.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_x_plus_expr.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_plus_expr.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_plus_expr.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9679621949326247
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_x_plus_expr.c/atomic_structured_assign_x_plus_expr.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_x_plus_expr.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_plus_expr.c\", line 95: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1188980219885707
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008417321019805968,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_x_rshift_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_assign_x_rshift_expr.c/atomic_structured_assign_x_rshift_expr.c0 /usa/chrismun/openacc/Tests/atomic_structured_assign_x_rshift_expr.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_rshift_expr.c\", line 69: error: extra text after expected end of preprocessing directive\n                          #pragma acc atomic update capture\n                                                    ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_rshift_expr.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9684568679658696
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_assign_x_rshift_expr.c/atomic_structured_assign_x_rshift_expr.c1 /usa/chrismun/openacc/Tests/atomic_structured_assign_x_rshift_expr.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_assign_x_rshift_expr.c\", line 103: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.169268321013078
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008334373938851058,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_bitand_equals_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_bitand_equals_assign.c/atomic_structured_bitand_equals_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_bitand_equals_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_bitand_equals_assign.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_bitand_equals_assign.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_bitand_equals_assign.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_bitand_equals_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.018957208027132
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_bitand_equals_assign.c/atomic_structured_bitand_equals_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_bitand_equals_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_bitand_equals_assign.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1188046879833564
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008535434026271105,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_bitor_equals_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_bitor_equals_assign.c/atomic_structured_bitor_equals_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_bitor_equals_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_bitor_equals_assign.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_bitor_equals_assign.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_bitor_equals_assign.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_bitor_equals_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.968445606995374
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_bitor_equals_assign.c/atomic_structured_bitor_equals_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_bitor_equals_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_bitor_equals_assign.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.118997701909393
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008740872028283775,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_bitxor_equals_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_bitxor_equals_assign.c/atomic_structured_bitxor_equals_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_bitxor_equals_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_bitxor_equals_assign.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_bitxor_equals_assign.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_bitxor_equals_assign.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_bitxor_equals_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9683475330239162
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_bitxor_equals_assign.c/atomic_structured_bitxor_equals_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_bitxor_equals_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_bitxor_equals_assign.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1182360290549695
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008774935966357589,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_divided_equals_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_divided_equals_assign.c/atomic_structured_divided_equals_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_divided_equals_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_divided_equals_assign.c\", line 67: error: extra text after expected end of preprocessing directive\n                #pragma acc atomic update capture\n                                          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_divided_equals_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9686131050111726
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_divided_equals_assign.c/atomic_structured_divided_equals_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_divided_equals_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_divided_equals_assign.c\", line 105: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1185889849439263
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008738136035390198,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_expr_bitand_x_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_expr_bitand_x_assign.c/atomic_structured_expr_bitand_x_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_expr_bitand_x_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_expr_bitand_x_assign.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_expr_bitand_x_assign.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_expr_bitand_x_assign.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_expr_bitand_x_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.018557843985036
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_expr_bitand_x_assign.c/atomic_structured_expr_bitand_x_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_expr_bitand_x_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_expr_bitand_x_assign.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1188193599227816
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008796736947260797,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_expr_bitor_x_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_expr_bitor_x_assign.c/atomic_structured_expr_bitor_x_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_expr_bitor_x_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_expr_bitor_x_assign.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_expr_bitor_x_assign.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_expr_bitor_x_assign.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_expr_bitor_x_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.018239801051095
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_expr_bitor_x_assign.c/atomic_structured_expr_bitor_x_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_expr_bitor_x_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_expr_bitor_x_assign.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1195792659418657
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008460231008939445,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_expr_bitxor_x_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_expr_bitxor_x_assign.c/atomic_structured_expr_bitxor_x_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_expr_bitxor_x_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_expr_bitxor_x_assign.c\", line 68: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_expr_bitxor_x_assign.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_expr_bitxor_x_assign.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_expr_bitxor_x_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9682660769904032
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_expr_bitxor_x_assign.c/atomic_structured_expr_bitxor_x_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_expr_bitxor_x_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_expr_bitxor_x_assign.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.118897138047032
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0087768699740991,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_expr_multiply_x_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_expr_multiply_x_assign.c/atomic_structured_expr_multiply_x_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_expr_multiply_x_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_expr_multiply_x_assign.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_expr_multiply_x_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9685037899762392
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_expr_multiply_x_assign.c/atomic_structured_expr_multiply_x_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_expr_multiply_x_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_expr_multiply_x_assign.c\", line 95: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\nis_possible:\n      9, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.119627728010528
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008530874969437718,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_expr_plus_x_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_expr_plus_x_assign.c/atomic_structured_expr_plus_x_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_expr_plus_x_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_expr_plus_x_assign.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_expr_plus_x_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.969332373002544
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_expr_plus_x_assign.c/atomic_structured_expr_plus_x_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_expr_plus_x_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_expr_plus_x_assign.c\", line 95: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1191652449779212
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008403354091569781,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_lshift_equals_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_lshift_equals_assign.c/atomic_structured_lshift_equals_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_lshift_equals_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_lshift_equals_assign.c\", line 61: error: extra text after expected end of preprocessing directive\n                          #pragma acc atomic update capture\n                                                    ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_lshift_equals_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.018300094990991
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_lshift_equals_assign.c/atomic_structured_lshift_equals_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_lshift_equals_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_lshift_equals_assign.c\", line 95: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.118915260070935
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008635311969555914,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_minus_equals_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_minus_equals_assign.c/atomic_structured_minus_equals_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_minus_equals_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_minus_equals_assign.c\", line 59: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_minus_equals_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0187722380505875
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_minus_equals_assign.c/atomic_structured_minus_equals_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_minus_equals_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_minus_equals_assign.c\", line 93: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1185345420381054
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008849266916513443,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_multiply_equals_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_multiply_equals_assign.c/atomic_structured_multiply_equals_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_multiply_equals_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_multiply_equals_assign.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_multiply_equals_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9688746890751645
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_multiply_equals_assign.c/atomic_structured_multiply_equals_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_multiply_equals_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_multiply_equals_assign.c\", line 95: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\nis_possible:\n      9, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.11874444806017
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008923326968215406,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_plus_equals_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_plus_equals_assign.c/atomic_structured_plus_equals_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_plus_equals_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_plus_equals_assign.c\", line 61: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_plus_equals_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9689254839904606
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_plus_equals_assign.c/atomic_structured_plus_equals_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_plus_equals_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_plus_equals_assign.c\", line 96: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.119559839949943
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008589556091465056,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_postdecrement_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_postdecrement_assign.c/atomic_structured_postdecrement_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_postdecrement_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_postdecrement_assign.c\", line 29: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_postdecrement_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9684306799899787
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_postdecrement_assign.c/atomic_structured_postdecrement_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_postdecrement_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_postdecrement_assign.c\", line 69: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1194536519469693
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00875256396830082,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_postincrement_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_postincrement_assign.c/atomic_structured_postincrement_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_postincrement_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_postincrement_assign.c\", line 29: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_postincrement_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0183504390297458
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_postincrement_assign.c/atomic_structured_postincrement_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_postincrement_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_postincrement_assign.c\", line 69: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1187163959257305
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008330987999215722,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_predecrement_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_predecrement_assign.c/atomic_structured_predecrement_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_predecrement_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_predecrement_assign.c\", line 29: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_predecrement_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9682746160542592
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_predecrement_assign.c/atomic_structured_predecrement_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_predecrement_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_predecrement_assign.c\", line 69: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1188801649259403
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008423642022535205,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_preincrement_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_preincrement_assign.c/atomic_structured_preincrement_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_preincrement_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_preincrement_assign.c\", line 29: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_preincrement_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9682336280820891
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_preincrement_assign.c/atomic_structured_preincrement_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_preincrement_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_preincrement_assign.c\", line 69: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1191345850238577
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008517289999872446,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_rshift_equals_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_rshift_equals_assign.c/atomic_structured_rshift_equals_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_rshift_equals_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_rshift_equals_assign.c\", line 61: error: extra text after expected end of preprocessing directive\n                          #pragma acc atomic update capture\n                                                    ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_rshift_equals_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0182951770257205
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_rshift_equals_assign.c/atomic_structured_rshift_equals_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_rshift_equals_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_rshift_equals_assign.c\", line 95: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.119089731015265
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008796576992608607,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_x_bitand_expr_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_x_bitand_expr_assign.c/atomic_structured_x_bitand_expr_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_x_bitand_expr_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitand_expr_assign.c\", line 10: error: expression must have integral type\n          if (b[x] == (prev & a[x])){\n                       ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitand_expr_assign.c\", line 10: error: expression must have integral type\n          if (b[x] == (prev & a[x])){\n                              ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitand_expr_assign.c\", line 19: warning: argument of type \"int *\" is incompatible with parameter of type \"real_t *\"\n              if (is_possible(passed_a, passed_b, length - 1, b[x])){\n                              ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitand_expr_assign.c\", line 19: warning: argument of type \"int *\" is incompatible with parameter of type \"real_t *\"\n              if (is_possible(passed_a, passed_b, length - 1, b[x])){\n                                        ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitand_expr_assign.c\", line 68: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitand_expr_assign.c\", line 96: warning: argument of type \"int *\" is incompatible with parameter of type \"real_t *\"\n          if (!is_possible(temp_a, temp_b, y - x, init)){\n                           ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitand_expr_assign.c\", line 96: warning: argument of type \"int *\" is incompatible with parameter of type \"real_t *\"\n          if (!is_possible(temp_a, temp_b, y - x, init)){\n                                   ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitand_expr_assign.c\", line 42: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitand_expr_assign.c\", line 43: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n3 errors detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_x_bitand_expr_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0188693000236526
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_x_bitand_expr_assign.c/atomic_structured_x_bitand_expr_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_x_bitand_expr_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitand_expr_assign.c\", line 10: error: expression must have integral type\n          if (b[x] == (prev & a[x])){\n                       ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitand_expr_assign.c\", line 10: error: expression must have integral type\n          if (b[x] == (prev & a[x])){\n                              ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitand_expr_assign.c\", line 19: warning: argument of type \"int *\" is incompatible with parameter of type \"real_t *\"\n              if (is_possible(passed_a, passed_b, length - 1, b[x])){\n                              ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitand_expr_assign.c\", line 19: warning: argument of type \"int *\" is incompatible with parameter of type \"real_t *\"\n              if (is_possible(passed_a, passed_b, length - 1, b[x])){\n                                        ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitand_expr_assign.c\", line 107: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n2 errors detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_x_bitand_expr_assign.c\".\n",
                    "export": true,
                    "output": "",
                    "result": 2,
                    "runtime": 1.968851163983345
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": true,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_x_bitor_expr_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_x_bitor_expr_assign.c/atomic_structured_x_bitor_expr_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_x_bitor_expr_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitor_expr_assign.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitor_expr_assign.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitor_expr_assign.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_x_bitor_expr_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0185287969652563
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_x_bitor_expr_assign.c/atomic_structured_x_bitor_expr_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_x_bitor_expr_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitor_expr_assign.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1187153559876606
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00836192595306784,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_x_bitxor_expr_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_x_bitxor_expr_assign.c/atomic_structured_x_bitxor_expr_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_x_bitxor_expr_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitxor_expr_assign.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitxor_expr_assign.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitxor_expr_assign.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_x_bitxor_expr_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0179178030230105
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_x_bitxor_expr_assign.c/atomic_structured_x_bitxor_expr_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_x_bitxor_expr_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_x_bitxor_expr_assign.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0685778129845858
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008771049091592431,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_x_divided_expr_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_x_divided_expr_assign.c/atomic_structured_x_divided_expr_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_x_divided_expr_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_x_divided_expr_assign.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_x_divided_expr_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9688438799930736
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_x_divided_expr_assign.c/atomic_structured_x_divided_expr_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_x_divided_expr_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_x_divided_expr_assign.c\", line 105: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1694740699604154
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009007896995171905,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_x_lshift_expr_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_x_lshift_expr_assign.c/atomic_structured_x_lshift_expr_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_x_lshift_expr_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_x_lshift_expr_assign.c\", line 61: error: extra text after expected end of preprocessing directive\n                          #pragma acc atomic update capture\n                                                    ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_x_lshift_expr_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0183826900320128
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_x_lshift_expr_assign.c/atomic_structured_x_lshift_expr_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_x_lshift_expr_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_x_lshift_expr_assign.c\", line 95: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1189762690337375
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008885394898243248,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_x_minus_expr_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_x_minus_expr_assign.c/atomic_structured_x_minus_expr_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_x_minus_expr_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_x_minus_expr_assign.c\", line 59: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_x_minus_expr_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.01826272404287
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_x_minus_expr_assign.c/atomic_structured_x_minus_expr_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_x_minus_expr_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_x_minus_expr_assign.c\", line 93: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1185517749981955
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008986386004835367,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_x_multiply_expr_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_x_multiply_expr_assign.c/atomic_structured_x_multiply_expr_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_x_multiply_expr_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_x_multiply_expr_assign.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_x_multiply_expr_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0182198130059987
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_x_multiply_expr_assign.c/atomic_structured_x_multiply_expr_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_x_multiply_expr_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_x_multiply_expr_assign.c\", line 95: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\nis_possible:\n      9, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1185933550586924
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008567395037971437,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_x_plus_expr_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_x_plus_expr_assign.c/atomic_structured_x_plus_expr_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_x_plus_expr_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_x_plus_expr_assign.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_x_plus_expr_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9682631520554423
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_x_plus_expr_assign.c/atomic_structured_x_plus_expr_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_x_plus_expr_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_x_plus_expr_assign.c\", line 95: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1193801319459453
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009067139006219804,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_x_rshift_expr_assign.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_structured_x_rshift_expr_assign.c/atomic_structured_x_rshift_expr_assign.c0 /usa/chrismun/openacc/Tests/atomic_structured_x_rshift_expr_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_x_rshift_expr_assign.c\", line 61: error: extra text after expected end of preprocessing directive\n                          #pragma acc atomic update capture\n                                                    ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/atomic_structured_x_rshift_expr_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9685294770170003
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/atomic_structured_x_rshift_expr_assign.c/atomic_structured_x_rshift_expr_assign.c1 /usa/chrismun/openacc/Tests/atomic_structured_x_rshift_expr_assign.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/atomic_structured_x_rshift_expr_assign.c\", line 95: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.168813382042572
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008506819955073297,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_bitand_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_bitand_equals.c/atomic_update_bitand_equals.c0 /usa/chrismun/openacc/Tests/atomic_update_bitand_equals.c",
                    "config": 1,
                    "errors": "test1:\n     27, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     29, Generating Tesla code\n         31, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8204403669806197
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0191531371092424,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_bitor_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_bitor_equals.c/atomic_update_bitor_equals.c0 /usa/chrismun/openacc/Tests/atomic_update_bitor_equals.c",
                    "config": 1,
                    "errors": "test1:\n     18, Memory zero idiom, loop replaced by call to __c_mzero4\n     24, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     26, Generating Tesla code\n         28, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8194996010279283
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.119030048022978,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_bitxor_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_bitxor_equals.c/atomic_update_bitxor_equals.c0 /usa/chrismun/openacc/Tests/atomic_update_bitxor_equals.c",
                    "config": 1,
                    "errors": "test1:\n     24, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     26, Generating Tesla code\n         28, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8200280180899426
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018808066030033,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_divided_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_divided_equals.c/atomic_update_divided_equals.c0 /usa/chrismun/openacc/Tests/atomic_update_divided_equals.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8197184840682894
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0187973330030218,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_bitand_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_expr_bitand_x.c/atomic_update_expr_bitand_x.c0 /usa/chrismun/openacc/Tests/atomic_update_expr_bitand_x.c",
                    "config": 1,
                    "errors": "test1:\n     27, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     29, Generating Tesla code\n         31, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7712293149670586
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0186345370020717,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_bitor_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_expr_bitor_x.c/atomic_update_expr_bitor_x.c0 /usa/chrismun/openacc/Tests/atomic_update_expr_bitor_x.c",
                    "config": 1,
                    "errors": "test1:\n     18, Memory zero idiom, loop replaced by call to __c_mzero4\n     24, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     26, Generating Tesla code\n         28, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820812979945913
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0186441040132195,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_bitxor_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_expr_bitxor_x.c/atomic_update_expr_bitxor_x.c0 /usa/chrismun/openacc/Tests/atomic_update_expr_bitxor_x.c",
                    "config": 1,
                    "errors": "test1:\n     24, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     26, Generating Tesla code\n         28, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8705553259933367
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0190233120229095,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_divided_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_expr_divided_x.c/atomic_update_expr_divided_x.c0 /usa/chrismun/openacc/Tests/atomic_update_expr_divided_x.c",
                    "config": 1,
                    "errors": "possible_result:\n     13, Memory copy idiom, loop replaced by call to __c_mcopy8\n     16, Memory copy idiom, loop replaced by call to __c_mcopy8\ntest1:\n     43, Memory set idiom, loop replaced by call to __c_mset8\n     48, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n     50, Generating Tesla code\n         52, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8705059639178216
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068344871979207,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_lshift_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_expr_lshift_x.c/atomic_update_expr_lshift_x.c0 /usa/chrismun/openacc/Tests/atomic_update_expr_lshift_x.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating copyin(a[:n*3]) [if not already present]\n         Generating copy(b[:n]) [if not already present]\n     22, Generating Tesla code\n         24, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop seq\n     26, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870495642069727
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 2.019474682980217,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_minus_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_expr_minus_x.c/atomic_update_expr_minus_x.c0 /usa/chrismun/openacc/Tests/atomic_update_expr_minus_x.c",
                    "config": 1,
                    "errors": "possible_result:\n     13, Memory copy idiom, loop replaced by call to __c_mcopy8\n     16, Memory copy idiom, loop replaced by call to __c_mcopy8\ntest1:\n     41, Memory zero idiom, loop replaced by call to __c_mzero8\n     46, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     48, Generating Tesla code\n         50, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.821527600986883
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0192711600102484,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_multiply_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_expr_multiply_x.c/atomic_update_expr_multiply_x.c0 /usa/chrismun/openacc/Tests/atomic_update_expr_multiply_x.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8198367670411244
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0188551449682564,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_plus_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_expr_plus_x.c/atomic_update_expr_plus_x.c0 /usa/chrismun/openacc/Tests/atomic_update_expr_plus_x.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang /* blockIdx.x */\n         28, #pragma acc loop vector(128) /* threadIdx.x */\n     28, Loop is parallelizable\n     37, Zero trip check eliminated\n     38, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.828451359993778
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069397691055201,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_rshift_x.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_expr_rshift_x.c/atomic_update_expr_rshift_x.c0 /usa/chrismun/openacc/Tests/atomic_update_expr_rshift_x.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating copyin(a[:n*3]) [if not already present]\n         Generating copy(b[:n]) [if not already present]\n     22, Generating Tesla code\n         24, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop seq\n     26, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8208631449379027
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 2.068146788980812,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_lshift_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_lshift_equals.c/atomic_update_lshift_equals.c0 /usa/chrismun/openacc/Tests/atomic_update_lshift_equals.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating copy(a[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     22, Generating Tesla code\n         24, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop seq\n     26, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.769692991976626
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068827513954602,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_minus_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_minus_equals.c/atomic_update_minus_equals.c0 /usa/chrismun/openacc/Tests/atomic_update_minus_equals.c",
                    "config": 1,
                    "errors": "test1:\n     21, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     23, Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8210310820722952
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069104828988202,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_multiply_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_multiply_equals.c/atomic_update_multiply_equals.c0 /usa/chrismun/openacc/Tests/atomic_update_multiply_equals.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820116265094839
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068697348004207,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_plus_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_plus_equals.c/atomic_update_plus_equals.c0 /usa/chrismun/openacc/Tests/atomic_update_plus_equals.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     34, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.871111025917344
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0686376659432426,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_postdecrement.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_postdecrement.c/atomic_update_postdecrement.c0 /usa/chrismun/openacc/Tests/atomic_update_postdecrement.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(distribution[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8201961250742897
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0193867969792336,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_postincrement.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_postincrement.c/atomic_update_postincrement.c0 /usa/chrismun/openacc/Tests/atomic_update_postincrement.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(distribution[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang /* blockIdx.x */\n         28, #pragma acc loop vector(128) /* threadIdx.x */\n     28, Loop is parallelizable\n     37, Zero trip check eliminated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.871417094953358
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019129501073621,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_predecrement.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_predecrement.c/atomic_update_predecrement.c0 /usa/chrismun/openacc/Tests/atomic_update_predecrement.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(distribution[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang /* blockIdx.x */\n         28, #pragma acc loop vector(128) /* threadIdx.x */\n     28, Loop is parallelizable\n     37, Zero trip check eliminated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.819589708931744
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0693300920538604,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_preincrement.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_preincrement.c/atomic_update_preincrement.c0 /usa/chrismun/openacc/Tests/atomic_update_preincrement.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(distribution[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang /* blockIdx.x */\n         28, #pragma acc loop vector(128) /* threadIdx.x */\n     28, Loop is parallelizable\n     37, Zero trip check eliminated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8713959329761565
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068751960992813,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_rshift_equals.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_rshift_equals.c/atomic_update_rshift_equals.c0 /usa/chrismun/openacc/Tests/atomic_update_rshift_equals.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating copy(a[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     22, Generating Tesla code\n         24, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop seq\n     26, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8716887480113655
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068416076945141,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_bitand_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_x_bitand_expr.c/atomic_update_x_bitand_expr.c0 /usa/chrismun/openacc/Tests/atomic_update_x_bitand_expr.c",
                    "config": 1,
                    "errors": "test1:\n     26, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     28, Generating Tesla code\n         30, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.821385090937838
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018558986019343,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_bitor_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_x_bitor_expr.c/atomic_update_x_bitor_expr.c0 /usa/chrismun/openacc/Tests/atomic_update_x_bitor_expr.c",
                    "config": 1,
                    "errors": "test1:\n     18, Memory zero idiom, loop replaced by call to __c_mzero4\n     24, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     26, Generating Tesla code\n         28, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8695553669240326
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019544856972061,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_bitxor_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_x_bitxor_expr.c/atomic_update_x_bitxor_expr.c0 /usa/chrismun/openacc/Tests/atomic_update_x_bitxor_expr.c",
                    "config": 1,
                    "errors": "test1:\n     24, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     26, Generating Tesla code\n         28, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.770271727000363
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0691292439587414,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_divided_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_x_divided_expr.c/atomic_update_x_divided_expr.c0 /usa/chrismun/openacc/Tests/atomic_update_x_divided_expr.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820504317060113
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018987484043464,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_lshift_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_x_lshift_expr.c/atomic_update_x_lshift_expr.c0 /usa/chrismun/openacc/Tests/atomic_update_x_lshift_expr.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating copy(a[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     22, Generating Tesla code\n         24, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop seq\n     26, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820271537057124
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069440622930415,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_minus_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_x_minus_expr.c/atomic_update_x_minus_expr.c0 /usa/chrismun/openacc/Tests/atomic_update_x_minus_expr.c",
                    "config": 1,
                    "errors": "test1:\n     21, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     23, Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8204600550234318
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0195702160708606,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_multiply_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_x_multiply_expr.c/atomic_update_x_multiply_expr.c0 /usa/chrismun/openacc/Tests/atomic_update_x_multiply_expr.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8335170479258522
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0188947109272704,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_plus_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_x_plus_expr.c/atomic_update_x_plus_expr.c0 /usa/chrismun/openacc/Tests/atomic_update_x_plus_expr.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang /* blockIdx.x */\n         28, #pragma acc loop vector(128) /* threadIdx.x */\n     28, Loop is parallelizable\n     37, Zero trip check eliminated\n     38, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8203714770497754
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069024203927256,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_rshift_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_update_x_rshift_expr.c/atomic_update_x_rshift_expr.c0 /usa/chrismun/openacc/Tests/atomic_update_x_rshift_expr.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating copy(a[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     22, Generating Tesla code\n         24, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop seq\n     26, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820336600067094
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068921710946597,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_bitand_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_x_bitand_expr.c/atomic_x_bitand_expr.c0 /usa/chrismun/openacc/Tests/atomic_x_bitand_expr.c",
                    "config": 1,
                    "errors": "test1:\n     26, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     28, Generating Tesla code\n         30, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.833107784972526
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0180207160301507,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_bitor_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_x_bitor_expr.c/atomic_x_bitor_expr.c0 /usa/chrismun/openacc/Tests/atomic_x_bitor_expr.c",
                    "config": 1,
                    "errors": "test1:\n     18, Memory zero idiom, loop replaced by call to __c_mzero4\n     24, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     26, Generating Tesla code\n         28, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.821036093053408
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068965754006058,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_bitxor_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_x_bitxor_expr.c/atomic_x_bitxor_expr.c0 /usa/chrismun/openacc/Tests/atomic_x_bitxor_expr.c",
                    "config": 1,
                    "errors": "test1:\n     24, Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     26, Generating Tesla code\n         28, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870367771014571
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0693647260777652,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_divided_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_x_divided_expr.c/atomic_x_divided_expr.c0 /usa/chrismun/openacc/Tests/atomic_x_divided_expr.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.821696628932841
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0697073839837685,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_lshift_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_x_lshift_expr.c/atomic_x_lshift_expr.c0 /usa/chrismun/openacc/Tests/atomic_x_lshift_expr.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating copy(a[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     22, Generating Tesla code\n         24, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop seq\n     26, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8212949209846556
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0184986530803144,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_minus_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_x_minus_expr.c/atomic_x_minus_expr.c0 /usa/chrismun/openacc/Tests/atomic_x_minus_expr.c",
                    "config": 1,
                    "errors": "test1:\n     21, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     23, Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820511857047677
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019383013015613,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_multiply_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_x_multiply_expr.c/atomic_x_multiply_expr.c0 /usa/chrismun/openacc/Tests/atomic_x_multiply_expr.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:n/10+1]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.819595417007804
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0684383820043877,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_plus_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_x_plus_expr.c/atomic_x_plus_expr.c0 /usa/chrismun/openacc/Tests/atomic_x_plus_expr.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating copy(totals[:10]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang /* blockIdx.x */\n         28, #pragma acc loop vector(128) /* threadIdx.x */\n     28, Loop is parallelizable\n     37, Zero trip check eliminated\n     38, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8209948210278526
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0190009330399334,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_rshift_expr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/atomic_x_rshift_expr.c/atomic_x_rshift_expr.c0 /usa/chrismun/openacc/Tests/atomic_x_rshift_expr.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating copy(a[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     22, Generating Tesla code\n         24, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop seq\n     26, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820326850982383
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.06868032598868,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_copy_no_lower_bound.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/data_copy_no_lower_bound.c/data_copy_no_lower_bound.c0 /usa/chrismun/openacc/Tests/data_copy_no_lower_bound.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n]) [if not already present]\n         Generating copy(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     20, Generating Tesla code\n         22, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7697156069334596
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069722905056551,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_copyin_no_lower_bound.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/data_copyin_no_lower_bound.c/data_copyin_no_lower_bound.c0 /usa/chrismun/openacc/Tests/data_copyin_no_lower_bound.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     20, Generating Tesla code\n         22, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8200444070389494
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0192455709911883,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_copyout_no_lower_bound.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/data_copyout_no_lower_bound.c/data_copyout_no_lower_bound.c0 /usa/chrismun/openacc/Tests/data_copyout_no_lower_bound.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     20, Generating Tesla code\n         22, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820216102991253
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.027202132041566,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_copyout_reference_counts.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/data_copyout_reference_counts.c/data_copyout_reference_counts.c0 /usa/chrismun/openacc/Tests/data_copyout_reference_counts.c",
                    "config": 1,
                    "errors": "test1:\n     14, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     27, Generating copyin(c[:n]) [if not already present]\n     29, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     31, Generating Tesla code\n         33, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     70, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     82, Generating enter data copyin(c[:n])\n         Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     84, Generating Tesla code\n         86, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     98, Generating exit data copyout(c[:n])\ntest3:\n    129, Generating enter data copyin(c[:n])\n         Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n    131, Generating Tesla code\n        133, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    138, Generating exit data delete(c[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.920043293037452
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0324597359867766,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_create.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/data_create.c/data_create.c0 /usa/chrismun/openacc/Tests/data_create.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating create(b[:n]) [if not already present]\n     20, Generating copyin(a[:n]) [if not already present]\n     22, Generating Tesla code\n         24, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     30, Generating copyout(c[:n]) [if not already present]\n     32, Generating Tesla code\n         34, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     68, Generating create(b[:n]) [if not already present]\n     70, Generating copyin(a[:n]) [if not already present]\n     72, Generating Tesla code\n         74, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     80, Generating copyout(c[:n]) [if not already present]\n     82, Generating Tesla code\n         84, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     82, Generating implicit copyin(a[:n]) [if not already present]\ntest3:\n    118, Generating create(b[:n]) [if not already present]\n    120, Generating copyin(a[:n]) [if not already present]\n    122, Generating Tesla code\n        124, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    130, Generating copyout(c[:n]) [if not already present]\n    132, Generating Tesla code\n        134, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.921461630030535
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.06884959700983,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_create_no_lower_bound.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/data_create_no_lower_bound.c/data_create_no_lower_bound.c0 /usa/chrismun/openacc/Tests/data_create_no_lower_bound.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n]) [if not already present]\n         Generating create(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n         Generating copyout(e[:n]) [if not already present]\n         Generating copyin(d[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         30, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.770442279987037
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019527633092366,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_present_no_lower_bound.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/data_present_no_lower_bound.c/data_present_no_lower_bound.c0 /usa/chrismun/openacc/Tests/data_present_no_lower_bound.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating enter data copyin(c[:n])\n         Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n     21, Generating Tesla code\n         23, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     27, Generating exit data copyout(c[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9200611850246787
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019357674056664,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_with_changing_subscript.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/data_with_changing_subscript.c/data_with_changing_subscript.c0 /usa/chrismun/openacc/Tests/data_with_changing_subscript.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating copyin(a[:length]) [if not already present]\n         Generating copyout(c[:length]) [if not already present]\n         Generating copyin(b[:length]) [if not already present]\n     21, Generating Tesla code\n         23, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8199760189745575
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.01864609005861,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_with_structs.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/data_with_structs.c/data_with_structs.c0 /usa/chrismun/openacc/Tests/data_with_structs.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copy(a[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7695180310402066
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0186089790659025,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_copyin.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -o /usa/chrismun/openacc/build/declare_copyin.c/declare_copyin.c0 /usa/chrismun/openacc/Tests/declare_copyin.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/declare_copyin.c\", line 203: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\nextern_multiplyData_copyin:\n      4, include \"acc_testsuite_declare.h\"\n          41, Generating Tesla code\n              43, #pragma acc loop vector /* threadIdx.x */\n          43, Loop is parallelizable\nmultiplyData:\n     12, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n     14, Loop is parallelizable\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.770295261987485
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008613070007413626,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -DT5 -o /usa/chrismun/openacc/build/declare_copyin.c/declare_copyin.c1 /usa/chrismun/openacc/Tests/declare_copyin.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/declare_copyin.c\", line 26: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\nextern_multiplyData_copyin:\n      4, include \"acc_testsuite_declare.h\"\n          41, Generating Tesla code\n              43, #pragma acc loop vector /* threadIdx.x */\n          43, Loop is parallelizable\nmultiplyData:\n     12, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n     14, Loop is parallelizable\ntest1:\n     33, Generating copyout(b[:n]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     35, Generating Tesla code\n         37, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8192737319041044
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.067895763902925,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT3 -DT4 -DT5 -o /usa/chrismun/openacc/build/declare_copyin.c/declare_copyin.c2 /usa/chrismun/openacc/Tests/declare_copyin.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/declare_copyin.c\", line 61: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\nextern_multiplyData_copyin:\n      4, include \"acc_testsuite_declare.h\"\n          41, Generating Tesla code\n              43, #pragma acc loop vector /* threadIdx.x */\n          43, Loop is parallelizable\nmultiplyData:\n     12, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n     14, Loop is parallelizable\ntest2:\n     69, Generating copyout(b[:n]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     71, Generating Tesla code\n         73, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.819904424948618
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019225222989917,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -DT5 -o /usa/chrismun/openacc/build/declare_copyin.c/declare_copyin.c3 /usa/chrismun/openacc/Tests/declare_copyin.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/declare_copyin.c\", line 97: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\nextern_multiplyData_copyin:\n      4, include \"acc_testsuite_declare.h\"\n          41, Generating Tesla code\n              43, #pragma acc loop vector /* threadIdx.x */\n          43, Loop is parallelizable\nmultiplyData:\n     12, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n     14, Loop is parallelizable\ntest3:\n    105, Generating copy(a[:n]) [if not already present]\n    107, Generating Tesla code\n        109, #pragma acc loop gang /* blockIdx.x */\n    116, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8700483990833163
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018699722015299,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT5 -o /usa/chrismun/openacc/build/declare_copyin.c/declare_copyin.c4 /usa/chrismun/openacc/Tests/declare_copyin.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/declare_copyin.c\", line 133: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\nextern_multiplyData_copyin:\n      4, include \"acc_testsuite_declare.h\"\n          41, Generating Tesla code\n              43, #pragma acc loop vector /* threadIdx.x */\n          43, Loop is parallelizable\nmultiplyData:\n     12, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n     14, Loop is parallelizable\ntest4:\n    141, Generating copy(a[:n]) [if not already present]\n    143, Generating Tesla code\n        145, #pragma acc loop gang /* blockIdx.x */\n    152, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.871342904982157
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0694755379809067,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/declare_copyin.c/declare_copyin.c5 /usa/chrismun/openacc/Tests/declare_copyin.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/declare_copyin.c\", line 169: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\nextern_multiplyData_copyin:\n      4, include \"acc_testsuite_declare.h\"\n          41, Generating Tesla code\n              43, #pragma acc loop vector /* threadIdx.x */\n          43, Loop is parallelizable\nmultiplyData:\n     12, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n     14, Loop is parallelizable\ntest5:\n    179, Generating enter data attach(datapointer)\n         Generating enter data copyin(a[:n])\n    181, Generating Tesla code\n        183, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    187, Generating exit data copyout(a[:n])\n    191, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820910906069912
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0191952449968085,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/declare_copyin.c/declare_copyin.c6 /usa/chrismun/openacc/Tests/declare_copyin.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/declare_copyin.c\", line 26: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/usa/chrismun/openacc/Tests/declare_copyin.c\", line 61: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/usa/chrismun/openacc/Tests/declare_copyin.c\", line 97: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/usa/chrismun/openacc/Tests/declare_copyin.c\", line 133: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/usa/chrismun/openacc/Tests/declare_copyin.c\", line 169: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\nextern_multiplyData_copyin:\n      4, include \"acc_testsuite_declare.h\"\n          41, Generating Tesla code\n              43, #pragma acc loop vector /* threadIdx.x */\n          43, Loop is parallelizable\nmultiplyData:\n     12, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n     14, Loop is parallelizable\ntest1:\n     33, Generating copyout(b[:n]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     35, Generating Tesla code\n         37, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     69, Generating copyout(b[:n]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     71, Generating Tesla code\n         73, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest3:\n    105, Generating copy(a[:n]) [if not already present]\n    107, Generating Tesla code\n        109, #pragma acc loop gang /* blockIdx.x */\n    116, FMA (fused multiply-add) instruction(s) generated\ntest4:\n    141, Generating copy(a[:n]) [if not already present]\n    143, Generating Tesla code\n        145, #pragma acc loop gang /* blockIdx.x */\n    152, FMA (fused multiply-add) instruction(s) generated\ntest5:\n    179, Generating enter data attach(datapointer)\n         Generating enter data copyin(a[:n])\n    181, Generating Tesla code\n        183, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    187, Generating exit data copyout(a[:n])\n    191, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9213840139564127
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069164732005447,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_create.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -o /usa/chrismun/openacc/build/declare_create.c/declare_create.c0 /usa/chrismun/openacc/Tests/declare_create.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/declare_create.c\", line 217: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\nextern_multiplyData_create:\n      3, include \"acc_testsuite_declare.h\"\n          53, Generating Tesla code\n              55, #pragma acc loop vector /* threadIdx.x */\n          55, Loop is parallelizable\nmultiplyData:\n     13, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n     14, Loop is parallelizable\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.770356736960821
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009011132060550153,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -DT5 -o /usa/chrismun/openacc/build/declare_create.c/declare_create.c1 /usa/chrismun/openacc/Tests/declare_create.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/declare_create.c\", line 26: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\nextern_multiplyData_create:\n      3, include \"acc_testsuite_declare.h\"\n          53, Generating Tesla code\n              55, #pragma acc loop vector /* threadIdx.x */\n          55, Loop is parallelizable\nmultiplyData:\n     13, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n     14, Loop is parallelizable\ntest1:\n     26, Generating update device(n)\n     35, Generating copyout(b[:n]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     37, Generating Tesla code\n         39, #pragma acc loop gang /* blockIdx.x */\n     44, Generating Tesla code\n         46, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.869883856968954
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0185448279371485,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT3 -DT4 -DT5 -o /usa/chrismun/openacc/build/declare_create.c/declare_create.c2 /usa/chrismun/openacc/Tests/declare_create.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/declare_create.c\", line 70: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\nextern_multiplyData_create:\n      3, include \"acc_testsuite_declare.h\"\n          53, Generating Tesla code\n              55, #pragma acc loop vector /* threadIdx.x */\n          55, Loop is parallelizable\nmultiplyData:\n     13, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n     14, Loop is parallelizable\ntest2:\n     70, Generating update device(n)\n     81, Generating update device(scalar)\n         Generating copyout(b[:n]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     83, Generating Tesla code\n         85, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820648438995704
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0188031969591975,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -DT5 -o /usa/chrismun/openacc/build/declare_create.c/declare_create.c3 /usa/chrismun/openacc/Tests/declare_create.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/declare_create.c\", line 109: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\nextern_multiplyData_create:\n      3, include \"acc_testsuite_declare.h\"\n          53, Generating Tesla code\n              55, #pragma acc loop vector /* threadIdx.x */\n          55, Loop is parallelizable\nmultiplyData:\n     13, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n     14, Loop is parallelizable\ntest3:\n    109, Generating update device(n)\n    119, Generating update device(mult_create)\n         Generating copy(a[:n]) [if not already present]\n    121, Generating Tesla code\n        123, #pragma acc loop gang /* blockIdx.x */\n    130, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8699726349441335
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0690289339981973,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT5 -o /usa/chrismun/openacc/build/declare_create.c/declare_create.c4 /usa/chrismun/openacc/Tests/declare_create.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/declare_create.c\", line 147: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\nextern_multiplyData_create:\n      3, include \"acc_testsuite_declare.h\"\n          53, Generating Tesla code\n              55, #pragma acc loop vector /* threadIdx.x */\n          55, Loop is parallelizable\nmultiplyData:\n     13, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n     14, Loop is parallelizable\ntest4:\n    147, Generating update device(n)\n    155, Generating copy(a[:n]) [if not already present]\n    157, Generating Tesla code\n        159, #pragma acc loop gang /* blockIdx.x */\n    166, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8205025349743664
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019242614042014,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/declare_create.c/declare_create.c5 /usa/chrismun/openacc/Tests/declare_create.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/declare_create.c\", line 183: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\nextern_multiplyData_create:\n      3, include \"acc_testsuite_declare.h\"\n          53, Generating Tesla code\n              55, #pragma acc loop vector /* threadIdx.x */\n          55, Loop is parallelizable\nmultiplyData:\n     13, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n     14, Loop is parallelizable\ntest5:\n    183, Generating update device(n)\n    193, Generating copyin(a[:n]) [if not already present]\n    195, Generating Tesla code\n        197, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    201, Generating exit data copyout(a[:n])\n    205, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.871869439026341
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failing in Thread:1\ncall to cuStreamSynchronize returned error 700: Illegal address during kernel execution\n\n",
                    "export": false,
                    "output": "",
                    "result": 1,
                    "runtime": 2.119375530979596,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT5 -o /usa/chrismun/openacc/build/declare_create.c/declare_create.c6 /usa/chrismun/openacc/Tests/declare_create.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/declare_create.c\", line 26: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/usa/chrismun/openacc/Tests/declare_create.c\", line 70: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/usa/chrismun/openacc/Tests/declare_create.c\", line 109: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/usa/chrismun/openacc/Tests/declare_create.c\", line 147: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\nextern_multiplyData_create:\n      3, include \"acc_testsuite_declare.h\"\n          53, Generating Tesla code\n              55, #pragma acc loop vector /* threadIdx.x */\n          55, Loop is parallelizable\nmultiplyData:\n     13, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n     14, Loop is parallelizable\ntest1:\n     26, Generating update device(n)\n     35, Generating copyout(b[:n]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     37, Generating Tesla code\n         39, #pragma acc loop gang /* blockIdx.x */\n     44, Generating Tesla code\n         46, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     70, Generating update device(n)\n     81, Generating update device(scalar)\n         Generating copyout(b[:n]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     83, Generating Tesla code\n         85, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest3:\n    109, Generating update device(n)\n    119, Generating update device(mult_create)\n         Generating copy(a[:n]) [if not already present]\n    121, Generating Tesla code\n        123, #pragma acc loop gang /* blockIdx.x */\n    130, FMA (fused multiply-add) instruction(s) generated\ntest4:\n    147, Generating update device(n)\n    155, Generating copy(a[:n]) [if not already present]\n    157, Generating Tesla code\n        159, #pragma acc loop gang /* blockIdx.x */\n    166, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.921445699990727
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0188779879827052,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_device_resident.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/declare_device_resident.c/declare_device_resident.c0 /usa/chrismun/openacc/Tests/declare_device_resident.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/declare_device_resident.c\", line 18: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/usa/chrismun/openacc/Tests/declare_device_resident.c\", line 70: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/usa/chrismun/openacc/Tests/declare_device_resident.c\", line 115: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\nextern_multiplyData_device_resident:\n      3, include \"acc_testsuite_declare.h\"\n          65, Generating Tesla code\n              67, #pragma acc loop vector /* threadIdx.x */\n          67, Loop is parallelizable\ntest1:\n     21, Generating Tesla code\n         24, #pragma acc loop seq\n     24, Loop is parallelizable\n     35, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(b[:n]) [if not already present]\n     37, Generating Tesla code\n         39, #pragma acc loop gang /* blockIdx.x */\n     44, Generating Tesla code\n         46, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     73, Generating Tesla code\n         76, #pragma acc loop seq\n     76, Loop is parallelizable\n     87, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(b[:n]) [if not already present]\n     89, Generating Tesla code\n         91, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest3:\n    118, Generating Tesla code\n        121, #pragma acc loop seq\n    121, Loop is parallelizable\n    132, Generating copy(a[:n]) [if not already present]\n    134, Generating Tesla code\n        136, #pragma acc loop gang /* blockIdx.x */\n    143, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8701850179350004
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0688062829431146,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_function_scope_copy.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/declare_function_scope_copy.c/declare_function_scope_copy.c0 /usa/chrismun/openacc/Tests/declare_function_scope_copy.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/declare_function_scope_copy.c\", line 194: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\ncopyin_copyout_test:\n      5, Generating copy(c[:n]) [if not already present]\n         Generating present(a[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820487434975803
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009180943015962839,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/declare_function_scope_copy.c/declare_function_scope_copy.c1 /usa/chrismun/openacc/Tests/declare_function_scope_copy.c",
                    "config": 1,
                    "errors": "copyin_copyout_test:\n      5, Generating copy(c[:n]) [if not already present]\n         Generating present(a[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest1:\n     33, Generating copyin(b[:n][:n],a[:n][:n]) [if not already present]\n     40, Zero trip check eliminated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8198808900779113
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0192378980573267,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT3 -DT4 -o /usa/chrismun/openacc/build/declare_function_scope_copy.c/declare_function_scope_copy.c2 /usa/chrismun/openacc/Tests/declare_function_scope_copy.c",
                    "config": 1,
                    "errors": "copyin_copyout_test:\n      5, Generating copy(c[:n]) [if not already present]\n         Generating present(a[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     69, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n     72, Generating copy(c[x][:n]) [if not already present]\n     79, Zero trip check eliminated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.920700412010774
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 0.16519945999607444,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -o /usa/chrismun/openacc/build/declare_function_scope_copy.c/declare_function_scope_copy.c3 /usa/chrismun/openacc/Tests/declare_function_scope_copy.c",
                    "config": 1,
                    "errors": "copyin_copyout_test:\n      5, Generating copy(c[:n]) [if not already present]\n         Generating present(a[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest3:\n    103, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    117, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n    120, Generating copyin(c[x][:n]) [if not already present]\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870387660106644
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 2.218906290945597,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -o /usa/chrismun/openacc/build/declare_function_scope_copy.c/declare_function_scope_copy.c4 /usa/chrismun/openacc/Tests/declare_function_scope_copy.c",
                    "config": 1,
                    "errors": "copyin_copyout_test:\n      5, Generating copy(c[:n]) [if not already present]\n         Generating present(a[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest4:\n    154, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    168, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n    171, Generating copy(c[x][:n]) [if not already present]\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.819977873004973
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 1.9694114109734073,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -o /usa/chrismun/openacc/build/declare_function_scope_copy.c/declare_function_scope_copy.c5 /usa/chrismun/openacc/Tests/declare_function_scope_copy.c",
                    "config": 1,
                    "errors": "copyin_copyout_test:\n      5, Generating copy(c[:n]) [if not already present]\n         Generating present(a[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest1:\n     33, Generating copyin(b[:n][:n],a[:n][:n]) [if not already present]\n     40, Zero trip check eliminated\ntest4:\n    154, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    168, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n    171, Generating copy(c[x][:n]) [if not already present]\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8705496959155425
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0689857529941946,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_function_scope_copyin.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/declare_function_scope_copyin.c/declare_function_scope_copyin.c0 /usa/chrismun/openacc/Tests/declare_function_scope_copyin.c",
                    "config": 1,
                    "errors": "function_test:\n      5, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nfunction_test_dev_only:\n     16, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n         Generating Tesla code\n         18, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest1:\n     47, Generating copy(c[:n][:n]) [if not already present]\n     54, Zero trip check eliminated\ntest2:\n     80, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     98, Generating copy(a[:n][:n],c[:n][:n],b[:n][:n]) [if not already present]\n    105, Zero trip check eliminated\ntest3:\n    138, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    154, Generating copy(c[:n][:n]) [if not already present]\n    161, Zero trip check eliminated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9205293100094423
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 2.169651616946794,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/declare_function_scope_copyin.c/declare_function_scope_copyin.c1 /usa/chrismun/openacc/Tests/declare_function_scope_copyin.c",
                    "config": 1,
                    "errors": "function_test:\n      5, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nfunction_test_dev_only:\n     16, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n         Generating Tesla code\n         18, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     80, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     98, Generating copy(a[:n][:n],c[:n][:n],b[:n][:n]) [if not already present]\n    105, Zero trip check eliminated\ntest3:\n    138, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    154, Generating copy(c[:n][:n]) [if not already present]\n    161, Zero trip check eliminated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.921792305074632
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 2.168891308014281,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/declare_function_scope_copyin.c/declare_function_scope_copyin.c2 /usa/chrismun/openacc/Tests/declare_function_scope_copyin.c",
                    "config": 1,
                    "errors": "function_test:\n      5, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nfunction_test_dev_only:\n     16, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n         Generating Tesla code\n         18, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest1:\n     47, Generating copy(c[:n][:n]) [if not already present]\n     54, Zero trip check eliminated\ntest3:\n    138, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    154, Generating copy(c[:n][:n]) [if not already present]\n    161, Zero trip check eliminated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870520679978654
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 2.1692876670276746,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/declare_function_scope_copyin.c/declare_function_scope_copyin.c3 /usa/chrismun/openacc/Tests/declare_function_scope_copyin.c",
                    "config": 1,
                    "errors": "function_test:\n      5, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nfunction_test_dev_only:\n     16, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n         Generating Tesla code\n         18, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     80, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     98, Generating copy(a[:n][:n],c[:n][:n],b[:n][:n]) [if not already present]\n    105, Zero trip check eliminated\ntest3:\n    138, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    154, Generating copy(c[:n][:n]) [if not already present]\n    161, Zero trip check eliminated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.920182292931713
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 2.169101236970164,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT3 -o /usa/chrismun/openacc/build/declare_function_scope_copyin.c/declare_function_scope_copyin.c4 /usa/chrismun/openacc/Tests/declare_function_scope_copyin.c",
                    "config": 1,
                    "errors": "function_test:\n      5, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nfunction_test_dev_only:\n     16, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n         Generating Tesla code\n         18, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest1:\n     47, Generating copy(c[:n][:n]) [if not already present]\n     54, Zero trip check eliminated\ntest2:\n     80, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     98, Generating copy(a[:n][:n],c[:n][:n],b[:n][:n]) [if not already present]\n    105, Zero trip check eliminated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9202349740080535
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 2.169589527999051,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/declare_function_scope_copyin.c/declare_function_scope_copyin.c5 /usa/chrismun/openacc/Tests/declare_function_scope_copyin.c",
                    "config": 1,
                    "errors": "function_test:\n      5, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nfunction_test_dev_only:\n     16, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n         Generating Tesla code\n         18, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     80, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     98, Generating copy(a[:n][:n],c[:n][:n],b[:n][:n]) [if not already present]\n    105, Zero trip check eliminated\ntest3:\n    138, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    154, Generating copy(c[:n][:n]) [if not already present]\n    161, Zero trip check eliminated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.920739196939394
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 2.168692762963474,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/declare_function_scope_copyin.c/declare_function_scope_copyin.c6 /usa/chrismun/openacc/Tests/declare_function_scope_copyin.c",
                    "config": 1,
                    "errors": "function_test:\n      5, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nfunction_test_dev_only:\n     16, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n         Generating Tesla code\n         18, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest1:\n     47, Generating copy(c[:n][:n]) [if not already present]\n     54, Zero trip check eliminated\ntest3:\n    138, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    154, Generating copy(c[:n][:n]) [if not already present]\n    161, Zero trip check eliminated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.821015011984855
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 2.1753745350288227,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/declare_function_scope_copyin.c/declare_function_scope_copyin.c7 /usa/chrismun/openacc/Tests/declare_function_scope_copyin.c",
                    "config": 1,
                    "errors": "function_test:\n      5, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nfunction_test_dev_only:\n     16, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating present(c[:n])\n         Generating Tesla code\n         18, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     80, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     98, Generating copy(a[:n][:n],c[:n][:n],b[:n][:n]) [if not already present]\n    105, Zero trip check eliminated\ntest3:\n    138, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    154, Generating copy(c[:n][:n]) [if not already present]\n    161, Zero trip check eliminated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9203674430027604
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": true,
                    "output": "",
                    "result": 139,
                    "runtime": 2.169160268967971,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_function_scope_copyout.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/declare_function_scope_copyout.c/declare_function_scope_copyout.c0 /usa/chrismun/openacc/Tests/declare_function_scope_copyout.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/declare_function_scope_copyout.c\", line 194: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\ncopyout_test:\n      5, Generating copyout(c[:n]) [if not already present]\n         Generating present(a[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.821250927983783
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0091493830550462,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/declare_function_scope_copyout.c/declare_function_scope_copyout.c1 /usa/chrismun/openacc/Tests/declare_function_scope_copyout.c",
                    "config": 1,
                    "errors": "copyout_test:\n      5, Generating copyout(c[:n]) [if not already present]\n         Generating present(a[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest1:\n     33, Generating copyin(b[:n][:n],a[:n][:n]) [if not already present]\n     40, Zero trip check eliminated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8204582090256736
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0686988109955564,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT3 -DT4 -o /usa/chrismun/openacc/build/declare_function_scope_copyout.c/declare_function_scope_copyout.c2 /usa/chrismun/openacc/Tests/declare_function_scope_copyout.c",
                    "config": 1,
                    "errors": "copyout_test:\n      5, Generating copyout(c[:n]) [if not already present]\n         Generating present(a[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     69, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n     72, Generating copy(c[x][:n]) [if not already present]\n     79, Zero trip check eliminated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820395902963355
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 0.16562585590872914,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -o /usa/chrismun/openacc/build/declare_function_scope_copyout.c/declare_function_scope_copyout.c3 /usa/chrismun/openacc/Tests/declare_function_scope_copyout.c",
                    "config": 1,
                    "errors": "copyout_test:\n      5, Generating copyout(c[:n]) [if not already present]\n         Generating present(a[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest3:\n    103, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    117, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n    120, Generating copyin(c[x][:n]) [if not already present]\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8712357019539922
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 2.169299140921794,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -o /usa/chrismun/openacc/build/declare_function_scope_copyout.c/declare_function_scope_copyout.c4 /usa/chrismun/openacc/Tests/declare_function_scope_copyout.c",
                    "config": 1,
                    "errors": "copyout_test:\n      5, Generating copyout(c[:n]) [if not already present]\n         Generating present(a[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest4:\n    154, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    168, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n    171, Generating copy(c[x][:n]) [if not already present]\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7703424289356917
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 2.1694900300353765,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/declare_function_scope_copyout.c/declare_function_scope_copyout.c5 /usa/chrismun/openacc/Tests/declare_function_scope_copyout.c",
                    "config": 1,
                    "errors": "copyout_test:\n      5, Generating copyout(c[:n]) [if not already present]\n         Generating present(a[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest1:\n     33, Generating copyin(b[:n][:n],a[:n][:n]) [if not already present]\n     40, Zero trip check eliminated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8198463729349896
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0691726070363075,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_function_scope_create.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/declare_function_scope_create.c/declare_function_scope_create.c0 /usa/chrismun/openacc/Tests/declare_function_scope_create.c",
                    "config": 1,
                    "errors": "create_test:\n      5, Generating create(c[:n]) [if not already present]\n         Generating present(a[:n],d[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         11, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ncreate_as_present:\n     20, Generating create(c[:n]) [if not already present]\n         Generating present(a[:n],d[:n],b[:n])\n         Generating Tesla code\n         22, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest1:\n     55, Generating copyin(a[:n][:n]) [if not already present]\n         Generating copyout(d[:n][:n]) [if not already present]\n         Generating copyin(b[:n][:n]) [if not already present]\n     62, Zero trip check eliminated\n     63, FMA (fused multiply-add) instruction(s) generated\ntest2:\n     93, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n         Generating copy(c[:n][:n]) [if not already present]\n         Generating copyout(d[:n][:n]) [if not already present]\n    100, Zero trip check eliminated\n    104, FMA (fused multiply-add) instruction(s) generated\ntest3:\n    128, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    142, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n    145, Generating copyout(d[x][:n]) [if not already present]\n         Generating copyin(c[x][:n]) [if not already present]\n    154, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.970744166057557
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 2.1684668969828635,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/declare_function_scope_create.c/declare_function_scope_create.c1 /usa/chrismun/openacc/Tests/declare_function_scope_create.c",
                    "config": 1,
                    "errors": "create_test:\n      5, Generating create(c[:n]) [if not already present]\n         Generating present(a[:n],d[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         11, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ncreate_as_present:\n     20, Generating create(c[:n]) [if not already present]\n         Generating present(a[:n],d[:n],b[:n])\n         Generating Tesla code\n         22, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     93, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n         Generating copy(c[:n][:n]) [if not already present]\n         Generating copyout(d[:n][:n]) [if not already present]\n    100, Zero trip check eliminated\n    104, FMA (fused multiply-add) instruction(s) generated\ntest3:\n    128, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    142, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n    145, Generating copyout(d[x][:n]) [if not already present]\n         Generating copyin(c[x][:n]) [if not already present]\n    154, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9217790799448267
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 0.1656880519585684,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/declare_function_scope_create.c/declare_function_scope_create.c2 /usa/chrismun/openacc/Tests/declare_function_scope_create.c",
                    "config": 1,
                    "errors": "create_test:\n      5, Generating create(c[:n]) [if not already present]\n         Generating present(a[:n],d[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         11, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ncreate_as_present:\n     20, Generating create(c[:n]) [if not already present]\n         Generating present(a[:n],d[:n],b[:n])\n         Generating Tesla code\n         22, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest1:\n     55, Generating copyin(a[:n][:n]) [if not already present]\n         Generating copyout(d[:n][:n]) [if not already present]\n         Generating copyin(b[:n][:n]) [if not already present]\n     62, Zero trip check eliminated\n     63, FMA (fused multiply-add) instruction(s) generated\ntest3:\n    128, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    142, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n    145, Generating copyout(d[x][:n]) [if not already present]\n         Generating copyin(c[x][:n]) [if not already present]\n    154, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9207396170822904
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 2.2189122299896553,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/declare_function_scope_create.c/declare_function_scope_create.c3 /usa/chrismun/openacc/Tests/declare_function_scope_create.c",
                    "config": 1,
                    "errors": "create_test:\n      5, Generating create(c[:n]) [if not already present]\n         Generating present(a[:n],d[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         11, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ncreate_as_present:\n     20, Generating create(c[:n]) [if not already present]\n         Generating present(a[:n],d[:n],b[:n])\n         Generating Tesla code\n         22, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     93, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n         Generating copy(c[:n][:n]) [if not already present]\n         Generating copyout(d[:n][:n]) [if not already present]\n    100, Zero trip check eliminated\n    104, FMA (fused multiply-add) instruction(s) generated\ntest3:\n    128, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    142, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n    145, Generating copyout(d[x][:n]) [if not already present]\n         Generating copyin(c[x][:n]) [if not already present]\n    154, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8716665250249207
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 0.16574287600815296,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT3 -o /usa/chrismun/openacc/build/declare_function_scope_create.c/declare_function_scope_create.c4 /usa/chrismun/openacc/Tests/declare_function_scope_create.c",
                    "config": 1,
                    "errors": "create_test:\n      5, Generating create(c[:n]) [if not already present]\n         Generating present(a[:n],d[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         11, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ncreate_as_present:\n     20, Generating create(c[:n]) [if not already present]\n         Generating present(a[:n],d[:n],b[:n])\n         Generating Tesla code\n         22, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest1:\n     55, Generating copyin(a[:n][:n]) [if not already present]\n         Generating copyout(d[:n][:n]) [if not already present]\n         Generating copyin(b[:n][:n]) [if not already present]\n     62, Zero trip check eliminated\n     63, FMA (fused multiply-add) instruction(s) generated\ntest2:\n     93, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n         Generating copy(c[:n][:n]) [if not already present]\n         Generating copyout(d[:n][:n]) [if not already present]\n    100, Zero trip check eliminated\n    104, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9204144909745082
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 2.2196749129798263,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/declare_function_scope_create.c/declare_function_scope_create.c5 /usa/chrismun/openacc/Tests/declare_function_scope_create.c",
                    "config": 1,
                    "errors": "create_test:\n      5, Generating create(c[:n]) [if not already present]\n         Generating present(a[:n],d[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         11, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ncreate_as_present:\n     20, Generating create(c[:n]) [if not already present]\n         Generating present(a[:n],d[:n],b[:n])\n         Generating Tesla code\n         22, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     93, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n         Generating copy(c[:n][:n]) [if not already present]\n         Generating copyout(d[:n][:n]) [if not already present]\n    100, Zero trip check eliminated\n    104, FMA (fused multiply-add) instruction(s) generated\ntest3:\n    128, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    142, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n    145, Generating copyout(d[x][:n]) [if not already present]\n         Generating copyin(c[x][:n]) [if not already present]\n    154, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.921886062948033
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 0.16542695998214185,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/declare_function_scope_create.c/declare_function_scope_create.c6 /usa/chrismun/openacc/Tests/declare_function_scope_create.c",
                    "config": 1,
                    "errors": "create_test:\n      5, Generating create(c[:n]) [if not already present]\n         Generating present(a[:n],d[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         11, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ncreate_as_present:\n     20, Generating create(c[:n]) [if not already present]\n         Generating present(a[:n],d[:n],b[:n])\n         Generating Tesla code\n         22, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest1:\n     55, Generating copyin(a[:n][:n]) [if not already present]\n         Generating copyout(d[:n][:n]) [if not already present]\n         Generating copyin(b[:n][:n]) [if not already present]\n     62, Zero trip check eliminated\n     63, FMA (fused multiply-add) instruction(s) generated\ntest3:\n    128, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    142, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n    145, Generating copyout(d[x][:n]) [if not already present]\n         Generating copyin(c[x][:n]) [if not already present]\n    154, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9205420629587024
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 2.169934120029211,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/declare_function_scope_create.c/declare_function_scope_create.c7 /usa/chrismun/openacc/Tests/declare_function_scope_create.c",
                    "config": 1,
                    "errors": "create_test:\n      5, Generating create(c[:n]) [if not already present]\n         Generating present(a[:n],d[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         11, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ncreate_as_present:\n     20, Generating create(c[:n]) [if not already present]\n         Generating present(a[:n],d[:n],b[:n])\n         Generating Tesla code\n         22, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     93, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n         Generating copy(c[:n][:n]) [if not already present]\n         Generating copyout(d[:n][:n]) [if not already present]\n    100, Zero trip check eliminated\n    104, FMA (fused multiply-add) instruction(s) generated\ntest3:\n    128, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    142, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n    145, Generating copyout(d[x][:n]) [if not already present]\n         Generating copyin(c[x][:n]) [if not already present]\n    154, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.869912991998717
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": true,
                    "output": "",
                    "result": 139,
                    "runtime": 0.16553877003025264,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_function_scope_deviceptr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/declare_function_scope_deviceptr.c/declare_function_scope_deviceptr.c0 /usa/chrismun/openacc/Tests/declare_function_scope_deviceptr.c",
                    "config": 1,
                    "errors": "declare_deviceptr:\n      5, Generating present(a[:n],d[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         11, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest1:\n     43, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n         Generating copy(c[:n][:n]) [if not already present]\n         Generating copyout(d[:n][:n]) [if not already present]\n     51, Zero trip check eliminated\n     55, FMA (fused multiply-add) instruction(s) generated\ntest2:\n     80, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     94, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n     97, Generating copyout(d[x][:n]) [if not already present]\n    107, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870596624095924
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 2.169155008974485,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/declare_function_scope_deviceptr.c/declare_function_scope_deviceptr.c1 /usa/chrismun/openacc/Tests/declare_function_scope_deviceptr.c",
                    "config": 1,
                    "errors": "declare_deviceptr:\n      5, Generating present(a[:n],d[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         11, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     80, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     94, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n     97, Generating copyout(d[x][:n]) [if not already present]\n    107, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870885908952914
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 2.1192508559906855,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/declare_function_scope_deviceptr.c/declare_function_scope_deviceptr.c2 /usa/chrismun/openacc/Tests/declare_function_scope_deviceptr.c",
                    "config": 1,
                    "errors": "declare_deviceptr:\n      5, Generating present(a[:n],d[:n],b[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         11, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest1:\n     43, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n         Generating copy(c[:n][:n]) [if not already present]\n         Generating copyout(d[:n][:n]) [if not already present]\n     51, Zero trip check eliminated\n     55, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8206132230116054
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0192881430266425,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_function_scope_present.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/declare_function_scope_present.c/declare_function_scope_present.c0 /usa/chrismun/openacc/Tests/declare_function_scope_present.c",
                    "config": 1,
                    "errors": "present:\n      5, Generating present(b[:n],a[:n],c[:n],d[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         11, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest1:\n     41, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n         Generating copyout(d[:n][:n]) [if not already present]\n     44, Generating copy(c[x][:n]) [if not already present]\n     51, Zero trip check eliminated\n     55, FMA (fused multiply-add) instruction(s) generated\ntest2:\n     79, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     93, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n     96, Generating copyout(d[x][:n]) [if not already present]\n         Generating copyin(c[x][:n]) [if not already present]\n    105, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.920032770955004
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 2.1691801430424675,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/declare_function_scope_present.c/declare_function_scope_present.c1 /usa/chrismun/openacc/Tests/declare_function_scope_present.c",
                    "config": 1,
                    "errors": "present:\n      5, Generating present(b[:n],a[:n],c[:n],d[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         11, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     79, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     93, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n     96, Generating copyout(d[x][:n]) [if not already present]\n         Generating copyin(c[x][:n]) [if not already present]\n    105, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870873939944431
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 2.169599605957046,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/declare_function_scope_present.c/declare_function_scope_present.c2 /usa/chrismun/openacc/Tests/declare_function_scope_present.c",
                    "config": 1,
                    "errors": "present:\n      5, Generating present(b[:n],a[:n],c[:n],d[:n])\n         Generating Tesla code\n          7, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         11, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest1:\n     41, Generating copyin(a[:n][:n],b[:n][:n]) [if not already present]\n         Generating copyout(d[:n][:n]) [if not already present]\n     44, Generating copy(c[x][:n]) [if not already present]\n     51, Zero trip check eliminated\n     55, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.82023895799648
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0693619629601017,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "enter_data_copyin_no_lower_bound.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/enter_data_copyin_no_lower_bound.c/enter_data_copyin_no_lower_bound.c0 /usa/chrismun/openacc/Tests/enter_data_copyin_no_lower_bound.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating enter data copyin(b[:n])\n         Generating enter data create(c[:n])\n         Generating enter data copyin(a[:n])\n         Generating present(a[:n],c[:n],b[:n])\n         Generating Tesla code\n         21, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     24, Generating exit data delete(a[:n])\n         Generating exit data copyout(c[:n])\n         Generating exit data delete(b[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.821048420970328
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0189866609871387,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "enter_data_create.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/enter_data_create.c/enter_data_create.c0 /usa/chrismun/openacc/Tests/enter_data_create.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating enter data create(b[:n])\n         Generating copyin(a[:n]) [if not already present]\n     21, Generating present(b[:n])\n         Generating Tesla code\n         23, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     29, Generating copyout(c[:n]) [if not already present]\n     31, Generating present(b[:n])\n         Generating Tesla code\n         33, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     37, Generating exit data delete(b[:n])\ntest2:\n     68, Generating enter data create(b[:n])\n         Generating copyin(a[:n]) [if not already present]\n     70, Generating present(b[:n])\n         Generating Tesla code\n         72, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     78, Generating copyout(c[:n]) [if not already present]\n     80, Generating present(b[:n])\n         Generating Tesla code\n         82, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     86, Generating exit data delete(b[:n])\ntest3:\n    116, Generating enter data create(b[:n])\n         Generating copyin(a[:n]) [if not already present]\n    118, Generating present(b[:n])\n         Generating Tesla code\n        120, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    126, Generating copyout(c[:n]) [if not already present]\n    128, Generating present(b[:n])\n         Generating Tesla code\n        130, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    134, Generating exit data delete(b[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9202889719745144
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0688389650313184,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "enter_data_create_no_lower_bound.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/enter_data_create_no_lower_bound.c/enter_data_create_no_lower_bound.c0 /usa/chrismun/openacc/Tests/enter_data_create_no_lower_bound.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating enter data copyin(b[:n])\n         Generating enter data create(c[:n])\n         Generating enter data copyin(a[:n])\n         Generating present(a[:n],c[:n],b[:n])\n         Generating Tesla code\n         21, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     24, Generating exit data copyout(c[:n])\n         Generating exit data delete(b[:n],a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870364407892339
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0187759030377492,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "enter_exit_data_if.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -o /usa/chrismun/openacc/build/enter_exit_data_if.c/enter_exit_data_if.c0 /usa/chrismun/openacc/Tests/enter_exit_data_if.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/enter_exit_data_if.c\", line 252: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1192630199948326
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009206551010720432,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -DT5 -o /usa/chrismun/openacc/build/enter_exit_data_if.c/enter_exit_data_if.c1 /usa/chrismun/openacc/Tests/enter_exit_data_if.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/enter_exit_data_if.c\", line 11: warning: variable \"host\" was declared but never referenced\n      int host = 0;\n          ^\n\ntest1:\n     21, Generating enter data copyin(a[:n],b[:n])\n         Generating create(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating create(b[:n]) [if not already present]\n     23, Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     29, Generating exit data delete(b[:n],a[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7695385710103437
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018479102058336,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT3 -DT4 -DT5 -o /usa/chrismun/openacc/build/enter_exit_data_if.c/enter_exit_data_if.c2 /usa/chrismun/openacc/Tests/enter_exit_data_if.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/enter_exit_data_if.c\", line 50: warning: variable \"dev\" was declared but never referenced\n      int dev = 1;\n          ^\n\ntest2:\n     61, Generating enter data create(a[:n],b[:n])\n         Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     63, Generating Tesla code\n         65, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     69, Generating exit data delete(b[:n],a[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.770799473975785
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0191935430048034,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -DT5 -o /usa/chrismun/openacc/build/enter_exit_data_if.c/enter_exit_data_if.c3 /usa/chrismun/openacc/Tests/enter_exit_data_if.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/enter_exit_data_if.c\", line 93: warning: variable \"host\" was declared but never referenced\n      int host = 0;\n          ^\n\ntest3:\n     99, Generating enter data copyin(devtest[:1])\n         Generating Tesla code\n         Generating implicit copyout(devtest[0]) [if not already present]\n    110, Generating enter data copyin(b[:n],a[:n])\n    118, Generating create(a[:n],b[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n    120, Generating Tesla code\n        122, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    126, Generating exit data copyout(b[:n],a[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.869609017041512
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0191415649605915,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT5 -o /usa/chrismun/openacc/build/enter_exit_data_if.c/enter_exit_data_if.c4 /usa/chrismun/openacc/Tests/enter_exit_data_if.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/enter_exit_data_if.c\", line 150: warning: variable \"dev\" was declared but never referenced\n      int dev = 1;\n          ^\n\ntest4:\n    157, Generating enter data copyin(devtest[:1])\n         Generating Tesla code\n         Generating implicit copyout(devtest[0]) [if not already present]\n    166, Generating enter data copyin(b[:n],a[:n])\n    176, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n    178, Generating Tesla code\n        180, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    184, Generating exit data copyout(b[:n],a[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.77017168502789
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069362346082926,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/enter_exit_data_if.c/enter_exit_data_if.c5 /usa/chrismun/openacc/Tests/enter_exit_data_if.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/enter_exit_data_if.c\", line 208: warning: variable \"dev\" was declared but never referenced\n      int dev = 1;\n          ^\n\ntest5:\n    215, Generating enter data copyin(devtest[:1])\n         Generating Tesla code\n         Generating implicit copyout(devtest[0]) [if not already present]\n    228, Generating enter data create(a[:n],b[:n])\n         Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n    230, Generating Tesla code\n        232, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    236, Generating exit data copyout(b[:n],a[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.871015694923699
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019488158985041,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/enter_exit_data_if.c/enter_exit_data_if.c6 /usa/chrismun/openacc/Tests/enter_exit_data_if.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/enter_exit_data_if.c\", line 11: warning: variable \"host\" was declared but never referenced\n      int host = 0;\n          ^\n\n\"/usa/chrismun/openacc/Tests/enter_exit_data_if.c\", line 50: warning: variable \"dev\" was declared but never referenced\n      int dev = 1;\n          ^\n\n\"/usa/chrismun/openacc/Tests/enter_exit_data_if.c\", line 93: warning: variable \"host\" was declared but never referenced\n      int host = 0;\n          ^\n\n\"/usa/chrismun/openacc/Tests/enter_exit_data_if.c\", line 150: warning: variable \"dev\" was declared but never referenced\n      int dev = 1;\n          ^\n\n\"/usa/chrismun/openacc/Tests/enter_exit_data_if.c\", line 208: warning: variable \"dev\" was declared but never referenced\n      int dev = 1;\n          ^\n\ntest1:\n     21, Generating enter data copyin(a[:n],b[:n])\n         Generating create(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating create(b[:n]) [if not already present]\n     23, Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     29, Generating exit data delete(b[:n],a[:n])\ntest2:\n     61, Generating enter data create(a[:n],b[:n])\n         Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     63, Generating Tesla code\n         65, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     69, Generating exit data delete(b[:n],a[:n])\ntest3:\n     99, Generating enter data copyin(devtest[:1])\n         Generating Tesla code\n         Generating implicit copyout(devtest[0]) [if not already present]\n    110, Generating enter data copyin(b[:n],a[:n])\n    118, Generating create(a[:n],b[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n    120, Generating Tesla code\n        122, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    126, Generating exit data copyout(b[:n],a[:n])\ntest4:\n    157, Generating enter data copyin(devtest[:1])\n         Generating Tesla code\n         Generating implicit copyout(devtest[0]) [if not already present]\n    166, Generating enter data copyin(b[:n],a[:n])\n    176, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n    178, Generating Tesla code\n        180, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    184, Generating exit data copyout(b[:n],a[:n])\ntest5:\n    215, Generating enter data copyin(devtest[:1])\n         Generating Tesla code\n         Generating implicit copyout(devtest[0]) [if not already present]\n    228, Generating enter data create(a[:n],b[:n])\n         Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n    230, Generating Tesla code\n        232, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    236, Generating exit data copyout(b[:n],a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9700417080894113
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019192432053387,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "exit_data.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/exit_data.c/exit_data.c0 /usa/chrismun/openacc/Tests/exit_data.c",
                    "config": 1,
                    "errors": "test1:\n     14, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     26, Generating enter data copyin(a[:n])\n         Generating present(a[:n])\n         Generating Tesla code\n         28, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     31, Generating exit data delete(a[:n])\ntest2:\n     60, Generating enter data copyin(a[:n])\n         Generating present(a[:n])\n         Generating Tesla code\n         62, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     65, Generating exit data copyout(a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8715244570048526
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018985357019119,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "exit_data_copyout_no_lower_bound.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/exit_data_copyout_no_lower_bound.c/exit_data_copyout_no_lower_bound.c0 /usa/chrismun/openacc/Tests/exit_data_copyout_no_lower_bound.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating enter data copyin(b[:n])\n         Generating enter data create(c[:n])\n         Generating enter data copyin(a[:n])\n         Generating present(a[:n],c[:n],b[:n])\n         Generating Tesla code\n         21, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     24, Generating exit data copyout(c[:n])\n         Generating exit data delete(b[:n],a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8202095209853724
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1187171479687095,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "exit_data_copyout_reference_counts.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/exit_data_copyout_reference_counts.c/exit_data_copyout_reference_counts.c0 /usa/chrismun/openacc/Tests/exit_data_copyout_reference_counts.c",
                    "config": 1,
                    "errors": "test1:\n     15, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     28, Generating enter data copyin(b[:n],c[:n],a[:n])\n         Generating copyin(c[:n]) [if not already present]\n     30, Generating Tesla code\n         32, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     30, Generating implicit copyin(b[:n],a[:n]) [if not already present]\n     37, Generating exit data delete(a[:n])\n         Generating exit data copyout(c[:n])\n         Generating exit data delete(b[:n])\ntest2:\n     67, Generating enter data copyin(c[:n],b[:n],a[:n])\n         Generating copyin(c[:n]) [if not already present]\n     69, Generating Tesla code\n         71, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     69, Generating implicit copyin(b[:n],a[:n]) [if not already present]\n     75, Generating exit data delete(a[:n])\n         Generating exit data copyout(c[:n])\n         Generating exit data delete(b[:n])\ntest3:\n    107, Generating enter data copyin(b[:n],a[:n],c[:n])\n         Generating enter data create(c[:n])\n         Generating Tesla code\n        109, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    107, Generating implicit copyin(a[:n]) [if not already present]\n         Generating implicit copy(c[:n]) [if not already present]\n         Generating implicit copyin(b[:n]) [if not already present]\n    112, Generating exit data delete(c[:n])\n         Generating exit data copyout(c[:n])\n         Generating exit data delete(b[:n],a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9201633780030534
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0695081299636513,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "exit_data_delete_no_lower_bound.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/exit_data_delete_no_lower_bound.c/exit_data_delete_no_lower_bound.c0 /usa/chrismun/openacc/Tests/exit_data_delete_no_lower_bound.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating enter data copyin(b[:n])\n         Generating enter data create(c[:n])\n         Generating enter data copyin(a[:n])\n         Generating present(a[:n],c[:n],b[:n])\n         Generating Tesla code\n         21, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     27, Generating exit data copyout(c[:n])\n         Generating exit data delete(b[:n],a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.769694523070939
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019279476022348,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "exit_data_finalize.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/exit_data_finalize.c/exit_data_finalize.c0 /usa/chrismun/openacc/Tests/exit_data_finalize.c",
                    "config": 1,
                    "errors": "test1:\n     15, Generating enter data copyin(devtest[:1])\n         Generating Tesla code\n         Generating implicit copyout(devtest[0]) [if not already present]\n     28, Generating enter data create(b[:n],a[:n],c[:n])\n         Generating enter data copyin(c[:n],b[:n],a[:n])\n         Generating present(a[:n],c[:n],b[:n])\n         Generating Tesla code\n         30, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     35, Generating exit data copyout(b[:n],a[:n],c[:n])\n     41, Generating exit data delete(a[:n])\n         Generating exit data copyout(c[:n])\n         Generating exit data delete(b[:n])\ntest2:\n     71, Generating enter data copyin(c[:n],b[:n],a[:n])\n         Generating present(a[:n],c[:n],b[:n])\n         Generating Tesla code\n         73, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     76, Generating exit data copyout(c[:n]) finalize\n         Generating exit data delete(b[:n],a[:n]) finalize\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870175448944792
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019035576027818,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "host_data.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/host_data.c/host_data.c0 /usa/chrismun/openacc/Tests/host_data.c",
                    "config": 1,
                    "errors": "test1:\n     23, Generating enter data copyin(a[:n])\n     34, Generating enter data copyin(a_points[:n])\n         Generating present(a_points[:n],a[:n])\n         Generating Tesla code\n         36, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     41, Generating exit data delete(a_points[:n])\n         Generating exit data copyout(a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8710059879813343
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0193006050540134,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "init.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/init.c/init.c0 /usa/chrismun/openacc/Tests/init.c",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0691291840048507
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.2194298369577155,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "init_device_num.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/init_device_num.c/init_device_num.c0 /usa/chrismun/openacc/Tests/init_device_num.c",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.119913108064793
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 1.9186923910165206,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "init_device_type.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/init_device_type.c/init_device_type.c0 /usa/chrismun/openacc/Tests/init_device_type.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/init_device_type.c\", line 9: error: Specified device type is not a valid device type. Currently accepted device types are 'nvidia, host, multicore, and default'\n      #pragma acc init device_type(device_type)\n                                   ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/init_device_type.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9685637700604275
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/init_device_type.c/init_device_type.c1 /usa/chrismun/openacc/Tests/init_device_type.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/init_device_type.c\", line 17: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.168945190962404
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00857133197132498,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "init_device_type_num.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/init_device_type_num.c/init_device_type_num.c0 /usa/chrismun/openacc/Tests/init_device_type_num.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/init_device_type_num.c\", line 8: warning: enumerated type mixed with another type\n      int device_num = acc_get_device_num(device_type);\n                                          ^\n\n\"/usa/chrismun/openacc/Tests/init_device_type_num.c\", line 10: error: Specified device type is not a valid device type. Currently accepted device types are 'nvidia, host, multicore, and default'\n      #pragma acc init device_type(device_type) device_num(device_num)\n                                   ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/init_device_type_num.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0208169389516115
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/init_device_type_num.c/init_device_type_num.c1 /usa/chrismun/openacc/Tests/init_device_type_num.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/init_device_type_num.c\", line 18: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1187259641010314
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008645861991681159,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_async.c/kernels_async.c0 /usa/chrismun/openacc/Tests/kernels_async.c",
                    "config": 1,
                    "errors": "test1:\n     26, Generating enter data create(c[:n],f[:n],g[:n])\n         Generating copyin(a[:n],b[:n],d[:n],e[:n]) [if not already present]\n     28, Generating implicit copyout(c[:n]) [if not already present]\n     30, Loop is parallelizable\n         Generating Tesla code\n         30, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     35, Generating implicit copyout(f[:n]) [if not already present]\n     37, Loop is parallelizable\n         Generating Tesla code\n         37, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     42, Generating implicit copyin(c[:n],f[:n]) [if not already present]\n         Generating implicit copyout(g[:n]) [if not already present]\n     44, Loop is parallelizable\n         Generating Tesla code\n         44, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     48, Generating update self(f[:n],c[:n])\n         Generating exit data copyout(g[:n])\n     68, Generating exit data delete(f[:n],c[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870096158934757
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0689034869428724,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_copy.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_copy.c/kernels_copy.c0 /usa/chrismun/openacc/Tests/kernels_copy.c",
                    "config": 1,
                    "errors": "test1:\n     17, Generating copyin(a[:n],b[:n]) [if not already present]\n     19, Generating copy(c[:n]) [if not already present]\n     21, Complex loop carried dependence of b->,a-> prevents parallelization\n         Loop carried dependence of c-> prevents parallelization\n         Loop carried backward dependence of c-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n         21, #pragma acc loop seq\ntest2:\n     49, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Accelerator serial kernel generated\n         Generating Tesla code\n     60, Generating copyin(a[:n],b[:n],c[:n]) [if not already present]\n     62, Generating copy(c[:n]) [if not already present]\n     64, Complex loop carried dependence of b->,a-> prevents parallelization\n         Loop carried dependence of c-> prevents parallelization\n         Loop carried backward dependence of c-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n         64, #pragma acc loop seq\ntest3:\n     93, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Accelerator serial kernel generated\n         Generating Tesla code\n    105, Generating copyin(a[:n]) [if not already present]\n         Generating copy(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n    106, Memory zero idiom, loop replaced by call to __c_mzero8\n    110, Generating copy(c[:n]) [if not already present]\n    112, Complex loop carried dependence of b->,a-> prevents parallelization\n         Loop carried dependence of c-> prevents parallelization\n         Loop carried backward dependence of c-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n        112, #pragma acc loop seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.919846417964436
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019013083074242,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_copyin.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_copyin.c/kernels_copyin.c0 /usa/chrismun/openacc/Tests/kernels_copyin.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/kernels_copyin.c\", line 91: error: identifier \"devtest\" is undefined\n      if (devtest[0] == 1){\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/kernels_copyin.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0190618539927527
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/kernels_copyin.c/kernels_copyin.c1 /usa/chrismun/openacc/Tests/kernels_copyin.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/kernels_copyin.c\", line 91: error: identifier \"devtest\" is undefined\n      if (devtest[0] == 1){\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/kernels_copyin.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0190493599511683
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/kernels_copyin.c/kernels_copyin.c2 /usa/chrismun/openacc/Tests/kernels_copyin.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/kernels_copyin.c\", line 91: error: identifier \"devtest\" is undefined\n      if (devtest[0] == 1){\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/kernels_copyin.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0189933630172163
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/kernels_copyin.c/kernels_copyin.c3 /usa/chrismun/openacc/Tests/kernels_copyin.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/kernels_copyin.c\", line 91: error: identifier \"devtest\" is undefined\n      if (devtest[0] == 1){\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/kernels_copyin.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9684989290544763
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT3 -o /usa/chrismun/openacc/build/kernels_copyin.c/kernels_copyin.c4 /usa/chrismun/openacc/Tests/kernels_copyin.c",
                    "config": 1,
                    "errors": "test1:\n     17, Generating copy(b[:n]) [if not already present]\n     19, Generating copyin(a[:n]) [if not already present]\n     21, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n         21, #pragma acc loop seq\ntest2:\n     48, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Accelerator serial kernel generated\n         Generating Tesla code\n     59, Generating copy(b[:n],a[:n]) [if not already present]\n     60, Memory set idiom, loop replaced by call to __c_mset8\n     64, Generating copyin(a[:n]) [if not already present]\n     66, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n         66, #pragma acc loop seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8703941120766103
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.01974566699937,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_copyout.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_copyout.c/kernels_copyout.c0 /usa/chrismun/openacc/Tests/kernels_copyout.c",
                    "config": 1,
                    "errors": "test1:\n     16, Generating copyin(a[:n]) [if not already present]\n     18, Generating copyout(b[:n]) [if not already present]\n     20, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n         20, #pragma acc loop seq\ntest2:\n     47, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Accelerator serial kernel generated\n         Generating Tesla code\n     58, Generating copyin(a[:n],b[:n]) [if not already present]\n     60, Generating copyout(b[:n]) [if not already present]\n     62, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n         62, #pragma acc loop seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8203852829756215
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.070381188997999,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_create.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_create.c/kernels_create.c0 /usa/chrismun/openacc/Tests/kernels_create.c",
                    "config": 1,
                    "errors": "test1:\n     13, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     24, Generating copyin(a[:n]) [if not already present]\n     26, Generating create(b[:n]) [if not already present]\n     28, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n         28, #pragma acc loop seq\ntest2:\n     60, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(b[:n]) [if not already present]\n     62, Generating create(b[:n]) [if not already present]\n     64, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n         64, #pragma acc loop seq\ntest3:\n     95, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n     97, Generating create(b[:n]) [if not already present]\n     99, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n         99, #pragma acc loop seq\n    103, Complex loop carried dependence of b-> prevents parallelization\n         Loop carried dependence of c-> prevents parallelization\n         Loop carried backward dependence of c-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n        103, #pragma acc loop seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.971052178996615
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0695368929300457,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_default_copy.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_default_copy.c/kernels_default_copy.c0 /usa/chrismun/openacc/Tests/kernels_default_copy.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n],b[:n]) [if not already present]\n     20, Generating implicit copy(c[:n]) [if not already present]\n     22, Complex loop carried dependence of b->,a-> prevents parallelization\n         Loop carried dependence of c prevents parallelization\n         Loop carried backward dependence of c prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n         22, #pragma acc loop seq\ntest2:\n     51, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Accelerator serial kernel generated\n         Generating Tesla code\n     60, Generating enter data copyin(c[:n])\n     63, Memory zero idiom, loop replaced by call to __c_mzero8\n     67, Generating copyin(a[:n],b[:n]) [if not already present]\n     69, Generating implicit copy(c[:n]) [if not already present]\n     71, Complex loop carried dependence of b->,a-> prevents parallelization\n         Loop carried dependence of c prevents parallelization\n         Loop carried backward dependence of c prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n         71, #pragma acc loop seq\n     81, Generating exit data copyout(c[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870799918076955
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0690073230070993,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_default_present.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_default_present.c/kernels_default_present.c0 /usa/chrismun/openacc/Tests/kernels_default_present.c",
                    "config": 1,
                    "errors": "test1:\n     17, Generating enter data copyin(a[:n])\n         Generating enter data create(b[:n])\n         Generating default present(a[:n],b[:n])\n     19, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n         19, #pragma acc loop seq\n     22, Generating exit data copyout(b[:n])\n         Generating exit data delete(a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.821028548059985
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019321443978697,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_if.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/kernels_if.c/kernels_if.c0 /usa/chrismun/openacc/Tests/kernels_if.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/kernels_if.c\", line 174: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1181699759326875
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008886776980943978,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/kernels_if.c/kernels_if.c1 /usa/chrismun/openacc/Tests/kernels_if.c",
                    "config": 1,
                    "errors": "test1:\n     17, Generating present(b[:n],a[:n])\n     19, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n         19, #pragma acc loop seq\n     19, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Memory copy idiom, loop replaced by call to __c_mcopy8\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7713955470826477
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008689854992553592,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT3 -DT4 -o /usa/chrismun/openacc/build/kernels_if.c/kernels_if.c2 /usa/chrismun/openacc/Tests/kernels_if.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/kernels_if.c\", line 49: error: identifier \"data_on_device\" is undefined\n      data_on_device = 1;\n      ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/kernels_if.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.96805757493712
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -o /usa/chrismun/openacc/build/kernels_if.c/kernels_if.c3 /usa/chrismun/openacc/Tests/kernels_if.c",
                    "config": 1,
                    "errors": "test3:\n     82, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     90, Generating enter data copyin(a[:n])\n         Generating enter data create(b[:n])\n     93, Memory set idiom, loop replaced by call to __c_mset8\n     98, Generating present(a[:n],b[:n])\n    100, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n        100, #pragma acc loop seq\n    100, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Memory copy idiom, loop replaced by call to __c_mcopy8\n    113, Generating exit data copyout(b[:n],a[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8197430999716744
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 4,
                    "runtime": 2.0682939970865846,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -o /usa/chrismun/openacc/build/kernels_if.c/kernels_if.c4 /usa/chrismun/openacc/Tests/kernels_if.c",
                    "config": 1,
                    "errors": "test4:\n    137, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    149, Generating enter data copyin(a[:n],b[:n])\n         Generating present(b[:n],a[:n])\n    151, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n        151, #pragma acc loop seq\n    151, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Memory copy idiom, loop replaced by call to __c_mcopy8\n    159, Generating exit data copyout(b[:n],a[:n])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8219146619085222
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018899087095633,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/kernels_if.c/kernels_if.c5 /usa/chrismun/openacc/Tests/kernels_if.c",
                    "config": 1,
                    "errors": "test1:\n     17, Generating present(b[:n],a[:n])\n     19, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n         19, #pragma acc loop seq\n     19, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Memory copy idiom, loop replaced by call to __c_mcopy8\ntest3:\n     82, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     90, Generating enter data copyin(a[:n])\n         Generating enter data create(b[:n])\n     93, Memory set idiom, loop replaced by call to __c_mset8\n     98, Generating present(a[:n],b[:n])\n    100, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n        100, #pragma acc loop seq\n    100, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Memory copy idiom, loop replaced by call to __c_mcopy8\n    113, Generating exit data copyout(b[:n],a[:n])\ntest4:\n    137, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n    149, Generating enter data copyin(a[:n],b[:n])\n         Generating present(b[:n],a[:n])\n    151, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n        151, #pragma acc loop seq\n    151, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Memory copy idiom, loop replaced by call to __c_mcopy8\n    159, Generating exit data copyout(b[:n],a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870071192039177
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 4,
                    "runtime": 2.0693655899958685,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop.c/kernels_loop.c0 /usa/chrismun/openacc/Tests/kernels_loop.c",
                    "config": 1,
                    "errors": "test1:\n     14, Generating copy(a[:1024]) [if not already present]\n         Generating copyout(b[:1024]) [if not already present]\n     17, Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Complex loop carried dependence of b->,a-> prevents parallelization\n         Accelerator serial kernel generated\n         Generating Tesla code\n         17, #pragma acc loop seq\n         19, #pragma acc loop seq\n         21, #pragma acc loop seq\n         23, #pragma acc loop seq\n         25, #pragma acc loop seq\n         27, #pragma acc loop seq\n         29, #pragma acc loop seq\n         31, #pragma acc loop seq\n         33, #pragma acc loop seq\n         35, #pragma acc loop seq\n     19, Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Complex loop carried dependence of a->,b-> prevents parallelization\n     21, Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Complex loop carried dependence of b->,a-> prevents parallelization\n     23, Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Complex loop carried dependence of b->,a-> prevents parallelization\n     25, Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Complex loop carried dependence of b->,a-> prevents parallelization\n     27, Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Complex loop carried dependence of b->,a-> prevents parallelization\n     29, Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Complex loop carried dependence of b->,a-> prevents parallelization\n     31, Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Complex loop carried dependence of b->,a-> prevents parallelization\n     33, Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Complex loop carried dependence of b->,a-> prevents parallelization\n     35, Complex loop carried dependence of b->,a-> prevents parallelization\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9705324979731813
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0193944729398936,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_independent.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_independent.c/kernels_loop_independent.c0 /usa/chrismun/openacc/Tests/kernels_loop_independent.c",
                    "config": 1,
                    "errors": "test1:\n     16, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(b[:n]) [if not already present]\n     18, Loop is parallelizable\n         Generating Tesla code\n         18, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.819838179042563
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0186372230527923,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_add_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_add_general.c/kernels_loop_reduction_add_general.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_add_general.c",
                    "config": 1,
                    "errors": "test1:\n     17, Generating copyin(a[:n]) [if not already present]\n         Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     19, Loop is parallelizable\n         Generating Tesla code\n         19, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.920074649970047
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0184771800413728,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_add_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_add_loop.c/kernels_loop_reduction_add_loop.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_add_loop.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating copyin(a[:n*10],b[:n*10]) [if not already present]\n         Generating copyout(d[:n*10]) [if not already present]\n         Generating create(c[:n*10]) [if not already present]\n     21, Complex loop carried dependence of b->,a->,c-> prevents parallelization\n         Loop carried dependence of d->,c-> prevents parallelization\n         Loop carried backward dependence of d->,c-> prevents vectorization\n         Complex loop carried dependence of d-> prevents parallelization\n         Generating Tesla code\n         21, #pragma acc loop seq\n         24, #pragma acc loop seq\n         29, #pragma acc loop seq\n     24, Complex loop carried dependence of b->,a->,c-> prevents parallelization\n     29, Complex loop carried dependence of d->,c-> prevents parallelization\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8200857860501856
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0182965679559857,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_add_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_add_vector_loop.c/kernels_loop_reduction_add_vector_loop.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_add_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     17, Generating copyin(a[:n*10]) [if not already present]\n         Generating copyout(c[:10]) [if not already present]\n         Generating copyin(b[:n*10]) [if not already present]\n     19, Loop carried dependence of c-> prevents parallelization\n         Loop carried backward dependence of c-> prevents vectorization\n         Complex loop carried dependence of b->,a-> prevents parallelization\n         Generating Tesla code\n         19, #pragma acc loop seq\n         22, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(+:temp)\n     22, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820454814005643
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0189283420331776,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_and_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_and_general.c/kernels_loop_reduction_and_general.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_and_general.c",
                    "config": 1,
                    "errors": "test1:\n     23, Generating copyin(a[:n]) [if not already present]\n         Generating implicit copy(result) [if not already present]\n     25, Loop is parallelizable\n         Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(&&:result)\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8695040909806266
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0689061320153996,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_and_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_and_loop.c/kernels_loop_reduction_and_loop.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_and_loop.c",
                    "config": 1,
                    "errors": "test1:\n     32, Generating copy(a[:n*10]) [if not already present]\n     34, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence due to exposed use of a[:n*10] prevents parallelization\n         Generating Tesla code\n         34, #pragma acc loop seq\n         37, #pragma acc loop worker(128) /* threadIdx.x */\n             Generating reduction(&&:temp)\n         41, #pragma acc loop seq\n     37, Loop is parallelizable\n     41, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence due to exposed use of a[:i1+n*10] prevents parallelization\n     55, Invariant if transformation\n     56, Invariant if transformation\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870682926964946
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069100068998523,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_and_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_and_vector_loop.c/kernels_loop_reduction_and_vector_loop.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_and_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     26, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(b[:10]) [if not already present]\n     28, Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Complex loop carried dependence of a-> prevents parallelization\n         Generating Tesla code\n         28, #pragma acc loop seq\n         31, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(&&:temp)\n     31, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8707660040818155
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068441243027337,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitand_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_bitand_general.c/kernels_loop_reduction_bitand_general.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_bitand_general.c",
                    "config": 1,
                    "errors": "test1:\n     32, Generating copyin(a[:n]) [if not already present]\n         Generating implicit copy(b) [if not already present]\n     34, Loop is parallelizable\n         Generating Tesla code\n         34, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(&:b)\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820834201062098
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019507396966219,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitand_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_bitand_loop.c/kernels_loop_reduction_bitand_loop.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_bitand_loop.c",
                    "config": 1,
                    "errors": "test1:\n     29, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(c[:10],b[:n*10]) [if not already present]\n     31, Complex loop carried dependence of a->,c->,b-> prevents parallelization\n         Loop carried dependence of c->,b-> prevents parallelization\n         Loop carried backward dependence of c->,b-> prevents vectorization\n         Generating Tesla code\n         31, #pragma acc loop seq\n         34, #pragma acc loop worker(128) /* threadIdx.x */\n             Generating reduction(&:temp)\n         39, #pragma acc loop seq\n     34, Loop is parallelizable\n     39, Complex loop carried dependence of c->,b-> prevents parallelization\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8210201599868014
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0184062550542876,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitand_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_bitand_vector_loop.c/kernels_loop_reduction_bitand_vector_loop.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_bitand_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     28, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(b[:10]) [if not already present]\n     30, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Generating Tesla code\n         30, #pragma acc loop seq\n         33, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(&:c)\n     33, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8203702149912715
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019981450983323,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitor_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_bitor_general.c/kernels_loop_reduction_bitor_general.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_bitor_general.c",
                    "config": 1,
                    "errors": "test1:\n     26, Generating copyin(a[:n]) [if not already present]\n         Generating implicit copy(b) [if not already present]\n     28, Loop is parallelizable\n         Generating Tesla code\n         28, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(|:b)\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8200035309419036
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069008896010928,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitor_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_bitor_loop.c/kernels_loop_reduction_bitor_loop.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_bitor_loop.c",
                    "config": 1,
                    "errors": "test1:\n     33, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(c[:10],b[:n*10]) [if not already present]\n     35, Complex loop carried dependence of c->,b-> prevents parallelization\n         Loop carried dependence of c->,b-> prevents parallelization\n         Loop carried backward dependence of c->,b-> prevents vectorization\n         Complex loop carried dependence of a-> prevents parallelization\n         Generating Tesla code\n         35, #pragma acc loop seq\n         38, #pragma acc loop worker(128) /* threadIdx.x */\n             Generating reduction(|:temp)\n         43, #pragma acc loop seq\n     38, Loop is parallelizable\n     43, Complex loop carried dependence of c->,b-> prevents parallelization\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8702776699792594
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0696292880456895,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitor_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_bitor_vector_loop.c/kernels_loop_reduction_bitor_vector_loop.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_bitor_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     27, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(b[:10]) [if not already present]\n     29, Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Complex loop carried dependence of a-> prevents parallelization\n         Generating Tesla code\n         29, #pragma acc loop seq\n         32, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(|:temp)\n     32, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870550444931723
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0693111590808257,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitxor_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_bitxor_general.c/kernels_loop_reduction_bitxor_general.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_bitxor_general.c",
                    "config": 1,
                    "errors": "test1:\n     16, Generating copyin(a[:n]) [if not already present]\n         Generating implicit copy(b) [if not already present]\n     18, Loop is parallelizable\n         Generating Tesla code\n         18, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(^:b)\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8703176480485126
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018703307956457,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitxor_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_bitxor_loop.c/kernels_loop_reduction_bitxor_loop.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_bitxor_loop.c",
                    "config": 1,
                    "errors": "test1:\n     23, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(c[:10],b[:n*10]) [if not already present]\n     25, Complex loop carried dependence of c->,b-> prevents parallelization\n         Loop carried dependence of c->,b-> prevents parallelization\n         Loop carried backward dependence of c->,b-> prevents vectorization\n         Complex loop carried dependence of a-> prevents parallelization\n         Generating Tesla code\n         25, #pragma acc loop seq\n         28, #pragma acc loop worker(128) /* threadIdx.x */\n             Generating reduction(^:temp)\n         33, #pragma acc loop seq\n     28, Loop is parallelizable\n     33, Complex loop carried dependence of c->,b-> prevents parallelization\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820987791987136
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019216947024688,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitxor_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_bitxor_vector_loop.c/kernels_loop_reduction_bitxor_vector_loop.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_bitxor_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(b[:10]) [if not already present]\n     20, Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Complex loop carried dependence of a-> prevents parallelization\n         Generating Tesla code\n         20, #pragma acc loop seq\n         23, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(^:temp)\n     23, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8210975989932194
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0688326238887385,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_max_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_max_general.c/kernels_loop_reduction_max_general.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_max_general.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/kernels_loop_reduction_max_general.c\", line 32: warning: use of \"=\" where \"==\" may have been intended\n      if (found = 0){\n          ^\n\n\"/usa/chrismun/openacc/Tests/kernels_loop_reduction_max_general.c\", line 10: warning: variable \"found\" was set but never used\n      int found = 0;\n          ^\n\ntest1:\n     17, Generating copyin(a[:n]) [if not already present]\n         Generating copy(max) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     19, Loop is parallelizable\n         Generating Tesla code\n         19, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(max:max)\n     25, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8705478319898248
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018651520018466,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_max_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_max_loop.c/kernels_loop_reduction_max_loop.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_max_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/kernels_loop_reduction_max_loop.c\", line 12: warning: variable \"max\" was declared but never referenced\n      real_t max = 0.0;\n             ^\n\ntest1:\n     24, Generating copyin(a[:n*10],b[:n*10]) [if not already present]\n         Generating copy(maximum[:10],c[:n*10]) [if not already present]\n     26, Complex loop carried dependence of maximum-> prevents parallelization\n         Loop carried dependence of c->,maximum-> prevents parallelization\n         Loop carried backward dependence of c->,maximum-> prevents vectorization\n         Complex loop carried dependence of b->,a-> prevents parallelization\n         Loop carried dependence of a-> prevents parallelization\n         Loop carried backward dependence of a-> prevents vectorization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Complex loop carried dependence of c-> prevents parallelization\n         Generating Tesla code\n         26, #pragma acc loop seq\n         29, #pragma acc loop worker(128) /* threadIdx.x */\n             Generating reduction(max:temp)\n         34, #pragma acc loop seq\n     29, Loop is parallelizable\n     34, Complex loop carried dependence of a->,maximum->,c->,b-> prevents parallelization\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.821210433030501
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018985788919963,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_max_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_max_vector_loop.c/kernels_loop_reduction_max_vector_loop.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_max_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(max[:10]) [if not already present]\n         Generating copyin(b[:n*10]) [if not already present]\n     20, Loop carried dependence of max-> prevents parallelization\n         Loop carried backward dependence of max-> prevents vectorization\n         Complex loop carried dependence of b->,a-> prevents parallelization\n         Generating Tesla code\n         20, #pragma acc loop seq\n         23, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(max:temp)\n     23, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870324007002637
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0691566159948707,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_min_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_min_general.c/kernels_loop_reduction_min_general.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_min_general.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating copyin(a[:n]) [if not already present]\n         Generating copy(min) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     21, Loop is parallelizable\n         Generating Tesla code\n         21, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(min:min)\n     27, FMA (fused multiply-add) instruction(s) generated\n     30, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8850100500276312
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0190773450303823,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_min_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_min_loop.c/kernels_loop_reduction_min_loop.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_min_loop.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating copyin(a[:n*10],b[:n*10]) [if not already present]\n         Generating copy(minimum[:10],c[:n*10]) [if not already present]\n     22, Complex loop carried dependence of minimum-> prevents parallelization\n         Loop carried dependence of c->,minimum-> prevents parallelization\n         Loop carried backward dependence of c->,minimum-> prevents vectorization\n         Complex loop carried dependence of b->,a-> prevents parallelization\n         Loop carried dependence of a-> prevents parallelization\n         Loop carried backward dependence of a-> prevents vectorization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Complex loop carried dependence of c-> prevents parallelization\n         Generating Tesla code\n         22, #pragma acc loop seq\n         25, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(min:temp)\n         30, #pragma acc loop seq\n     25, Loop is parallelizable\n     30, Complex loop carried dependence of a->,minimum->,c->,b-> prevents parallelization\n         Inner sequential loop scheduled on accelerator\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.875640362035483
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0690317909466103,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_min_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_min_vector_loop.c/kernels_loop_reduction_min_vector_loop.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_min_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(min[:10]) [if not already present]\n         Generating copyin(b[:n*10]) [if not already present]\n     21, Loop carried dependence of min-> prevents parallelization\n         Loop carried backward dependence of min-> prevents vectorization\n         Complex loop carried dependence of b->,a-> prevents parallelization\n         Generating Tesla code\n         21, #pragma acc loop seq\n         24, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(min:temp)\n     24, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870782105019316
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019779408001341,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_multiply_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_multiply_general.c/kernels_loop_reduction_multiply_general.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_multiply_general.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating copyin(a[:multiplicitive_n]) [if not already present]\n         Generating copy(multiplied_total) [if not already present]\n         Generating copyin(b[:multiplicitive_n]) [if not already present]\n     21, Loop is parallelizable\n         Generating Tesla code\n         21, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(*:multiplied_total)\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870323274983093
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068041487946175,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_multiply_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_multiply_loop.c/kernels_loop_reduction_multiply_loop.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_multiply_loop.c",
                    "config": 1,
                    "errors": "test1:\n     21, Generating copyin(a[:n*10],b[:n*10]) [if not already present]\n         Generating copy(totals[:10]) [if not already present]\n         Generating copyout(c[:n*10]) [if not already present]\n     23, Complex loop carried dependence of totals-> prevents parallelization\n         Loop carried dependence of c->,totals-> prevents parallelization\n         Loop carried backward dependence of c->,totals-> prevents vectorization\n         Complex loop carried dependence of b->,a-> prevents parallelization\n         Loop carried dependence of a-> prevents parallelization\n         Loop carried backward dependence of a-> prevents vectorization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Complex loop carried dependence of c-> prevents parallelization\n         Generating Tesla code\n         23, #pragma acc loop seq\n         26, #pragma acc loop worker(128) /* threadIdx.x */\n             Generating reduction(*:temp)\n         31, #pragma acc loop seq\n     26, Loop is parallelizable\n     31, Complex loop carried dependence of a->,totals->,c->,b-> prevents parallelization\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8692072390113026
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0687152129830793,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_multiply_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_multiply_vector_loop.c/kernels_loop_reduction_multiply_vector_loop.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_multiply_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating copyin(a[:multiplicitive_n*10]) [if not already present]\n         Generating copyout(c[:10]) [if not already present]\n         Generating copyin(b[:multiplicitive_n*10]) [if not already present]\n     21, Loop carried dependence of c-> prevents parallelization\n         Loop carried backward dependence of c-> prevents vectorization\n         Complex loop carried dependence of b->,a-> prevents parallelization\n         Generating Tesla code\n         21, #pragma acc loop seq\n         24, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(*:temp)\n     24, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8204477910185233
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018997843028046,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_or_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_or_general.c/kernels_loop_reduction_or_general.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_or_general.c",
                    "config": 1,
                    "errors": "test1:\n     23, Generating copyin(a[:n]) [if not already present]\n         Generating implicit copy(result) [if not already present]\n     25, Loop is parallelizable\n         Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(||:result)\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8208533350843936
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0185126470169052,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_or_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_or_loop.c/kernels_loop_reduction_or_loop.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_or_loop.c",
                    "config": 1,
                    "errors": "test1:\n     24, Generating copy(a[:n*10]) [if not already present]\n         Generating implicit copy(results[:10]) [if not already present]\n     26, Complex loop carried dependence of results-> prevents parallelization\n         Loop carried dependence of results-> prevents parallelization\n         Loop carried backward dependence of results-> prevents vectorization\n         Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of a-> prevents parallelization\n         Loop carried backward dependence of a-> prevents vectorization\n         Loop carried dependence due to exposed use of a[:n*10] prevents parallelization\n         Generating Tesla code\n         26, #pragma acc loop seq\n         29, #pragma acc loop worker(128) /* threadIdx.x */\n             Generating reduction(||:temp)\n         34, #pragma acc loop seq\n     29, Loop is parallelizable\n     34, Complex loop carried dependence of results->,a-> prevents parallelization\n         Loop carried dependence due to exposed use of a[:i1+n*10] prevents parallelization\n     46, Invariant if transformation\n     54, Invariant if transformation\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8197288130177185
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0195326609537005,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_or_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_reduction_or_vector_loop.c/kernels_loop_reduction_or_vector_loop.c0 /usa/chrismun/openacc/Tests/kernels_loop_reduction_or_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(b[:10]) [if not already present]\n     24, Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Complex loop carried dependence of a-> prevents parallelization\n         Generating Tesla code\n         24, #pragma acc loop seq\n         27, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(||:temp)\n     27, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8199262499110773
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018675785046071,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_seq.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_seq.c/kernels_loop_seq.c0 /usa/chrismun/openacc/Tests/kernels_loop_seq.c",
                    "config": 1,
                    "errors": "test1:\n     17, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     19, Generating Tesla code\n         19, #pragma acc loop seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8706092010252178
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0690138780046254,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_tile.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_tile.c/kernels_loop_tile.c0 /usa/chrismun/openacc/Tests/kernels_loop_tile.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/kernels_loop_tile.c\", line 58: warning: variable \"temp\" was declared but never referenced\n    real_t temp = 0.0;\n           ^\n\ntest1:\n     20, Generating copy(a[:n],b[:n],d2[:n*n],c[:n]) [if not already present]\n     22, Complex loop carried dependence of d2->,c-> prevents parallelization\n         Loop carried dependence of d2-> prevents parallelization\n         Loop carried backward dependence of d2-> prevents vectorization\n         Complex loop carried dependence of b->,a-> prevents parallelization\n     23, Complex loop carried dependence of d2->,c->,b->,a-> prevents parallelization\n         Generating Tesla code\n         22, #pragma acc loop seq tile(32,4)\n         23,   tiled */\n             Generating reduction(+:temp)\n         25, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating implicit reduction(+:temp)\n     25, Loop is parallelizable\n     33, Zero trip check eliminated\n     35, Zero trip check eliminated\ntest2:\n     67, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating copyout(d3[:n*(n*n)]) [if not already present]\n         Generating copyin(c[:n]) [if not already present]\n         Invalid tile width ignored\n     69, Complex loop carried dependence of b->,a-> prevents parallelization\n         Loop carried dependence of d3-> prevents parallelization\n         Loop carried backward dependence of d3-> prevents vectorization\n         Complex loop carried dependence of d3->,c-> prevents parallelization\n     70, Complex loop carried dependence of b->,a-> prevents parallelization\n         Loop carried dependence of d3-> prevents parallelization\n         Loop carried backward dependence of d3-> prevents vectorization\n         Complex loop carried dependence of d3->,c-> prevents parallelization\n     71, Complex loop carried dependence of b->,a->,d3->,c-> prevents parallelization\n         Generating Tesla code\n         69, #pragma acc loop seq tile(0,0,0)\n         70,   tiled */\n         71,   tiled */\n     79, Zero trip check eliminated\n     80, Zero trip check eliminated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.869791934033856
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0690405459608883,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_vector_blocking.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_vector_blocking.c/kernels_loop_vector_blocking.c0 /usa/chrismun/openacc/Tests/kernels_loop_vector_blocking.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/kernels_loop_vector_blocking.c\", line 36: warning: expression has no effect\n        err + 1;\n        ^\n\ntest1:\n     19, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     23, Complex loop carried dependence of b->,a-> prevents parallelization\n         Loop carried dependence of c-> prevents parallelization\n         Loop carried backward dependence of c-> prevents vectorization\n         Generating Tesla code\n         23, #pragma acc loop seq\n     28, Complex loop carried dependence of b->,a-> prevents parallelization\n         Loop carried dependence of c-> prevents parallelization\n         Loop carried backward dependence of c-> prevents vectorization\n         Generating Tesla code\n         28, #pragma acc loop seq\n     35, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8708476870087907
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0685059579554945,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_worker_blocking.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_loop_worker_blocking.c/kernels_loop_worker_blocking.c0 /usa/chrismun/openacc/Tests/kernels_loop_worker_blocking.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/kernels_loop_worker_blocking.c\", line 36: warning: expression has no effect\n        err + 1;\n        ^\n\ntest1:\n     19, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     23, Complex loop carried dependence of b->,a-> prevents parallelization\n         Loop carried dependence of c-> prevents parallelization\n         Loop carried backward dependence of c-> prevents vectorization\n         Generating Tesla code\n         23, #pragma acc loop seq\n     28, Complex loop carried dependence of b->,a-> prevents parallelization\n         Loop carried dependence of c-> prevents parallelization\n         Loop carried backward dependence of c-> prevents vectorization\n         Generating Tesla code\n         28, #pragma acc loop seq\n     35, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.920327287982218
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0190194529714063,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_num_gangs.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_num_gangs.c/kernels_num_gangs.c0 /usa/chrismun/openacc/Tests/kernels_num_gangs.c",
                    "config": 1,
                    "errors": "test1:\n     16, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(b[:n]) [if not already present]\n     18, Loop is parallelizable\n         Generating Tesla code\n         18, #pragma acc loop gang(16), vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820424627047032
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068993367953226,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_num_workers.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_num_workers.c/kernels_num_workers.c0 /usa/chrismun/openacc/Tests/kernels_num_workers.c",
                    "config": 1,
                    "errors": "test1:\n     16, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(b[:n]) [if not already present]\n     18, Loop is parallelizable\n         Generating Tesla code\n         18, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8211632310412824
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0184309129836038,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_present.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_present.c/kernels_present.c0 /usa/chrismun/openacc/Tests/kernels_present.c",
                    "config": 1,
                    "errors": "test1:\n     17, Generating enter data copyin(a[:n])\n         Generating enter data create(b[:n])\n         Generating present(a[:n],b[:n])\n     19, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n         19, #pragma acc loop seq\n     22, Generating exit data copyout(b[:n])\n         Generating exit data delete(a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.81941279489547
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068639750010334,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_scalar_default_copy.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_scalar_default_copy.c/kernels_scalar_default_copy.c0 /usa/chrismun/openacc/Tests/kernels_scalar_default_copy.c",
                    "config": 1,
                    "errors": "test1:\n     21, Generating copyin(b[:n]) [if not already present]\n     23, Generating implicit copy(sum) [if not already present]\n     25, Loop is parallelizable\n         Generating Tesla code\n         25, #pragma acc loop vector(32) /* threadIdx.x */\n             Generating implicit reduction(+:sum)\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8698044379707426
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0695563899353147,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_vector_length.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_vector_length.c/kernels_vector_length.c0 /usa/chrismun/openacc/Tests/kernels_vector_length.c",
                    "config": 1,
                    "errors": "test1:\n     16, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(b[:n]) [if not already present]\n     20, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\n         Generating Tesla code\n         20, #pragma acc loop seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8200527840526775
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069823434925638,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_wait.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/kernels_wait.c/kernels_wait.c0 /usa/chrismun/openacc/Tests/kernels_wait.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating enter data copyin(b[:n],c[:n],a[:n])\n         Generating implicit copyin(a[:n]) [if not already present]\n         Generating implicit copy(c[:n]) [if not already present]\n         Generating implicit copyin(b[:n]) [if not already present]\n     21, Complex loop carried dependence of b->,a-> prevents parallelization\n         Loop carried dependence of c-> prevents parallelization\n         Loop carried backward dependence of c-> prevents vectorization\n         Accelerator serial kernel generated\n         Generating Tesla code\n         21, #pragma acc loop seq\n     24, Generating exit data delete(a[:n])\n         Generating exit data copyout(c[:n])\n         Generating exit data delete(b[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820371596957557
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069528339081444,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "loop_collapse.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/loop_collapse.c/loop_collapse.c0 /usa/chrismun/openacc/Tests/loop_collapse.c",
                    "config": 1,
                    "errors": "test1:\n     21, Generating copyin(a[:n*10],b[:n*10]) [if not already present]\n         Generating copy(c[:n*10]) [if not already present]\n     23, Generating Tesla code\n         25, #pragma acc loop gang /* blockIdx.x */\n         26, #pragma acc loop seq\n     26, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of c-> prevents parallelization\n         Loop carried backward dependence of c-> prevents vectorization\n         Complex loop carried dependence of c->,b-> prevents parallelization\ntest2:\n     64, Generating copyin(a[:n*10]) [if not already present]\n         Generating copyout(c[:n*10]) [if not already present]\n         Generating copyin(b[:n*10]) [if not already present]\n     66, Generating Tesla code\n         68, #pragma acc loop gang, vector(128) collapse(2) /* blockIdx.x threadIdx.x */\n         69,   /* blockIdx.x threadIdx.x collapsed */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9199238340370357
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018490184098482,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "loop_no_collapse_default.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/loop_no_collapse_default.c/loop_no_collapse_default.c0 /usa/chrismun/openacc/Tests/loop_no_collapse_default.c",
                    "config": 1,
                    "errors": "test1:\n     21, Generating copyin(a[:n*10],b[:n*10]) [if not already present]\n         Generating copy(c[:n*10]) [if not already present]\n     23, Generating Tesla code\n         25, #pragma acc loop gang /* blockIdx.x */\n         26, #pragma acc loop seq\n     26, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of c-> prevents parallelization\n         Loop carried backward dependence of c-> prevents vectorization\n         Complex loop carried dependence of c->,b-> prevents parallelization\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8204514370299876
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068322420003824,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel.c/parallel.c0 /usa/chrismun/openacc/Tests/parallel.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:1024]) [if not already present]\n         Generating copy(c[:1024]) [if not already present]\n         Generating copyin(b[:1024]) [if not already present]\n     20, Generating Tesla code\n         22, #pragma acc loop gang /* blockIdx.x */\n         24, #pragma acc loop seq\n         26, #pragma acc loop seq\n         28, #pragma acc loop seq\n         30, #pragma acc loop seq\n         32, #pragma acc loop seq\n         34, #pragma acc loop seq\n         36, #pragma acc loop seq\n         38, #pragma acc loop seq\n         40, #pragma acc loop seq\n     24, Loop is parallelizable\n     26, Loop is parallelizable\n     28, Loop is parallelizable\n     30, Loop is parallelizable\n     32, Loop is parallelizable\n     34, Loop is parallelizable\n     36, Loop is parallelizable\n     38, Loop is parallelizable\n     40, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 3.019728011917323
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0180202370975167,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_async.c/parallel_async.c0 /usa/chrismun/openacc/Tests/parallel_async.c",
                    "config": 1,
                    "errors": "test1:\n     26, Generating copyin(a[:n],c[:n],d[:n],b[:n],e[:n],g[:n],f[:n]) [if not already present]\n     28, Generating Tesla code\n         30, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     35, Generating Tesla code\n         37, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     42, Generating Tesla code\n         44, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     47, Generating update self(c[:n],g[:n],f[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8698074140120298
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1195151469437405,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_copy.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_copy.c/parallel_copy.c0 /usa/chrismun/openacc/Tests/parallel_copy.c",
                    "config": 1,
                    "errors": "test1:\n     16, Generating copy(a[:n]) [if not already present]\n         Generating Tesla code\n         18, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     24, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7696441690204665
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0684681149432436,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_copyin.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_copyin.c/parallel_copyin.c0 /usa/chrismun/openacc/Tests/parallel_copyin.c",
                    "config": 1,
                    "errors": "test1:\n     14, Generating enter data copyin(hasDevice[:1])\n         Generating present(hasDevice[:1])\n         Generating Tesla code\n     25, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n         27, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     55, Generating copy(b[:n]) [if not already present]\n     57, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n         59, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.821789516019635
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0184148309053853,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_copyout.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_copyout.c/parallel_copyout.c0 /usa/chrismun/openacc/Tests/parallel_copyout.c",
                    "config": 1,
                    "errors": "test1:\n     17, Generating copyin(a[:n]) [if not already present]\n     19, Generating copyout(b[:n]) [if not already present]\n         Generating Tesla code\n         21, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     51, Generating enter data copyin(hasDevice[:1])\n         Generating present(hasDevice[:1])\n         Generating Tesla code\n     62, Generating copyin(a[:n],b[:n]) [if not already present]\n     64, Generating copyout(b[:n]) [if not already present]\n         Generating Tesla code\n         66, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest3:\n     98, Generating copyin(a[:n],b[:n]) [if not already present]\n    100, Generating copyout(b[:n]) [if not already present]\n         Generating Tesla code\n        102, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    107, Generating update self(b[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870938385021873
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068528119008988,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_create.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_create.c/parallel_create.c0 /usa/chrismun/openacc/Tests/parallel_create.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n]) [if not already present]\n         Generating copy(c[:n]) [if not already present]\n     20, Generating create(b[:n]) [if not already present]\n         Generating Tesla code\n         22, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820738543989137
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0185858150944114,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_default_copy.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_default_copy.c/parallel_default_copy.c0 /usa/chrismun/openacc/Tests/parallel_default_copy.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n],b[:n]) [if not already present]\n     20, Generating Tesla code\n         22, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     20, Generating implicit copy(c[:n]) [if not already present]\ntest2:\n     51, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     60, Generating enter data copyin(c[:n])\n     63, Memory zero idiom, loop replaced by call to __c_mzero8\n     67, Generating copyin(a[:n],b[:n]) [if not already present]\n     69, Generating Tesla code\n         71, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     69, Generating implicit copy(c[:n]) [if not already present]\n     81, Generating exit data copyout(c[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820002193097025
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0190277410438284,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_default_present.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_default_present.c/parallel_default_present.c0 /usa/chrismun/openacc/Tests/parallel_default_present.c",
                    "config": 1,
                    "errors": "test1:\n      9, Memory zero idiom, loop replaced by call to __c_mzero8\n     14, Generating enter data copyin(a[:n])\n         Generating Tesla code\n         16, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     14, Generating default present(a[:n])\n     19, Generating exit data copyout(a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8198654840234667
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0182490160223097,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_deviceptr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_deviceptr.c/parallel_deviceptr.c0 /usa/chrismun/openacc/Tests/parallel_deviceptr.c",
                    "config": 1,
                    "errors": "test1:\n     10, Memory zero idiom, loop replaced by call to __c_mzero8\n     15, Generating enter data copyin(a[:n])\n     21, Generating Tesla code\n         23, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     28, Generating exit data copyout(a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.770597413997166
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069101732922718,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_firstprivate.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_firstprivate.c/parallel_firstprivate.c0 /usa/chrismun/openacc/Tests/parallel_firstprivate.c",
                    "config": 1,
                    "errors": "test1:\n     23, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(d[:n*10]) [if not already present]\n         Generating copyin(b[:n*10]) [if not already present]\n     25, Generating Tesla code\n         27, #pragma acc loop gang /* blockIdx.x */\n         29, #pragma acc loop seq /* threadIdx.y */\n     25, Generating update device(c[:n])\n     29, Loop is parallelizable\ntest2:\n     64, Memory zero idiom, loop replaced by call to __c_mzero8\n     69, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(d[:n*10]) [if not already present]\n         Generating copyin(b[:n*10]) [if not already present]\n     71, Generating Tesla code\n         73, #pragma acc loop gang /* blockIdx.x */\n         75, #pragma acc loop seq /* threadIdx.y */\n         79, #pragma acc loop seq /* threadIdx.y */\n     71, Generating update device(c[:n])\n     75, Loop is parallelizable\n     79, Loop is parallelizable\n     87, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9220011750003323
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069222722086124,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_if.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_if.c/parallel_if.c0 /usa/chrismun/openacc/Tests/parallel_if.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/parallel_if.c\", line 10: warning: variable \"accel\" was declared but never referenced\n      int accel = 1;\n          ^\n\n\"/usa/chrismun/openacc/Tests/parallel_if.c\", line 55: error: identifier \"devtest\" is undefined\n      if (devtest[0] != 0){\n          ^\n\n\"/usa/chrismun/openacc/Tests/parallel_if.c\", line 45: warning: variable \"accel\" was declared but never referenced\n      int accel = 1;\n          ^\n\n\"/usa/chrismun/openacc/Tests/parallel_if.c\", line 92: warning: variable \"host\" was declared but never referenced\n      int host = 0;\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/parallel_if.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.018516594078392
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/parallel_if.c/parallel_if.c1 /usa/chrismun/openacc/Tests/parallel_if.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/parallel_if.c\", line 55: error: identifier \"devtest\" is undefined\n      if (devtest[0] != 0){\n          ^\n\n\"/usa/chrismun/openacc/Tests/parallel_if.c\", line 45: warning: variable \"accel\" was declared but never referenced\n      int accel = 1;\n          ^\n\n\"/usa/chrismun/openacc/Tests/parallel_if.c\", line 92: warning: variable \"host\" was declared but never referenced\n      int host = 0;\n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/parallel_if.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0190609430428594
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_if.c/parallel_if.c2 /usa/chrismun/openacc/Tests/parallel_if.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/parallel_if.c\", line 10: warning: variable \"accel\" was declared but never referenced\n      int accel = 1;\n          ^\n\n\"/usa/chrismun/openacc/Tests/parallel_if.c\", line 92: warning: variable \"host\" was declared but never referenced\n      int host = 0;\n          ^\n\ntest1:\n     19, Generating Tesla code\n         21, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     19, Generating implicit copyin(a[:n]) [if not already present]\n         Generating implicit copyout(c[:n]) [if not already present]\n         Generating implicit copyin(b[:n]) [if not already present]\ntest3:\n    103, Generating enter data copyin(b[:n],c[:n],a[:n])\n         Generating present(a[:n],c[:n],b[:n])\n         Generating Tesla code\n        105, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n    108, Generating exit data copyout(c[:n])\n         Generating exit data delete(b[:n],a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8709939600666985
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068620382924564,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_loop.c/parallel_loop.c0 /usa/chrismun/openacc/Tests/parallel_loop.c",
                    "config": 1,
                    "errors": "test1:\n     11, Memory zero idiom, loop replaced by call to __c_mzero8\n     16, Generating copy(a[:n]) [if not already present]\n         Generating Tesla code\n         18, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\ntest2:\n     48, Generating copy(a[:n],c[:n],b[:n]) [if not already present]\n     50, Generating Tesla code\n         52, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n         56, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8704002569429576
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0688578829867765,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_loop_async.c/parallel_loop_async.c0 /usa/chrismun/openacc/Tests/parallel_loop_async.c",
                    "config": 1,
                    "errors": "NVC++-S-1002-Reduction type not supported for this variable datatype - errors (/usa/chrismun/openacc/Tests/parallel_loop_async.c: 30)\ntest1:\n     25, Generating copyin(a[:n*10],b[:n*10],c[:n*10]) [if not already present]\n         Generating copy(errors[:10]) [if not already present]\n         Generating copyin(d[:n*10]) [if not already present]\n     26, Generating Tesla code\n         28, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     30, Generating Tesla code\n         32, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\nNVC++/x86-64 Linux 21.9-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.072760094073601
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/parallel_loop_async.c/parallel_loop_async.c1 /usa/chrismun/openacc/Tests/parallel_loop_async.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/parallel_loop_async.c\", line 51: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068916465039365
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009092416032217443,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_auto.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_loop_auto.c/parallel_loop_auto.c0 /usa/chrismun/openacc/Tests/parallel_loop_auto.c",
                    "config": 1,
                    "errors": "test1:\n     17, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(b[:n]) [if not already present]\n         Generating Tesla code\n         19, #pragma acc loop seq\n     19, Complex loop carried dependence of a-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest2:\n     49, Generating copy(a[:n]) [if not already present]\n         Generating Tesla code\n         51, #pragma acc loop seq\n     51, Loop carried dependence of a-> prevents parallelization\n         Loop carried backward dependence of a-> prevents vectorization\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8704174410086125
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068932513007894,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_gang.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_loop_gang.c/parallel_loop_gang.c0 /usa/chrismun/openacc/Tests/parallel_loop_gang.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n]) [if not already present]\n         Generating copy(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n         Generating Tesla code\n         20, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.77059036900755
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018559576012194,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_add_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general.c/parallel_loop_reduction_add_general.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n]) [if not already present]\n         Generating copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n         Generating Tesla code\n         20, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8703006899449974
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068825692986138,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_add_general_type_check_pt1.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt1.c\", line 291: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1180081019410864
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008531706989742815,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c1 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "test1:\n     28, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n         30, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n     28, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8696969990851358
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 1,
                    "runtime": 2.0194791220128536,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c2 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "test2:\n     64, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n         66, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n     64, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.821481236955151
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069133514072746,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -DT5 -DT6 -DT7 -DT8 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c3 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "test3:\n     99, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        101, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n     99, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.869942764053121
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068574376986362,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT5 -DT6 -DT7 -DT8 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c4 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "test4:\n    134, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        136, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n    134, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.819787996937521
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068866648012772,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT6 -DT7 -DT8 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c5 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "test5:\n    169, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        171, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n    169, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.871448348974809
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0197518180357292,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT7 -DT8 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c6 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "test6:\n    204, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        206, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n    204, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870339343091473
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018478551064618,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT8 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c7 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "test7:\n    239, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        241, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n    239, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8700262720230967
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068399805924855,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c8 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "test8:\n    270, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        272, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n    270, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7703935459721833
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068769506062381,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c9 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "test1:\n     28, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n         30, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n     28, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\ntest2:\n     64, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n         66, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n     64, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\ntest3:\n     99, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        101, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n     99, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\ntest4:\n    134, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        136, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n    134, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\ntest5:\n    169, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        171, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n    169, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\ntest6:\n    204, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        206, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n    204, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\ntest7:\n    239, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        241, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n    239, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\ntest8:\n    270, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        272, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n    270, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 3.321443172986619
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 2.0688794950256124,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_add_general_type_check_pt2.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt2.c\", line 288: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1186463870108128
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009306219988502562,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c1 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n         20, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n     18, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8710226450348273
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069284165976569,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c2 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "test2:\n     54, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n         56, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n     54, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8707734239287674
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069242869038135,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -DT5 -DT6 -DT7 -DT8 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c3 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "test3:\n     89, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n         91, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n     89, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8204019169788808
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0198143570451066,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT5 -DT6 -DT7 -DT8 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c4 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "test4:\n    124, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        126, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n    124, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8206168439937755
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0187375630484894,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT6 -DT7 -DT8 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c5 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "test5:\n    159, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        161, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n    159, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870405447902158
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.06915304006543,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT7 -DT8 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c6 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "test6:\n    194, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        196, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n    194, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.869601369020529
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0687123180832714,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT8 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c7 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "test7:\n    229, Generating copyin(b[:n],a[:n]) [if not already present]\n    232, Accelerator restriction: datatype not supported: total\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069454060983844
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0193577030440792,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c8 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "test8:\n    264, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        266, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n    264, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820342955063097
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0192963059525937,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c9 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n         20, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n     18, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\ntest2:\n     54, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n         56, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n     54, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\ntest3:\n     89, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n         91, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n     89, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\ntest4:\n    124, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        126, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n    124, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\ntest5:\n    159, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        161, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n    159, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\ntest6:\n    194, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        196, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n    194, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\ntest7:\n    229, Generating copyin(b[:n],a[:n]) [if not already present]\n    232, Accelerator restriction: datatype not supported: total\ntest8:\n    264, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n        266, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n    264, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 3.221611052053049
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0197994069894776,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_add_general_type_check_pt3.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_general_type_check_pt3.c/parallel_loop_reduction_add_general_type_check_pt3.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_general_type_check_pt3.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n         20, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:total)\n     18, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\ntest2:\n     57, Generating copyin(b[:n],a[:n]) [if not already present]\n     60, Accelerator restriction: datatype not supported: total\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.869493927108124
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0691636509727687,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_add_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_loop.c/parallel_loop_reduction_add_loop.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_loop.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating copyin(a[:n*10],b[:n*10]) [if not already present]\n         Generating create(c[:n*10]) [if not already present]\n         Generating copyout(d[:n*10]) [if not already present]\n         Generating Tesla code\n         22, #pragma acc loop gang /* blockIdx.x */\n         25, #pragma acc loop seq /* threadIdx.y */\n             Generating reduction(+:avg)\n         30, #pragma acc loop seq /* threadIdx.y */\n     25, Loop is parallelizable\n     30, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8703585609328
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0194656779058278,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_add_loop_type_check_pt1.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_loop_type_check_pt1.c/parallel_loop_reduction_add_loop_type_check_pt1.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_loop_type_check_pt1.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/parallel_loop_reduction_add_loop_type_check_pt1.c\", line 11: warning: variable \"total\" was declared but never referenced\n      _Bool total = 1;\n            ^\n\ntest2:\n     88, Generating copyin(a[:n*10],b[:n*10],c[:n*10]) [if not already present]\n         Generating copyout(d[:n*10]) [if not already present]\n         Generating Tesla code\n         90, #pragma acc loop gang /* blockIdx.x */\n         93, #pragma acc loop seq /* threadIdx.y */\n             Generating reduction(+:total)\n         97, #pragma acc loop seq /* threadIdx.y */\n     93, Loop is parallelizable\n     97, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870905893971212
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "0 out of 1000 failed\n",
                    "result": 1,
                    "runtime": 2.019967324915342,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_add_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_add_vector_loop.c/parallel_loop_reduction_add_vector_loop.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_add_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     17, Generating copyin(a[:n*10]) [if not already present]\n         Generating copyout(c[:10]) [if not already present]\n         Generating copyin(b[:n*10]) [if not already present]\n         Generating Tesla code\n         19, #pragma acc loop gang /* blockIdx.x */\n         22, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(+:temp)\n     22, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.871359709999524
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0189182329922915,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_and_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_and_general.c/parallel_loop_reduction_and_general.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_and_general.c",
                    "config": 1,
                    "errors": "test1:\n     23, Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(&&:result)\n     23, Generating implicit copy(result) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.821036424022168
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0192078090040013,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_and_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_and_loop.c/parallel_loop_reduction_and_loop.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_and_loop.c",
                    "config": 1,
                    "errors": "test1:\n     33, Generating copy(a[:n*10]) [if not already present]\n         Generating Tesla code\n         35, #pragma acc loop gang /* blockIdx.x */\n         38, #pragma acc loop seq /* threadIdx.y */\n             Generating reduction(&&:temp)\n         42, #pragma acc loop seq /* threadIdx.y */\n     38, Loop is parallelizable\n     42, Loop is parallelizable\n     49, Invariant if transformation\n     50, Invariant if transformation\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.869817098020576
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0192051759222522,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_and_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_and_vector_loop.c/parallel_loop_reduction_and_vector_loop.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_and_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     26, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(b[:10]) [if not already present]\n         Generating Tesla code\n         28, #pragma acc loop gang /* blockIdx.x */\n         31, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(&&:temp)\n     31, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8716541569447145
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019228819059208,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitand_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_bitand_general.c/parallel_loop_reduction_bitand_general.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_bitand_general.c",
                    "config": 1,
                    "errors": "test1:\n     31, Generating Tesla code\n         33, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(&:b)\n     31, Generating implicit copy(b) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8210250840056688
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0188366590300575,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitand_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_bitand_loop.c/parallel_loop_reduction_bitand_loop.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_bitand_loop.c",
                    "config": 1,
                    "errors": "test1:\n     27, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(c[:10],b[:n*10]) [if not already present]\n         Generating Tesla code\n         29, #pragma acc loop gang /* blockIdx.x */\n         32, #pragma acc loop seq /* threadIdx.y */\n             Generating reduction(&:temp)\n         37, #pragma acc loop seq /* threadIdx.y */\n     32, Loop is parallelizable\n     37, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870357629028149
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0688784340163693,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitand_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_bitand_vector_loop.c/parallel_loop_reduction_bitand_vector_loop.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_bitand_vector_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/parallel_loop_reduction_bitand_vector_loop.c\", line 11: warning: variable \"temp\" was declared but never referenced\n      unsigned int temp = 1;\n                   ^\n\ntest1:\n     25, Generating copyin(a[:n*10]) [if not already present]\n         Generating copyout(b[:10]) [if not already present]\n         Generating Tesla code\n         27, #pragma acc loop gang /* blockIdx.x */\n         30, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(&:c)\n     30, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8700839610537514
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0189261590130627,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitor_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_bitor_general.c/parallel_loop_reduction_bitor_general.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_bitor_general.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/parallel_loop_reduction_bitor_general.c\", line 9: warning: variable \"temp\" was declared but never referenced\n      unsigned int temp = 1;\n                   ^\n\ntest1:\n     23, Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(|:b)\n     23, Generating implicit copy(b) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870095312013291
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0194012350402772,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitor_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_bitor_loop.c/parallel_loop_reduction_bitor_loop.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_bitor_loop.c",
                    "config": 1,
                    "errors": "test1:\n     27, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(c[:10],b[:n*10]) [if not already present]\n         Generating Tesla code\n         29, #pragma acc loop gang /* blockIdx.x */\n         32, #pragma acc loop seq /* threadIdx.y */\n             Generating reduction(|:temp)\n         37, #pragma acc loop seq /* threadIdx.y */\n     32, Loop is parallelizable\n     37, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8212929780129343
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.01900094805751,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitor_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_bitor_vector_loop.c/parallel_loop_reduction_bitor_vector_loop.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_bitor_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     27, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(b[:10]) [if not already present]\n         Generating Tesla code\n         29, #pragma acc loop gang /* blockIdx.x */\n         32, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(|:temp)\n     32, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870242169010453
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069199680001475,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitxor_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_bitxor_general.c/parallel_loop_reduction_bitxor_general.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_bitxor_general.c",
                    "config": 1,
                    "errors": "test1:\n     16, Generating Tesla code\n         18, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(^:b)\n     16, Generating implicit copy(b) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8211848461069167
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019103961996734,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitxor_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_bitxor_loop.c/parallel_loop_reduction_bitxor_loop.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_bitxor_loop.c",
                    "config": 1,
                    "errors": "test1:\n     23, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(c[:10],b[:n*10]) [if not already present]\n         Generating Tesla code\n         25, #pragma acc loop gang /* blockIdx.x */\n         28, #pragma acc loop seq /* threadIdx.y */\n             Generating reduction(^:temp)\n         33, #pragma acc loop seq /* threadIdx.y */\n     28, Loop is parallelizable\n     33, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8700179759180173
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0683307860745117,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitxor_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_bitxor_vector_loop.c/parallel_loop_reduction_bitxor_vector_loop.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_bitxor_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(b[:10]) [if not already present]\n         Generating Tesla code\n         20, #pragma acc loop gang /* blockIdx.x */\n         23, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(^:temp)\n     23, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.827457994921133
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0691794799640775,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_max_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_max_general.c/parallel_loop_reduction_max_general.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_max_general.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/parallel_loop_reduction_max_general.c\", line 32: warning: use of \"=\" where \"==\" may have been intended\n      if (found = 0){\n          ^\n\n\"/usa/chrismun/openacc/Tests/parallel_loop_reduction_max_general.c\", line 10: warning: variable \"found\" was set but never used\n      int found = 0;\n          ^\n\ntest1:\n     17, Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n         19, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(max:max)\n     17, Generating implicit copy(max) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     25, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8705668420298025
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0185463200323284,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_max_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_max_loop.c/parallel_loop_reduction_max_loop.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_max_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/parallel_loop_reduction_max_loop.c\", line 12: warning: variable \"max\" was declared but never referenced\n      real_t max = 0.0;\n             ^\n\ntest1:\n     24, Generating copyin(a[:n*10],b[:n*10]) [if not already present]\n         Generating copy(c[:n*10],maximum[:10]) [if not already present]\n         Generating Tesla code\n         26, #pragma acc loop gang /* blockIdx.x */\n         29, #pragma acc loop seq /* threadIdx.y */\n             Generating reduction(max:temp)\n         34, #pragma acc loop seq /* threadIdx.y */\n     29, Loop is parallelizable\n     34, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.920383621007204
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018757621059194,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_max_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_max_vector_loop.c/parallel_loop_reduction_max_vector_loop.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_max_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(max[:10]) [if not already present]\n         Generating copyin(b[:n*10]) [if not already present]\n         Generating Tesla code\n         20, #pragma acc loop gang /* blockIdx.x */\n         23, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(max:temp)\n     23, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8699924789834768
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0185390659607947,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_min_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_min_general.c/parallel_loop_reduction_min_general.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_min_general.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n]) [if not already present]\n         Generating copy(min) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n         Generating Tesla code\n         20, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(min:min)\n     26, FMA (fused multiply-add) instruction(s) generated\n     29, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.87045022204984
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0691506570437923,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_min_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_min_loop.c/parallel_loop_reduction_min_loop.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_min_loop.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating copyin(a[:n*10],b[:n*10]) [if not already present]\n         Generating copy(c[:n*10],minimum[:10]) [if not already present]\n         Generating Tesla code\n         22, #pragma acc loop gang /* blockIdx.x */\n         25, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(min:temp)\n         30, #pragma acc loop vector(128) /* threadIdx.x */\n     25, Loop is parallelizable\n     30, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9207987440750003
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0189453129423782,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_min_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_min_vector_loop.c/parallel_loop_reduction_min_vector_loop.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_min_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(min[:10]) [if not already present]\n         Generating copyin(b[:n*10]) [if not already present]\n         Generating Tesla code\n         21, #pragma acc loop gang /* blockIdx.x */\n         24, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(min:temp)\n     24, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.87143736705184
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018866255064495,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_multiply_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_multiply_general.c/parallel_loop_reduction_multiply_general.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_multiply_general.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating copyin(a[:multiplicitive_n]) [if not already present]\n         Generating copy(multiplied_total) [if not already present]\n         Generating copyin(b[:multiplicitive_n]) [if not already present]\n         Generating Tesla code\n         21, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(*:multiplied_total)\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8207252270076424
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0716356110060588,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_multiply_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_multiply_loop.c/parallel_loop_reduction_multiply_loop.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_multiply_loop.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:m_n*10],b[:m_n*10]) [if not already present]\n         Generating copyout(c[:m_n*10],totals[:10]) [if not already present]\n         Generating Tesla code\n         24, #pragma acc loop gang /* blockIdx.x */\n         27, #pragma acc loop seq /* threadIdx.y */\n             Generating reduction(*:temp)\n         32, #pragma acc loop seq /* threadIdx.y */\n     27, Loop is parallelizable\n     32, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8705691570648924
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0186233459971845,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_multiply_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -o /usa/chrismun/openacc/build/parallel_loop_reduction_multiply_vector_loop.c/parallel_loop_reduction_multiply_vector_loop.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_multiply_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating copyin(a[:multiplicitive_n*10]) [if not already present]\n         Generating copyout(c[:10]) [if not already present]\n         Generating copyin(b[:multiplicitive_n*10]) [if not already present]\n         Generating Tesla code\n         21, #pragma acc loop gang /* blockIdx.x */\n         24, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(*:temp)\n     24, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.821025926969014
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0189661129843444,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_or_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -o /usa/chrismun/openacc/build/parallel_loop_reduction_or_general.c/parallel_loop_reduction_or_general.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_or_general.c",
                    "config": 1,
                    "errors": "test1:\n     23, Generating Tesla code\n         25, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(||:result)\n     23, Generating implicit copy(result) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.920825086068362
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0685345220845193,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_or_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_loop_reduction_or_loop.c/parallel_loop_reduction_or_loop.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_or_loop.c",
                    "config": 1,
                    "errors": "test1:\n     24, Generating Tesla code\n         26, #pragma acc loop gang /* blockIdx.x */\n         29, #pragma acc loop seq /* threadIdx.y */\n             Generating reduction(||:temp)\n         34, #pragma acc loop seq /* threadIdx.y */\n     24, Generating copy(a[:n*10]) [if not already present]\n         Generating implicit copy(results[:10]) [if not already present]\n     29, Loop is parallelizable\n     34, Loop is parallelizable\n     46, Invariant if transformation\n     54, Invariant if transformation\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8715117699466646
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069574777968228,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_or_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_loop_reduction_or_vector_loop.c/parallel_loop_reduction_or_vector_loop.c0 /usa/chrismun/openacc/Tests/parallel_loop_reduction_or_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(b[:10]) [if not already present]\n         Generating Tesla code\n         24, #pragma acc loop gang /* blockIdx.x */\n         27, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(||:temp)\n     27, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8205239080125466
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0693296439712867,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_seq.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_loop_seq.c/parallel_loop_seq.c0 /usa/chrismun/openacc/Tests/parallel_loop_seq.c",
                    "config": 1,
                    "errors": "test1:\n     17, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n         Generating Tesla code\n         19, #pragma acc loop seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8211154269520193
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0690978650236502,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_tile.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_loop_tile.c/parallel_loop_tile.c0 /usa/chrismun/openacc/Tests/parallel_loop_tile.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/parallel_loop_tile.c\", line 58: warning: variable \"temp\" was declared but never referenced\n      real_t temp = 0.0;\n             ^\n\ntest1:\n     20, Generating copy(a[:n],b[:n],c[:n]) [if not already present]\n         Generating Tesla code\n         22, #pragma acc loop gang, vector tile(32,4) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:temp)\n         23,   /* blockIdx.x threadIdx.x tiled */\n         25, #pragma acc loop seq\n     20, Generating implicit copy(temp) [if not already present]\n         Generating copy(d2[:n*n]) [if not already present]\n     25, Loop is parallelizable\n     33, Zero trip check eliminated\n     35, Zero trip check eliminated\ntest2:\n     67, Generating copyin(a[:n],b[:n],c[:n]) [if not already present]\n         Generating copyout(d3[:n*(n*n)]) [if not already present]\n         Generating Tesla code\n         69, #pragma acc loop gang, vector tile(2,4,8) /* blockIdx.x threadIdx.x */\n         70,   /* blockIdx.x threadIdx.x tiled */\n         71,   /* blockIdx.x threadIdx.x tiled */\n     79, Zero trip check eliminated\n     80, Zero trip check eliminated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9212944509927183
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069044033996761,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_vector.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_loop_vector.c/parallel_loop_vector.c0 /usa/chrismun/openacc/Tests/parallel_loop_vector.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n]) [if not already present]\n         Generating copy(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n         Generating Tesla code\n         20, #pragma acc loop vector(128) /* threadIdx.x */\n     20, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8716794840293005
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0686965869972482,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_vector_blocking.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_loop_vector_blocking.c/parallel_loop_vector_blocking.c0 /usa/chrismun/openacc/Tests/parallel_loop_vector_blocking.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/parallel_loop_vector_blocking.c\", line 36: warning: expression has no effect\n        err + 1;\n        ^\n\ntest1:\n     19, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     21, Generating Tesla code\n         23, #pragma acc loop vector(128) /* threadIdx.x */\n         28, #pragma acc loop vector(128) /* threadIdx.x */\n     23, Loop is parallelizable\n     28, Loop is parallelizable\n     35, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8708164941053838
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0185228449990973,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_worker.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_loop_worker.c/parallel_loop_worker.c0 /usa/chrismun/openacc/Tests/parallel_loop_worker.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n]) [if not already present]\n         Generating copy(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n         Generating Tesla code\n         20, #pragma acc loop seq /* threadIdx.y */\n     20, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.821170900017023
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069584173965268,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_worker_blocking.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_loop_worker_blocking.c/parallel_loop_worker_blocking.c0 /usa/chrismun/openacc/Tests/parallel_loop_worker_blocking.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/parallel_loop_worker_blocking.c\", line 36: warning: expression has no effect\n          err + 1;\n          ^\n\ntest1:\n     19, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     21, Generating Tesla code\n         23, #pragma acc loop seq /* threadIdx.y */\n         28, #pragma acc loop seq /* threadIdx.y */\n     23, Loop is parallelizable\n     28, Loop is parallelizable\n     35, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.819538615993224
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019087231019512,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_present.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_present.c/parallel_present.c0 /usa/chrismun/openacc/Tests/parallel_present.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating enter data copyin(b[:n],a[:n])\n         Generating present(a[:n],b[:n])\n         Generating copy(c[:n]) [if not already present]\n         Generating Tesla code\n         21, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     24, Generating exit data delete(b[:n],a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8705444099614397
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069335905951448,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_private.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_private.c/parallel_private.c0 /usa/chrismun/openacc/Tests/parallel_private.c",
                    "config": 1,
                    "errors": "test1:\n     23, Generating enter data copyin(d[:10],b[:n*10],a[:n*10])\n         Generating Tesla code\n         25, #pragma acc loop gang(10) /* blockIdx.x */\n         27, #pragma acc loop seq /* threadIdx.y */\n         31, #pragma acc loop seq\n     23, Generating implicit copy(d[:10]) [if not already present]\n     25, Accelerator restriction: size of the GPU copy of b,a is unknown\n     27, Loop is parallelizable\n     38, Generating exit data delete(a[:n*10])\n         Generating exit data copyout(d[:10])\n         Generating exit data delete(b[:n*10])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870260512921959
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068874555057846,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_reduction.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_reduction.c/parallel_reduction.c0 /usa/chrismun/openacc/Tests/parallel_reduction.c",
                    "config": 1,
                    "errors": "test1:\n     15, Generating Tesla code\n         17, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n             Generating reduction(+:reduction)\n     15, Generating implicit copy(reduction) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.87016837997362
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0691540520638227,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_scalar_default_firstprivate.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_scalar_default_firstprivate.c/parallel_scalar_default_firstprivate.c0 /usa/chrismun/openacc/Tests/parallel_scalar_default_firstprivate.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyout(b[:n]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     20, Generating Tesla code\n         22, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.82001039898023
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019037447986193,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_switch.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_switch.c/parallel_switch.c0 /usa/chrismun/openacc/Tests/parallel_switch.c",
                    "config": 1,
                    "errors": "test1:\n     21, Generating enter data copyin(b[:n],c[:n],a[:n])\n         Generating present(a[:n],c[:n],b[:n])\n         Generating Tesla code\n         23, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     39, Generating exit data copyout(c[:n])\n         Generating exit data delete(b[:n],a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.819781734026037
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0189946989994496,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_wait.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_wait.c/parallel_wait.c0 /usa/chrismun/openacc/Tests/parallel_wait.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating enter data create(a[:n])\n         Generating update device(a[:n])\n         Generating present(a[:n])\n         Generating Tesla code\n         20, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     23, Generating exit data copyout(a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7698164869798347
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0696175169432536,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_while_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/parallel_while_loop.c/parallel_while_loop.c0 /usa/chrismun/openacc/Tests/parallel_while_loop.c",
                    "config": 1,
                    "errors": "test1:\n     16, Generating copy(a[:n*10]) [if not already present]\n     18, Generating Tesla code\n         21, #pragma acc loop gang /* blockIdx.x */\n         23, #pragma acc loop seq\n         26, #pragma acc loop vector(128) /* threadIdx.x */\n             Generating reduction(+:avg)\n     23, Loop carried dependence of a-> prevents parallelization\n         Loop carried backward dependence of a-> prevents vectorization\n     26, Loop is parallelizable\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820879750070162
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0195485739968717,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "routine_bind.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/routine_bind.c/routine_bind.c0 /usa/chrismun/openacc/Tests/routine_bind.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/routine_bind.c\", line 250: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\nhost_function_identifier_unnamed:\n      9, Generating Tesla code\n         11, #pragma acc loop vector /* threadIdx.x */\n             Generating implicit reduction(+:returned)\n             Vector barrier inserted for vector loop reduction\n     11, Loop is parallelizable\nhost_function_identifier_named:\n     44, Generating Tesla code\n         46, #pragma acc loop vector /* threadIdx.x */\n             Generating implicit reduction(+:returned)\n             Vector barrier inserted for vector loop reduction\n     46, Loop is parallelizable\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.821189776994288
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008476312970742583,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/routine_bind.c/routine_bind.c1 /usa/chrismun/openacc/Tests/routine_bind.c",
                    "config": 1,
                    "errors": "host_function_identifier_unnamed:\n      9, Generating Tesla code\n         11, #pragma acc loop vector /* threadIdx.x */\n             Generating implicit reduction(+:returned)\n             Vector barrier inserted for vector loop reduction\n     11, Loop is parallelizable\nhost_function_identifier_named:\n     44, Generating Tesla code\n         46, #pragma acc loop vector /* threadIdx.x */\n             Generating implicit reduction(+:returned)\n             Vector barrier inserted for vector loop reduction\n     46, Loop is parallelizable\ntest1:\n     98, Generating copyout(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    100, Generating Tesla code\n        102, #pragma acc loop gang, worker(4) /* blockIdx.x threadIdx.y */\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8702432720456272
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 1,
                    "runtime": 2.068905030959286,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT3 -DT4 -o /usa/chrismun/openacc/build/routine_bind.c/routine_bind.c2 /usa/chrismun/openacc/Tests/routine_bind.c",
                    "config": 1,
                    "errors": "host_function_identifier_unnamed:\n      9, Generating Tesla code\n         11, #pragma acc loop vector /* threadIdx.x */\n             Generating implicit reduction(+:returned)\n             Vector barrier inserted for vector loop reduction\n     11, Loop is parallelizable\nhost_function_identifier_named:\n     44, Generating Tesla code\n         46, #pragma acc loop vector /* threadIdx.x */\n             Generating implicit reduction(+:returned)\n             Vector barrier inserted for vector loop reduction\n     46, Loop is parallelizable\ntest2:\n    141, Generating copyout(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    143, Generating Tesla code\n        145, #pragma acc loop gang, worker(4) /* blockIdx.x threadIdx.y */\nnvvmCompileProgram error 9: NVVM_ERROR_COMPILATION.\nError: /tmp/pgaccYFGRbwUQJblGq.gpu (751, 24): parse use of undefined value '@device_function_string_unnamed'\nptxas /tmp/pgaccsFGRb2PeBH9TU.ptx, line 1; fatal   : Missing .version directive at start of file '/tmp/pgaccsFGRb2PeBH9TU.ptx'\nptxas fatal   : Ptx assembly aborted due to errors\nNVC++-F-0155-Compiler failed to translate accelerator region (see -Minfo messages): Device compiler exited with error status code (/usa/chrismun/openacc/Tests/routine_bind.c: 1)\nNVC++/x86-64 Linux 21.9-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0685846880078316
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -o /usa/chrismun/openacc/build/routine_bind.c/routine_bind.c3 /usa/chrismun/openacc/Tests/routine_bind.c",
                    "config": 1,
                    "errors": "host_function_identifier_unnamed:\n      9, Generating Tesla code\n         11, #pragma acc loop vector /* threadIdx.x */\n             Generating implicit reduction(+:returned)\n             Vector barrier inserted for vector loop reduction\n     11, Loop is parallelizable\nhost_function_identifier_named:\n     44, Generating Tesla code\n         46, #pragma acc loop vector /* threadIdx.x */\n             Generating implicit reduction(+:returned)\n             Vector barrier inserted for vector loop reduction\n     46, Loop is parallelizable\ntest3:\n    183, Generating copyout(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    185, Generating Tesla code\n        187, #pragma acc loop gang, worker(4) /* blockIdx.x threadIdx.y */\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.922086247941479
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 4,
                    "runtime": 2.068807717994787,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -o /usa/chrismun/openacc/build/routine_bind.c/routine_bind.c4 /usa/chrismun/openacc/Tests/routine_bind.c",
                    "config": 1,
                    "errors": "host_function_identifier_unnamed:\n      9, Generating Tesla code\n         11, #pragma acc loop vector /* threadIdx.x */\n             Generating implicit reduction(+:returned)\n             Vector barrier inserted for vector loop reduction\n     11, Loop is parallelizable\nhost_function_identifier_named:\n     44, Generating Tesla code\n         46, #pragma acc loop vector /* threadIdx.x */\n             Generating implicit reduction(+:returned)\n             Vector barrier inserted for vector loop reduction\n     46, Loop is parallelizable\ntest4:\n    225, Generating copyout(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    227, Generating Tesla code\n        229, #pragma acc loop gang, worker(4) /* blockIdx.x threadIdx.y */\nnvvmCompileProgram error 9: NVVM_ERROR_COMPILATION.\nError: /tmp/pgacc6THRbUYhfjy36.gpu (751, 24): parse use of undefined value '@device_function_string_named'\nptxas /tmp/pgaccATHRbom34PKfU.ptx, line 1; fatal   : Missing .version directive at start of file '/tmp/pgaccATHRbom34PKfU.ptx'\nptxas fatal   : Ptx assembly aborted due to errors\nNVC++-F-0155-Compiler failed to translate accelerator region (see -Minfo messages): Device compiler exited with error status code (/usa/chrismun/openacc/Tests/routine_bind.c: 1)\nNVC++/x86-64 Linux 21.9-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.068521016044542
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT4 -o /usa/chrismun/openacc/build/routine_bind.c/routine_bind.c5 /usa/chrismun/openacc/Tests/routine_bind.c",
                    "config": 1,
                    "errors": "host_function_identifier_unnamed:\n      9, Generating Tesla code\n         11, #pragma acc loop vector /* threadIdx.x */\n             Generating implicit reduction(+:returned)\n             Vector barrier inserted for vector loop reduction\n     11, Loop is parallelizable\nhost_function_identifier_named:\n     44, Generating Tesla code\n         46, #pragma acc loop vector /* threadIdx.x */\n             Generating implicit reduction(+:returned)\n             Vector barrier inserted for vector loop reduction\n     46, Loop is parallelizable\ntest1:\n     98, Generating copyout(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    100, Generating Tesla code\n        102, #pragma acc loop gang, worker(4) /* blockIdx.x threadIdx.y */\ntest3:\n    183, Generating copyout(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    185, Generating Tesla code\n        187, #pragma acc loop gang, worker(4) /* blockIdx.x threadIdx.y */\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.970443687052466
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 5,
                    "runtime": 2.0196647840784863,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "routine_gang.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -DT9 -DT10 -o /usa/chrismun/openacc/build/routine_gang.c/routine_gang.c0 /usa/chrismun/openacc/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/routine_gang.c\", line 502: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\ncalled_function_worker:\n     16, Generating Tesla code\n         19, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     19, Loop is parallelizable\ncalled_function_vector:\n     26, Generating Tesla code\n         29, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         30, Vector barrier inserted for vector loop reduction\n     29, Loop is parallelizable\ncalled_function_seq:\n     36, Generating acc routine seq\n         Generating Tesla code\ncalled_function_gang:\n     46, Generating Tesla code\n         51, #pragma acc loop gang /* blockIdx.x */\n         54, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:privatized_return)\n         60, #pragma acc loop seq\n     54, Loop is parallelizable\ntest_routine_gang_loop_unnamed:\n     68, Generating Tesla code\n         71, #pragma acc loop gang /* blockIdx.x */\n         74, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n     74, Loop is parallelizable\ntest_routine_gang_gang_unnamed:\n     82, Generating Tesla code\n         83, #pragma acc loop seq\n     83, Loop is parallelizable\ntest_routine_gang_worker_unnamed:\n     89, Generating Tesla code\n         90, #pragma acc loop gang /* blockIdx.x */\n     90, Loop is parallelizable\ntest_routine_gang_vector_unnamed:\n     96, Generating Tesla code\n         97, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n     97, Loop is parallelizable\ntest_routine_gang_seq_unnamed:\n    103, Generating Tesla code\n        104, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    104, Loop is parallelizable\ntest_routine_gang_loop_named:\n    109, Generating Tesla code\n        112, #pragma acc loop gang /* blockIdx.x */\n        115, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n    115, Loop is parallelizable\ntest_routine_gang_gang_named:\n    122, Generating Tesla code\n        123, #pragma acc loop seq\n    123, Loop is parallelizable\ntest_routine_gang_worker_named:\n    128, Generating Tesla code\n        129, #pragma acc loop gang /* blockIdx.x */\n    129, Loop is parallelizable\ntest_routine_gang_vector_named:\n    134, Generating Tesla code\n        135, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n    135, Loop is parallelizable\ntest_routine_gang_seq_named:\n    140, Generating Tesla code\n        141, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    141, Loop is parallelizable\nvalidate_data:\n    150, Zero trip check eliminated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.170513606048189
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01714022899977863,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -DT9 -DT10 -o /usa/chrismun/openacc/build/routine_gang.c/routine_gang.c1 /usa/chrismun/openacc/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/routine_gang.c\", line 175: error: identifier \"x\" is undefined\n          b[x] = 0;\n            ^\n\n\"/usa/chrismun/openacc/Tests/routine_gang.c\", line 176: warning: missing return statement at end of non-void function \"test1\"\n      }\n      ^\n\n\"/usa/chrismun/openacc/Tests/routine_gang.c\", line 163: warning: variable \"err\" was declared but never referenced\n      int err = 0;\n          ^\n\n\"/usa/chrismun/openacc/Tests/routine_gang.c\", line 179: error: expected a declaration\n      {\n      ^\n\n\"/usa/chrismun/openacc/Tests/routine_gang.c\", line 186: error: expected a declaration\n      if (validate_data(a, b)){\n      ^\n\n\"/usa/chrismun/openacc/Tests/routine_gang.c\", line 190: warning: parsing restarts here after previous syntax error\n      return err;\n                ^\n\n\"/usa/chrismun/openacc/Tests/routine_gang.c\", line 191: error: expected a declaration\n  }\n  ^\n\n\"/usa/chrismun/openacc/Tests/routine_gang.c\", line 593: warning: parsing restarts here after previous syntax error\n      return failcode;\n                     ^\n\n\"/usa/chrismun/openacc/Tests/routine_gang.c\", line 594: error: expected a declaration\n  }\n  ^\n\n5 errors detected in the compilation of \"/usa/chrismun/openacc/Tests/routine_gang.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9692285750061274
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -DT9 -DT10 -o /usa/chrismun/openacc/build/routine_gang.c/routine_gang.c2 /usa/chrismun/openacc/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "called_function_worker:\n     16, Generating Tesla code\n         19, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     19, Loop is parallelizable\ncalled_function_vector:\n     26, Generating Tesla code\n         29, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         30, Vector barrier inserted for vector loop reduction\n     29, Loop is parallelizable\ncalled_function_seq:\n     36, Generating acc routine seq\n         Generating Tesla code\ncalled_function_gang:\n     46, Generating Tesla code\n         51, #pragma acc loop gang /* blockIdx.x */\n         54, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:privatized_return)\n         60, #pragma acc loop seq\n     54, Loop is parallelizable\ntest_routine_gang_loop_unnamed:\n     68, Generating Tesla code\n         71, #pragma acc loop gang /* blockIdx.x */\n         74, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n     74, Loop is parallelizable\ntest_routine_gang_gang_unnamed:\n     82, Generating Tesla code\n         83, #pragma acc loop seq\n     83, Loop is parallelizable\ntest_routine_gang_worker_unnamed:\n     89, Generating Tesla code\n         90, #pragma acc loop gang /* blockIdx.x */\n     90, Loop is parallelizable\ntest_routine_gang_vector_unnamed:\n     96, Generating Tesla code\n         97, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n     97, Loop is parallelizable\ntest_routine_gang_seq_unnamed:\n    103, Generating Tesla code\n        104, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    104, Loop is parallelizable\ntest_routine_gang_loop_named:\n    109, Generating Tesla code\n        112, #pragma acc loop gang /* blockIdx.x */\n        115, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n    115, Loop is parallelizable\ntest_routine_gang_gang_named:\n    122, Generating Tesla code\n        123, #pragma acc loop seq\n    123, Loop is parallelizable\ntest_routine_gang_worker_named:\n    128, Generating Tesla code\n        129, #pragma acc loop gang /* blockIdx.x */\n    129, Loop is parallelizable\ntest_routine_gang_vector_named:\n    134, Generating Tesla code\n        135, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n    135, Loop is parallelizable\ntest_routine_gang_seq_named:\n    140, Generating Tesla code\n        141, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    141, Loop is parallelizable\nvalidate_data:\n    150, Zero trip check eliminated\ntest2:\n    213, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    215, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.320959849981591
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0689911340596154,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -DT5 -DT6 -DT7 -DT8 -DT9 -DT10 -o /usa/chrismun/openacc/build/routine_gang.c/routine_gang.c3 /usa/chrismun/openacc/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "called_function_worker:\n     16, Generating Tesla code\n         19, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     19, Loop is parallelizable\ncalled_function_vector:\n     26, Generating Tesla code\n         29, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         30, Vector barrier inserted for vector loop reduction\n     29, Loop is parallelizable\ncalled_function_seq:\n     36, Generating acc routine seq\n         Generating Tesla code\ncalled_function_gang:\n     46, Generating Tesla code\n         51, #pragma acc loop gang /* blockIdx.x */\n         54, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:privatized_return)\n         60, #pragma acc loop seq\n     54, Loop is parallelizable\ntest_routine_gang_loop_unnamed:\n     68, Generating Tesla code\n         71, #pragma acc loop gang /* blockIdx.x */\n         74, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n     74, Loop is parallelizable\ntest_routine_gang_gang_unnamed:\n     82, Generating Tesla code\n         83, #pragma acc loop seq\n     83, Loop is parallelizable\ntest_routine_gang_worker_unnamed:\n     89, Generating Tesla code\n         90, #pragma acc loop gang /* blockIdx.x */\n     90, Loop is parallelizable\ntest_routine_gang_vector_unnamed:\n     96, Generating Tesla code\n         97, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n     97, Loop is parallelizable\ntest_routine_gang_seq_unnamed:\n    103, Generating Tesla code\n        104, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    104, Loop is parallelizable\ntest_routine_gang_loop_named:\n    109, Generating Tesla code\n        112, #pragma acc loop gang /* blockIdx.x */\n        115, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n    115, Loop is parallelizable\ntest_routine_gang_gang_named:\n    122, Generating Tesla code\n        123, #pragma acc loop seq\n    123, Loop is parallelizable\ntest_routine_gang_worker_named:\n    128, Generating Tesla code\n        129, #pragma acc loop gang /* blockIdx.x */\n    129, Loop is parallelizable\ntest_routine_gang_vector_named:\n    134, Generating Tesla code\n        135, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n    135, Loop is parallelizable\ntest_routine_gang_seq_named:\n    140, Generating Tesla code\n        141, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    141, Loop is parallelizable\nvalidate_data:\n    150, Zero trip check eliminated\ntest3:\n    247, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    249, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.2704119420377538
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 4,
                    "runtime": 2.019317295984365,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT5 -DT6 -DT7 -DT8 -DT9 -DT10 -o /usa/chrismun/openacc/build/routine_gang.c/routine_gang.c4 /usa/chrismun/openacc/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "called_function_worker:\n     16, Generating Tesla code\n         19, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     19, Loop is parallelizable\ncalled_function_vector:\n     26, Generating Tesla code\n         29, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         30, Vector barrier inserted for vector loop reduction\n     29, Loop is parallelizable\ncalled_function_seq:\n     36, Generating acc routine seq\n         Generating Tesla code\ncalled_function_gang:\n     46, Generating Tesla code\n         51, #pragma acc loop gang /* blockIdx.x */\n         54, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:privatized_return)\n         60, #pragma acc loop seq\n     54, Loop is parallelizable\ntest_routine_gang_loop_unnamed:\n     68, Generating Tesla code\n         71, #pragma acc loop gang /* blockIdx.x */\n         74, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n     74, Loop is parallelizable\ntest_routine_gang_gang_unnamed:\n     82, Generating Tesla code\n         83, #pragma acc loop seq\n     83, Loop is parallelizable\ntest_routine_gang_worker_unnamed:\n     89, Generating Tesla code\n         90, #pragma acc loop gang /* blockIdx.x */\n     90, Loop is parallelizable\ntest_routine_gang_vector_unnamed:\n     96, Generating Tesla code\n         97, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n     97, Loop is parallelizable\ntest_routine_gang_seq_unnamed:\n    103, Generating Tesla code\n        104, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    104, Loop is parallelizable\ntest_routine_gang_loop_named:\n    109, Generating Tesla code\n        112, #pragma acc loop gang /* blockIdx.x */\n        115, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n    115, Loop is parallelizable\ntest_routine_gang_gang_named:\n    122, Generating Tesla code\n        123, #pragma acc loop seq\n    123, Loop is parallelizable\ntest_routine_gang_worker_named:\n    128, Generating Tesla code\n        129, #pragma acc loop gang /* blockIdx.x */\n    129, Loop is parallelizable\ntest_routine_gang_vector_named:\n    134, Generating Tesla code\n        135, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n    135, Loop is parallelizable\ntest_routine_gang_seq_named:\n    140, Generating Tesla code\n        141, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    141, Loop is parallelizable\nvalidate_data:\n    150, Zero trip check eliminated\ntest4:\n    281, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    283, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.271666590939276
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 8,
                    "runtime": 2.019286527996883,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT6 -DT7 -DT8 -DT9 -DT10 -o /usa/chrismun/openacc/build/routine_gang.c/routine_gang.c5 /usa/chrismun/openacc/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "called_function_worker:\n     16, Generating Tesla code\n         19, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     19, Loop is parallelizable\ncalled_function_vector:\n     26, Generating Tesla code\n         29, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         30, Vector barrier inserted for vector loop reduction\n     29, Loop is parallelizable\ncalled_function_seq:\n     36, Generating acc routine seq\n         Generating Tesla code\ncalled_function_gang:\n     46, Generating Tesla code\n         51, #pragma acc loop gang /* blockIdx.x */\n         54, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:privatized_return)\n         60, #pragma acc loop seq\n     54, Loop is parallelizable\ntest_routine_gang_loop_unnamed:\n     68, Generating Tesla code\n         71, #pragma acc loop gang /* blockIdx.x */\n         74, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n     74, Loop is parallelizable\ntest_routine_gang_gang_unnamed:\n     82, Generating Tesla code\n         83, #pragma acc loop seq\n     83, Loop is parallelizable\ntest_routine_gang_worker_unnamed:\n     89, Generating Tesla code\n         90, #pragma acc loop gang /* blockIdx.x */\n     90, Loop is parallelizable\ntest_routine_gang_vector_unnamed:\n     96, Generating Tesla code\n         97, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n     97, Loop is parallelizable\ntest_routine_gang_seq_unnamed:\n    103, Generating Tesla code\n        104, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    104, Loop is parallelizable\ntest_routine_gang_loop_named:\n    109, Generating Tesla code\n        112, #pragma acc loop gang /* blockIdx.x */\n        115, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n    115, Loop is parallelizable\ntest_routine_gang_gang_named:\n    122, Generating Tesla code\n        123, #pragma acc loop seq\n    123, Loop is parallelizable\ntest_routine_gang_worker_named:\n    128, Generating Tesla code\n        129, #pragma acc loop gang /* blockIdx.x */\n    129, Loop is parallelizable\ntest_routine_gang_vector_named:\n    134, Generating Tesla code\n        135, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n    135, Loop is parallelizable\ntest_routine_gang_seq_named:\n    140, Generating Tesla code\n        141, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    141, Loop is parallelizable\nvalidate_data:\n    150, Zero trip check eliminated\ntest5:\n    315, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    317, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.2219253779621795
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.01867844897788,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT7 -DT8 -DT9 -DT10 -o /usa/chrismun/openacc/build/routine_gang.c/routine_gang.c6 /usa/chrismun/openacc/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "called_function_worker:\n     16, Generating Tesla code\n         19, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     19, Loop is parallelizable\ncalled_function_vector:\n     26, Generating Tesla code\n         29, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         30, Vector barrier inserted for vector loop reduction\n     29, Loop is parallelizable\ncalled_function_seq:\n     36, Generating acc routine seq\n         Generating Tesla code\ncalled_function_gang:\n     46, Generating Tesla code\n         51, #pragma acc loop gang /* blockIdx.x */\n         54, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:privatized_return)\n         60, #pragma acc loop seq\n     54, Loop is parallelizable\ntest_routine_gang_loop_unnamed:\n     68, Generating Tesla code\n         71, #pragma acc loop gang /* blockIdx.x */\n         74, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n     74, Loop is parallelizable\ntest_routine_gang_gang_unnamed:\n     82, Generating Tesla code\n         83, #pragma acc loop seq\n     83, Loop is parallelizable\ntest_routine_gang_worker_unnamed:\n     89, Generating Tesla code\n         90, #pragma acc loop gang /* blockIdx.x */\n     90, Loop is parallelizable\ntest_routine_gang_vector_unnamed:\n     96, Generating Tesla code\n         97, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n     97, Loop is parallelizable\ntest_routine_gang_seq_unnamed:\n    103, Generating Tesla code\n        104, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    104, Loop is parallelizable\ntest_routine_gang_loop_named:\n    109, Generating Tesla code\n        112, #pragma acc loop gang /* blockIdx.x */\n        115, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n    115, Loop is parallelizable\ntest_routine_gang_gang_named:\n    122, Generating Tesla code\n        123, #pragma acc loop seq\n    123, Loop is parallelizable\ntest_routine_gang_worker_named:\n    128, Generating Tesla code\n        129, #pragma acc loop gang /* blockIdx.x */\n    129, Loop is parallelizable\ntest_routine_gang_vector_named:\n    134, Generating Tesla code\n        135, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n    135, Loop is parallelizable\ntest_routine_gang_seq_named:\n    140, Generating Tesla code\n        141, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    141, Loop is parallelizable\nvalidate_data:\n    150, Zero trip check eliminated\ntest6:\n    349, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    351, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.2715290709165856
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0189184539485723,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT8 -DT9 -DT10 -o /usa/chrismun/openacc/build/routine_gang.c/routine_gang.c7 /usa/chrismun/openacc/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "called_function_worker:\n     16, Generating Tesla code\n         19, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     19, Loop is parallelizable\ncalled_function_vector:\n     26, Generating Tesla code\n         29, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         30, Vector barrier inserted for vector loop reduction\n     29, Loop is parallelizable\ncalled_function_seq:\n     36, Generating acc routine seq\n         Generating Tesla code\ncalled_function_gang:\n     46, Generating Tesla code\n         51, #pragma acc loop gang /* blockIdx.x */\n         54, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:privatized_return)\n         60, #pragma acc loop seq\n     54, Loop is parallelizable\ntest_routine_gang_loop_unnamed:\n     68, Generating Tesla code\n         71, #pragma acc loop gang /* blockIdx.x */\n         74, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n     74, Loop is parallelizable\ntest_routine_gang_gang_unnamed:\n     82, Generating Tesla code\n         83, #pragma acc loop seq\n     83, Loop is parallelizable\ntest_routine_gang_worker_unnamed:\n     89, Generating Tesla code\n         90, #pragma acc loop gang /* blockIdx.x */\n     90, Loop is parallelizable\ntest_routine_gang_vector_unnamed:\n     96, Generating Tesla code\n         97, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n     97, Loop is parallelizable\ntest_routine_gang_seq_unnamed:\n    103, Generating Tesla code\n        104, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    104, Loop is parallelizable\ntest_routine_gang_loop_named:\n    109, Generating Tesla code\n        112, #pragma acc loop gang /* blockIdx.x */\n        115, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n    115, Loop is parallelizable\ntest_routine_gang_gang_named:\n    122, Generating Tesla code\n        123, #pragma acc loop seq\n    123, Loop is parallelizable\ntest_routine_gang_worker_named:\n    128, Generating Tesla code\n        129, #pragma acc loop gang /* blockIdx.x */\n    129, Loop is parallelizable\ntest_routine_gang_vector_named:\n    134, Generating Tesla code\n        135, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n    135, Loop is parallelizable\ntest_routine_gang_seq_named:\n    140, Generating Tesla code\n        141, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    141, Loop is parallelizable\nvalidate_data:\n    150, Zero trip check eliminated\ntest7:\n    383, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    385, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.2202224420616403
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0691562140127644,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT9 -DT10 -o /usa/chrismun/openacc/build/routine_gang.c/routine_gang.c8 /usa/chrismun/openacc/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "called_function_worker:\n     16, Generating Tesla code\n         19, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     19, Loop is parallelizable\ncalled_function_vector:\n     26, Generating Tesla code\n         29, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         30, Vector barrier inserted for vector loop reduction\n     29, Loop is parallelizable\ncalled_function_seq:\n     36, Generating acc routine seq\n         Generating Tesla code\ncalled_function_gang:\n     46, Generating Tesla code\n         51, #pragma acc loop gang /* blockIdx.x */\n         54, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:privatized_return)\n         60, #pragma acc loop seq\n     54, Loop is parallelizable\ntest_routine_gang_loop_unnamed:\n     68, Generating Tesla code\n         71, #pragma acc loop gang /* blockIdx.x */\n         74, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n     74, Loop is parallelizable\ntest_routine_gang_gang_unnamed:\n     82, Generating Tesla code\n         83, #pragma acc loop seq\n     83, Loop is parallelizable\ntest_routine_gang_worker_unnamed:\n     89, Generating Tesla code\n         90, #pragma acc loop gang /* blockIdx.x */\n     90, Loop is parallelizable\ntest_routine_gang_vector_unnamed:\n     96, Generating Tesla code\n         97, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n     97, Loop is parallelizable\ntest_routine_gang_seq_unnamed:\n    103, Generating Tesla code\n        104, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    104, Loop is parallelizable\ntest_routine_gang_loop_named:\n    109, Generating Tesla code\n        112, #pragma acc loop gang /* blockIdx.x */\n        115, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n    115, Loop is parallelizable\ntest_routine_gang_gang_named:\n    122, Generating Tesla code\n        123, #pragma acc loop seq\n    123, Loop is parallelizable\ntest_routine_gang_worker_named:\n    128, Generating Tesla code\n        129, #pragma acc loop gang /* blockIdx.x */\n    129, Loop is parallelizable\ntest_routine_gang_vector_named:\n    134, Generating Tesla code\n        135, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n    135, Loop is parallelizable\ntest_routine_gang_seq_named:\n    140, Generating Tesla code\n        141, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    141, Loop is parallelizable\nvalidate_data:\n    150, Zero trip check eliminated\ntest8:\n    417, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    419, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.2705188440158963
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0187770259799436,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -DT10 -o /usa/chrismun/openacc/build/routine_gang.c/routine_gang.c9 /usa/chrismun/openacc/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "called_function_worker:\n     16, Generating Tesla code\n         19, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     19, Loop is parallelizable\ncalled_function_vector:\n     26, Generating Tesla code\n         29, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         30, Vector barrier inserted for vector loop reduction\n     29, Loop is parallelizable\ncalled_function_seq:\n     36, Generating acc routine seq\n         Generating Tesla code\ncalled_function_gang:\n     46, Generating Tesla code\n         51, #pragma acc loop gang /* blockIdx.x */\n         54, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:privatized_return)\n         60, #pragma acc loop seq\n     54, Loop is parallelizable\ntest_routine_gang_loop_unnamed:\n     68, Generating Tesla code\n         71, #pragma acc loop gang /* blockIdx.x */\n         74, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n     74, Loop is parallelizable\ntest_routine_gang_gang_unnamed:\n     82, Generating Tesla code\n         83, #pragma acc loop seq\n     83, Loop is parallelizable\ntest_routine_gang_worker_unnamed:\n     89, Generating Tesla code\n         90, #pragma acc loop gang /* blockIdx.x */\n     90, Loop is parallelizable\ntest_routine_gang_vector_unnamed:\n     96, Generating Tesla code\n         97, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n     97, Loop is parallelizable\ntest_routine_gang_seq_unnamed:\n    103, Generating Tesla code\n        104, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    104, Loop is parallelizable\ntest_routine_gang_loop_named:\n    109, Generating Tesla code\n        112, #pragma acc loop gang /* blockIdx.x */\n        115, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n    115, Loop is parallelizable\ntest_routine_gang_gang_named:\n    122, Generating Tesla code\n        123, #pragma acc loop seq\n    123, Loop is parallelizable\ntest_routine_gang_worker_named:\n    128, Generating Tesla code\n        129, #pragma acc loop gang /* blockIdx.x */\n    129, Loop is parallelizable\ntest_routine_gang_vector_named:\n    134, Generating Tesla code\n        135, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n    135, Loop is parallelizable\ntest_routine_gang_seq_named:\n    140, Generating Tesla code\n        141, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    141, Loop is parallelizable\nvalidate_data:\n    150, Zero trip check eliminated\ntest9:\n    451, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    453, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.269508674973622
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068734197993763,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -DT9 -o /usa/chrismun/openacc/build/routine_gang.c/routine_gang.c10 /usa/chrismun/openacc/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "called_function_worker:\n     16, Generating Tesla code\n         19, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     19, Loop is parallelizable\ncalled_function_vector:\n     26, Generating Tesla code\n         29, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         30, Vector barrier inserted for vector loop reduction\n     29, Loop is parallelizable\ncalled_function_seq:\n     36, Generating acc routine seq\n         Generating Tesla code\ncalled_function_gang:\n     46, Generating Tesla code\n         51, #pragma acc loop gang /* blockIdx.x */\n         54, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:privatized_return)\n         60, #pragma acc loop seq\n     54, Loop is parallelizable\ntest_routine_gang_loop_unnamed:\n     68, Generating Tesla code\n         71, #pragma acc loop gang /* blockIdx.x */\n         74, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n     74, Loop is parallelizable\ntest_routine_gang_gang_unnamed:\n     82, Generating Tesla code\n         83, #pragma acc loop seq\n     83, Loop is parallelizable\ntest_routine_gang_worker_unnamed:\n     89, Generating Tesla code\n         90, #pragma acc loop gang /* blockIdx.x */\n     90, Loop is parallelizable\ntest_routine_gang_vector_unnamed:\n     96, Generating Tesla code\n         97, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n     97, Loop is parallelizable\ntest_routine_gang_seq_unnamed:\n    103, Generating Tesla code\n        104, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    104, Loop is parallelizable\ntest_routine_gang_loop_named:\n    109, Generating Tesla code\n        112, #pragma acc loop gang /* blockIdx.x */\n        115, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n    115, Loop is parallelizable\ntest_routine_gang_gang_named:\n    122, Generating Tesla code\n        123, #pragma acc loop seq\n    123, Loop is parallelizable\ntest_routine_gang_worker_named:\n    128, Generating Tesla code\n        129, #pragma acc loop gang /* blockIdx.x */\n    129, Loop is parallelizable\ntest_routine_gang_vector_named:\n    134, Generating Tesla code\n        135, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n    135, Loop is parallelizable\ntest_routine_gang_seq_named:\n    140, Generating Tesla code\n        141, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    141, Loop is parallelizable\nvalidate_data:\n    150, Zero trip check eliminated\ntest10:\n    485, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    487, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.220960712991655
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0188236149260774,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/routine_gang.c/routine_gang.c11 /usa/chrismun/openacc/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "called_function_worker:\n     16, Generating Tesla code\n         19, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     19, Loop is parallelizable\ncalled_function_vector:\n     26, Generating Tesla code\n         29, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         30, Vector barrier inserted for vector loop reduction\n     29, Loop is parallelizable\ncalled_function_seq:\n     36, Generating acc routine seq\n         Generating Tesla code\ncalled_function_gang:\n     46, Generating Tesla code\n         51, #pragma acc loop gang /* blockIdx.x */\n         54, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:privatized_return)\n         60, #pragma acc loop seq\n     54, Loop is parallelizable\ntest_routine_gang_loop_unnamed:\n     68, Generating Tesla code\n         71, #pragma acc loop gang /* blockIdx.x */\n         74, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n     74, Loop is parallelizable\ntest_routine_gang_gang_unnamed:\n     82, Generating Tesla code\n         83, #pragma acc loop seq\n     83, Loop is parallelizable\ntest_routine_gang_worker_unnamed:\n     89, Generating Tesla code\n         90, #pragma acc loop gang /* blockIdx.x */\n     90, Loop is parallelizable\ntest_routine_gang_vector_unnamed:\n     96, Generating Tesla code\n         97, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n     97, Loop is parallelizable\ntest_routine_gang_seq_unnamed:\n    103, Generating Tesla code\n        104, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    104, Loop is parallelizable\ntest_routine_gang_loop_named:\n    109, Generating Tesla code\n        112, #pragma acc loop gang /* blockIdx.x */\n        115, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:temp)\n    115, Loop is parallelizable\ntest_routine_gang_gang_named:\n    122, Generating Tesla code\n        123, #pragma acc loop seq\n    123, Loop is parallelizable\ntest_routine_gang_worker_named:\n    128, Generating Tesla code\n        129, #pragma acc loop gang /* blockIdx.x */\n    129, Loop is parallelizable\ntest_routine_gang_vector_named:\n    134, Generating Tesla code\n        135, #pragma acc loop gang, worker /* blockIdx.x threadIdx.y */\n    135, Loop is parallelizable\ntest_routine_gang_seq_named:\n    140, Generating Tesla code\n        141, #pragma acc loop gang, worker, vector /* blockIdx.x threadIdx.y threadIdx.x */\n    141, Loop is parallelizable\nvalidate_data:\n    150, Zero trip check eliminated\ntest2:\n    213, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    215, Generating Tesla code\ntest3:\n    247, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    249, Generating Tesla code\ntest4:\n    281, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    283, Generating Tesla code\ntest5:\n    315, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    317, Generating Tesla code\ntest6:\n    349, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    351, Generating Tesla code\ntest7:\n    383, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    385, Generating Tesla code\ntest8:\n    417, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    419, Generating Tesla code\ntest9:\n    451, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    453, Generating Tesla code\ntest10:\n    485, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    487, Generating Tesla code\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 3.6221423969836906
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 12,
                    "runtime": 2.06804948404897,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "routine_nohost.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/routine_nohost.c/routine_nohost.c0 /usa/chrismun/openacc/Tests/routine_nohost.c",
                    "config": 1,
                    "errors": "function:\n      3, Generating Tesla code\n          6, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n      6, Loop is parallelizable\ntest1:\n     30, Generating copyin(a[:n][:n]) [if not already present]\n         Generating copyout(b[:n]) [if not already present]\n     32, Generating Tesla code\n         34, #pragma acc loop gang /* blockIdx.x */\n     42, Zero trip check eliminated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870306762983091
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069438179023564,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "routine_seq.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/routine_seq.c/routine_seq.c0 /usa/chrismun/openacc/Tests/routine_seq.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/routine_seq.c\", line 206: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\ncalled_function_seq:\n      9, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_loop_unnamed:\n     19, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_seq_unnamed:\n     29, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_loop_named:\n     35, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_seq_named:\n     44, Generating acc routine seq\n         Generating Tesla code\nvalidate_data:\n     54, Zero trip check eliminated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8705753890099004
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009224166045896709,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -o /usa/chrismun/openacc/build/routine_seq.c/routine_seq.c1 /usa/chrismun/openacc/Tests/routine_seq.c",
                    "config": 1,
                    "errors": "called_function_seq:\n      9, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_loop_unnamed:\n     19, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_seq_unnamed:\n     29, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_loop_named:\n     35, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_seq_named:\n     44, Generating acc routine seq\n         Generating Tesla code\nvalidate_data:\n     54, Zero trip check eliminated\ntest1:\n     84, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n     86, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.869500998989679
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.072667589993216,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT3 -DT4 -o /usa/chrismun/openacc/build/routine_seq.c/routine_seq.c2 /usa/chrismun/openacc/Tests/routine_seq.c",
                    "config": 1,
                    "errors": "called_function_seq:\n      9, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_loop_unnamed:\n     19, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_seq_unnamed:\n     29, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_loop_named:\n     35, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_seq_named:\n     44, Generating acc routine seq\n         Generating Tesla code\nvalidate_data:\n     54, Zero trip check eliminated\ntest2:\n    119, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    121, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8694947260664776
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069123934954405,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -o /usa/chrismun/openacc/build/routine_seq.c/routine_seq.c3 /usa/chrismun/openacc/Tests/routine_seq.c",
                    "config": 1,
                    "errors": "called_function_seq:\n      9, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_loop_unnamed:\n     19, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_seq_unnamed:\n     29, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_loop_named:\n     35, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_seq_named:\n     44, Generating acc routine seq\n         Generating Tesla code\nvalidate_data:\n     54, Zero trip check eliminated\ntest3:\n    154, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    156, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.919247703975998
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0196107210358605,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -o /usa/chrismun/openacc/build/routine_seq.c/routine_seq.c4 /usa/chrismun/openacc/Tests/routine_seq.c",
                    "config": 1,
                    "errors": "called_function_seq:\n      9, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_loop_unnamed:\n     19, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_seq_unnamed:\n     29, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_loop_named:\n     35, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_seq_named:\n     44, Generating acc routine seq\n         Generating Tesla code\nvalidate_data:\n     54, Zero trip check eliminated\ntest4:\n    189, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    191, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9196177220437676
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0185537750367075,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/routine_seq.c/routine_seq.c5 /usa/chrismun/openacc/Tests/routine_seq.c",
                    "config": 1,
                    "errors": "called_function_seq:\n      9, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_loop_unnamed:\n     19, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_seq_unnamed:\n     29, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_loop_named:\n     35, Generating acc routine seq\n         Generating Tesla code\ntest_routine_seq_seq_named:\n     44, Generating acc routine seq\n         Generating Tesla code\nvalidate_data:\n     54, Zero trip check eliminated\ntest1:\n     84, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n     86, Generating Tesla code\ntest2:\n    119, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    121, Generating Tesla code\ntest3:\n    154, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    156, Generating Tesla code\ntest4:\n    189, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    191, Generating Tesla code\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 3.020365344011225
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018446331960149,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "routine_vector.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -o /usa/chrismun/openacc/build/routine_vector.c/routine_vector.c0 /usa/chrismun/openacc/Tests/routine_vector.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/routine_vector.c\", line 301: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\ncalled_function_vector:\n     11, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         15, Vector barrier inserted for vector loop reduction\n     14, Loop is parallelizable\ncalled_function_seq:\n     21, Generating acc routine seq\n         Generating Tesla code\ntest_routine_vector_loop_unnamed:\n     31, Generating Tesla code\n         33, #pragma acc loop vector /* threadIdx.x */\n         34, #pragma acc loop seq\n     33, Loop is parallelizable\n     34, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_vector_vector_unnamed:\n     41, Generating Tesla code\n         42, #pragma acc loop seq\n     42, Loop is parallelizable\ntest_routine_vector_seq_unnamed:\n     48, Generating Tesla code\n         49, #pragma acc loop vector /* threadIdx.x */\n     49, Loop is parallelizable\ntest_routine_vector_loop_named:\n     54, Generating Tesla code\n         56, #pragma acc loop vector /* threadIdx.x */\n         57, #pragma acc loop seq\n     56, Loop is parallelizable\n     57, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_vector_vector_named:\n     63, Generating Tesla code\n         64, #pragma acc loop seq\n     64, Loop is parallelizable\ntest_routine_vector_seq_named:\n     69, Generating Tesla code\n         70, #pragma acc loop vector /* threadIdx.x */\n     70, Loop is parallelizable\nvalidate_data:\n     79, Zero trip check eliminated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.970138459932059
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008476502960547805,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -DT5 -DT6 -o /usa/chrismun/openacc/build/routine_vector.c/routine_vector.c1 /usa/chrismun/openacc/Tests/routine_vector.c",
                    "config": 1,
                    "errors": "called_function_vector:\n     11, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         15, Vector barrier inserted for vector loop reduction\n     14, Loop is parallelizable\ncalled_function_seq:\n     21, Generating acc routine seq\n         Generating Tesla code\ntest_routine_vector_loop_unnamed:\n     31, Generating Tesla code\n         33, #pragma acc loop vector /* threadIdx.x */\n         34, #pragma acc loop seq\n     33, Loop is parallelizable\n     34, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_vector_vector_unnamed:\n     41, Generating Tesla code\n         42, #pragma acc loop seq\n     42, Loop is parallelizable\ntest_routine_vector_seq_unnamed:\n     48, Generating Tesla code\n         49, #pragma acc loop vector /* threadIdx.x */\n     49, Loop is parallelizable\ntest_routine_vector_loop_named:\n     54, Generating Tesla code\n         56, #pragma acc loop vector /* threadIdx.x */\n         57, #pragma acc loop seq\n     56, Loop is parallelizable\n     57, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_vector_vector_named:\n     63, Generating Tesla code\n         64, #pragma acc loop seq\n     64, Loop is parallelizable\ntest_routine_vector_seq_named:\n     69, Generating Tesla code\n         70, #pragma acc loop vector /* threadIdx.x */\n     70, Loop is parallelizable\nvalidate_data:\n     79, Zero trip check eliminated\ntest1:\n    109, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    111, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.021509137004614
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069110749056563,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT3 -DT4 -DT5 -DT6 -o /usa/chrismun/openacc/build/routine_vector.c/routine_vector.c2 /usa/chrismun/openacc/Tests/routine_vector.c",
                    "config": 1,
                    "errors": "called_function_vector:\n     11, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         15, Vector barrier inserted for vector loop reduction\n     14, Loop is parallelizable\ncalled_function_seq:\n     21, Generating acc routine seq\n         Generating Tesla code\ntest_routine_vector_loop_unnamed:\n     31, Generating Tesla code\n         33, #pragma acc loop vector /* threadIdx.x */\n         34, #pragma acc loop seq\n     33, Loop is parallelizable\n     34, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_vector_vector_unnamed:\n     41, Generating Tesla code\n         42, #pragma acc loop seq\n     42, Loop is parallelizable\ntest_routine_vector_seq_unnamed:\n     48, Generating Tesla code\n         49, #pragma acc loop vector /* threadIdx.x */\n     49, Loop is parallelizable\ntest_routine_vector_loop_named:\n     54, Generating Tesla code\n         56, #pragma acc loop vector /* threadIdx.x */\n         57, #pragma acc loop seq\n     56, Loop is parallelizable\n     57, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_vector_vector_named:\n     63, Generating Tesla code\n         64, #pragma acc loop seq\n     64, Loop is parallelizable\ntest_routine_vector_seq_named:\n     69, Generating Tesla code\n         70, #pragma acc loop vector /* threadIdx.x */\n     70, Loop is parallelizable\nvalidate_data:\n     79, Zero trip check eliminated\ntest2:\n    144, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    146, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.970869131037034
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069250133004971,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -DT5 -DT6 -o /usa/chrismun/openacc/build/routine_vector.c/routine_vector.c3 /usa/chrismun/openacc/Tests/routine_vector.c",
                    "config": 1,
                    "errors": "called_function_vector:\n     11, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         15, Vector barrier inserted for vector loop reduction\n     14, Loop is parallelizable\ncalled_function_seq:\n     21, Generating acc routine seq\n         Generating Tesla code\ntest_routine_vector_loop_unnamed:\n     31, Generating Tesla code\n         33, #pragma acc loop vector /* threadIdx.x */\n         34, #pragma acc loop seq\n     33, Loop is parallelizable\n     34, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_vector_vector_unnamed:\n     41, Generating Tesla code\n         42, #pragma acc loop seq\n     42, Loop is parallelizable\ntest_routine_vector_seq_unnamed:\n     48, Generating Tesla code\n         49, #pragma acc loop vector /* threadIdx.x */\n     49, Loop is parallelizable\ntest_routine_vector_loop_named:\n     54, Generating Tesla code\n         56, #pragma acc loop vector /* threadIdx.x */\n         57, #pragma acc loop seq\n     56, Loop is parallelizable\n     57, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_vector_vector_named:\n     63, Generating Tesla code\n         64, #pragma acc loop seq\n     64, Loop is parallelizable\ntest_routine_vector_seq_named:\n     69, Generating Tesla code\n         70, #pragma acc loop vector /* threadIdx.x */\n     70, Loop is parallelizable\nvalidate_data:\n     79, Zero trip check eliminated\ntest3:\n    179, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    181, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.0206326890038326
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069182718056254,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT5 -DT6 -o /usa/chrismun/openacc/build/routine_vector.c/routine_vector.c4 /usa/chrismun/openacc/Tests/routine_vector.c",
                    "config": 1,
                    "errors": "called_function_vector:\n     11, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         15, Vector barrier inserted for vector loop reduction\n     14, Loop is parallelizable\ncalled_function_seq:\n     21, Generating acc routine seq\n         Generating Tesla code\ntest_routine_vector_loop_unnamed:\n     31, Generating Tesla code\n         33, #pragma acc loop vector /* threadIdx.x */\n         34, #pragma acc loop seq\n     33, Loop is parallelizable\n     34, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_vector_vector_unnamed:\n     41, Generating Tesla code\n         42, #pragma acc loop seq\n     42, Loop is parallelizable\ntest_routine_vector_seq_unnamed:\n     48, Generating Tesla code\n         49, #pragma acc loop vector /* threadIdx.x */\n     49, Loop is parallelizable\ntest_routine_vector_loop_named:\n     54, Generating Tesla code\n         56, #pragma acc loop vector /* threadIdx.x */\n         57, #pragma acc loop seq\n     56, Loop is parallelizable\n     57, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_vector_vector_named:\n     63, Generating Tesla code\n         64, #pragma acc loop seq\n     64, Loop is parallelizable\ntest_routine_vector_seq_named:\n     69, Generating Tesla code\n         70, #pragma acc loop vector /* threadIdx.x */\n     70, Loop is parallelizable\nvalidate_data:\n     79, Zero trip check eliminated\ntest4:\n    214, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    216, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.0206703150179237
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069432760006748,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT6 -o /usa/chrismun/openacc/build/routine_vector.c/routine_vector.c5 /usa/chrismun/openacc/Tests/routine_vector.c",
                    "config": 1,
                    "errors": "called_function_vector:\n     11, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         15, Vector barrier inserted for vector loop reduction\n     14, Loop is parallelizable\ncalled_function_seq:\n     21, Generating acc routine seq\n         Generating Tesla code\ntest_routine_vector_loop_unnamed:\n     31, Generating Tesla code\n         33, #pragma acc loop vector /* threadIdx.x */\n         34, #pragma acc loop seq\n     33, Loop is parallelizable\n     34, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_vector_vector_unnamed:\n     41, Generating Tesla code\n         42, #pragma acc loop seq\n     42, Loop is parallelizable\ntest_routine_vector_seq_unnamed:\n     48, Generating Tesla code\n         49, #pragma acc loop vector /* threadIdx.x */\n     49, Loop is parallelizable\ntest_routine_vector_loop_named:\n     54, Generating Tesla code\n         56, #pragma acc loop vector /* threadIdx.x */\n         57, #pragma acc loop seq\n     56, Loop is parallelizable\n     57, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_vector_vector_named:\n     63, Generating Tesla code\n         64, #pragma acc loop seq\n     64, Loop is parallelizable\ntest_routine_vector_seq_named:\n     69, Generating Tesla code\n         70, #pragma acc loop vector /* threadIdx.x */\n     70, Loop is parallelizable\nvalidate_data:\n     79, Zero trip check eliminated\ntest5:\n    249, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    251, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.0218040520558134
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069154971977696,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -o /usa/chrismun/openacc/build/routine_vector.c/routine_vector.c6 /usa/chrismun/openacc/Tests/routine_vector.c",
                    "config": 1,
                    "errors": "called_function_vector:\n     11, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         15, Vector barrier inserted for vector loop reduction\n     14, Loop is parallelizable\ncalled_function_seq:\n     21, Generating acc routine seq\n         Generating Tesla code\ntest_routine_vector_loop_unnamed:\n     31, Generating Tesla code\n         33, #pragma acc loop vector /* threadIdx.x */\n         34, #pragma acc loop seq\n     33, Loop is parallelizable\n     34, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_vector_vector_unnamed:\n     41, Generating Tesla code\n         42, #pragma acc loop seq\n     42, Loop is parallelizable\ntest_routine_vector_seq_unnamed:\n     48, Generating Tesla code\n         49, #pragma acc loop vector /* threadIdx.x */\n     49, Loop is parallelizable\ntest_routine_vector_loop_named:\n     54, Generating Tesla code\n         56, #pragma acc loop vector /* threadIdx.x */\n         57, #pragma acc loop seq\n     56, Loop is parallelizable\n     57, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_vector_vector_named:\n     63, Generating Tesla code\n         64, #pragma acc loop seq\n     64, Loop is parallelizable\ntest_routine_vector_seq_named:\n     69, Generating Tesla code\n         70, #pragma acc loop vector /* threadIdx.x */\n     70, Loop is parallelizable\nvalidate_data:\n     79, Zero trip check eliminated\ntest6:\n    284, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    286, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.968517311033793
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0690801040036604,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/routine_vector.c/routine_vector.c7 /usa/chrismun/openacc/Tests/routine_vector.c",
                    "config": 1,
                    "errors": "called_function_vector:\n     11, Generating Tesla code\n         14, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         15, Vector barrier inserted for vector loop reduction\n     14, Loop is parallelizable\ncalled_function_seq:\n     21, Generating acc routine seq\n         Generating Tesla code\ntest_routine_vector_loop_unnamed:\n     31, Generating Tesla code\n         33, #pragma acc loop vector /* threadIdx.x */\n         34, #pragma acc loop seq\n     33, Loop is parallelizable\n     34, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_vector_vector_unnamed:\n     41, Generating Tesla code\n         42, #pragma acc loop seq\n     42, Loop is parallelizable\ntest_routine_vector_seq_unnamed:\n     48, Generating Tesla code\n         49, #pragma acc loop vector /* threadIdx.x */\n     49, Loop is parallelizable\ntest_routine_vector_loop_named:\n     54, Generating Tesla code\n         56, #pragma acc loop vector /* threadIdx.x */\n         57, #pragma acc loop seq\n     56, Loop is parallelizable\n     57, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_vector_vector_named:\n     63, Generating Tesla code\n         64, #pragma acc loop seq\n     64, Loop is parallelizable\ntest_routine_vector_seq_named:\n     69, Generating Tesla code\n         70, #pragma acc loop vector /* threadIdx.x */\n     70, Loop is parallelizable\nvalidate_data:\n     79, Zero trip check eliminated\ntest1:\n    109, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    111, Generating Tesla code\ntest2:\n    144, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    146, Generating Tesla code\ntest3:\n    179, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    181, Generating Tesla code\ntest4:\n    214, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    216, Generating Tesla code\ntest5:\n    249, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    251, Generating Tesla code\ntest6:\n    284, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    286, Generating Tesla code\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 3.271003570058383
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018946816911921,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "routine_worker.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -o /usa/chrismun/openacc/build/routine_worker.c/routine_worker.c0 /usa/chrismun/openacc/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/routine_worker.c\", line 397: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\ncalled_function_worker:\n     14, Generating Tesla code\n         17, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     17, Loop is parallelizable\ncalled_function_vector:\n     24, Generating Tesla code\n         27, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         28, Vector barrier inserted for vector loop reduction\n     27, Loop is parallelizable\ncalled_function_seq:\n     34, Generating acc routine seq\n         Generating Tesla code\ntest_routine_worker_loop_unnamed:\n     44, Generating Tesla code\n         46, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         47, #pragma acc loop seq\n     46, Loop is parallelizable\n     47, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_unnamed:\n     54, Generating Tesla code\n         55, #pragma acc loop seq\n     55, Loop is parallelizable\ntest_routine_worker_vector_unnamed:\n     61, Generating Tesla code\n         62, #pragma acc loop worker /* threadIdx.y */\n     62, Loop is parallelizable\ntest_routine_worker_seq_unnamed:\n     68, Generating Tesla code\n         69, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     69, Loop is parallelizable\ntest_routine_worker_loop_named:\n     74, Generating Tesla code\n         76, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         77, #pragma acc loop seq\n     76, Loop is parallelizable\n     77, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_named:\n     83, Generating Tesla code\n         84, #pragma acc loop seq\n     84, Loop is parallelizable\ntest_routine_worker_vector_named:\n     89, Generating Tesla code\n         90, #pragma acc loop worker /* threadIdx.y */\n     90, Loop is parallelizable\ntest_routine_worker_seq_named:\n     95, Generating Tesla code\n         96, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     96, Loop is parallelizable\nvalidate_data:\n    105, Zero trip check eliminated\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.0695436149835587
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008738227072171867,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -o /usa/chrismun/openacc/build/routine_worker.c/routine_worker.c1 /usa/chrismun/openacc/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "called_function_worker:\n     14, Generating Tesla code\n         17, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     17, Loop is parallelizable\ncalled_function_vector:\n     24, Generating Tesla code\n         27, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         28, Vector barrier inserted for vector loop reduction\n     27, Loop is parallelizable\ncalled_function_seq:\n     34, Generating acc routine seq\n         Generating Tesla code\ntest_routine_worker_loop_unnamed:\n     44, Generating Tesla code\n         46, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         47, #pragma acc loop seq\n     46, Loop is parallelizable\n     47, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_unnamed:\n     54, Generating Tesla code\n         55, #pragma acc loop seq\n     55, Loop is parallelizable\ntest_routine_worker_vector_unnamed:\n     61, Generating Tesla code\n         62, #pragma acc loop worker /* threadIdx.y */\n     62, Loop is parallelizable\ntest_routine_worker_seq_unnamed:\n     68, Generating Tesla code\n         69, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     69, Loop is parallelizable\ntest_routine_worker_loop_named:\n     74, Generating Tesla code\n         76, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         77, #pragma acc loop seq\n     76, Loop is parallelizable\n     77, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_named:\n     83, Generating Tesla code\n         84, #pragma acc loop seq\n     84, Loop is parallelizable\ntest_routine_worker_vector_named:\n     89, Generating Tesla code\n         90, #pragma acc loop worker /* threadIdx.y */\n     90, Loop is parallelizable\ntest_routine_worker_seq_named:\n     95, Generating Tesla code\n         96, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     96, Loop is parallelizable\nvalidate_data:\n    105, Zero trip check eliminated\ntest1:\n    135, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    137, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.119417470996268
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0192420659586787,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -o /usa/chrismun/openacc/build/routine_worker.c/routine_worker.c2 /usa/chrismun/openacc/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "called_function_worker:\n     14, Generating Tesla code\n         17, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     17, Loop is parallelizable\ncalled_function_vector:\n     24, Generating Tesla code\n         27, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         28, Vector barrier inserted for vector loop reduction\n     27, Loop is parallelizable\ncalled_function_seq:\n     34, Generating acc routine seq\n         Generating Tesla code\ntest_routine_worker_loop_unnamed:\n     44, Generating Tesla code\n         46, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         47, #pragma acc loop seq\n     46, Loop is parallelizable\n     47, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_unnamed:\n     54, Generating Tesla code\n         55, #pragma acc loop seq\n     55, Loop is parallelizable\ntest_routine_worker_vector_unnamed:\n     61, Generating Tesla code\n         62, #pragma acc loop worker /* threadIdx.y */\n     62, Loop is parallelizable\ntest_routine_worker_seq_unnamed:\n     68, Generating Tesla code\n         69, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     69, Loop is parallelizable\ntest_routine_worker_loop_named:\n     74, Generating Tesla code\n         76, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         77, #pragma acc loop seq\n     76, Loop is parallelizable\n     77, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_named:\n     83, Generating Tesla code\n         84, #pragma acc loop seq\n     84, Loop is parallelizable\ntest_routine_worker_vector_named:\n     89, Generating Tesla code\n         90, #pragma acc loop worker /* threadIdx.y */\n     90, Loop is parallelizable\ntest_routine_worker_seq_named:\n     95, Generating Tesla code\n         96, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     96, Loop is parallelizable\nvalidate_data:\n    105, Zero trip check eliminated\ntest2:\n    170, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    172, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.120800803997554
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0733641459373757,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT4 -DT5 -DT6 -DT7 -DT8 -o /usa/chrismun/openacc/build/routine_worker.c/routine_worker.c3 /usa/chrismun/openacc/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "called_function_worker:\n     14, Generating Tesla code\n         17, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     17, Loop is parallelizable\ncalled_function_vector:\n     24, Generating Tesla code\n         27, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         28, Vector barrier inserted for vector loop reduction\n     27, Loop is parallelizable\ncalled_function_seq:\n     34, Generating acc routine seq\n         Generating Tesla code\ntest_routine_worker_loop_unnamed:\n     44, Generating Tesla code\n         46, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         47, #pragma acc loop seq\n     46, Loop is parallelizable\n     47, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_unnamed:\n     54, Generating Tesla code\n         55, #pragma acc loop seq\n     55, Loop is parallelizable\ntest_routine_worker_vector_unnamed:\n     61, Generating Tesla code\n         62, #pragma acc loop worker /* threadIdx.y */\n     62, Loop is parallelizable\ntest_routine_worker_seq_unnamed:\n     68, Generating Tesla code\n         69, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     69, Loop is parallelizable\ntest_routine_worker_loop_named:\n     74, Generating Tesla code\n         76, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         77, #pragma acc loop seq\n     76, Loop is parallelizable\n     77, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_named:\n     83, Generating Tesla code\n         84, #pragma acc loop seq\n     84, Loop is parallelizable\ntest_routine_worker_vector_named:\n     89, Generating Tesla code\n         90, #pragma acc loop worker /* threadIdx.y */\n     90, Loop is parallelizable\ntest_routine_worker_seq_named:\n     95, Generating Tesla code\n         96, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     96, Loop is parallelizable\nvalidate_data:\n    105, Zero trip check eliminated\ntest3:\n    205, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    207, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.12081156601198
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0686761509859934,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT5 -DT6 -DT7 -DT8 -o /usa/chrismun/openacc/build/routine_worker.c/routine_worker.c4 /usa/chrismun/openacc/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "called_function_worker:\n     14, Generating Tesla code\n         17, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     17, Loop is parallelizable\ncalled_function_vector:\n     24, Generating Tesla code\n         27, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         28, Vector barrier inserted for vector loop reduction\n     27, Loop is parallelizable\ncalled_function_seq:\n     34, Generating acc routine seq\n         Generating Tesla code\ntest_routine_worker_loop_unnamed:\n     44, Generating Tesla code\n         46, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         47, #pragma acc loop seq\n     46, Loop is parallelizable\n     47, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_unnamed:\n     54, Generating Tesla code\n         55, #pragma acc loop seq\n     55, Loop is parallelizable\ntest_routine_worker_vector_unnamed:\n     61, Generating Tesla code\n         62, #pragma acc loop worker /* threadIdx.y */\n     62, Loop is parallelizable\ntest_routine_worker_seq_unnamed:\n     68, Generating Tesla code\n         69, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     69, Loop is parallelizable\ntest_routine_worker_loop_named:\n     74, Generating Tesla code\n         76, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         77, #pragma acc loop seq\n     76, Loop is parallelizable\n     77, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_named:\n     83, Generating Tesla code\n         84, #pragma acc loop seq\n     84, Loop is parallelizable\ntest_routine_worker_vector_named:\n     89, Generating Tesla code\n         90, #pragma acc loop worker /* threadIdx.y */\n     90, Loop is parallelizable\ntest_routine_worker_seq_named:\n     95, Generating Tesla code\n         96, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     96, Loop is parallelizable\nvalidate_data:\n    105, Zero trip check eliminated\ntest4:\n    240, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    242, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.1215734239667654
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068951169028878,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT6 -DT7 -DT8 -o /usa/chrismun/openacc/build/routine_worker.c/routine_worker.c5 /usa/chrismun/openacc/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "called_function_worker:\n     14, Generating Tesla code\n         17, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     17, Loop is parallelizable\ncalled_function_vector:\n     24, Generating Tesla code\n         27, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         28, Vector barrier inserted for vector loop reduction\n     27, Loop is parallelizable\ncalled_function_seq:\n     34, Generating acc routine seq\n         Generating Tesla code\ntest_routine_worker_loop_unnamed:\n     44, Generating Tesla code\n         46, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         47, #pragma acc loop seq\n     46, Loop is parallelizable\n     47, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_unnamed:\n     54, Generating Tesla code\n         55, #pragma acc loop seq\n     55, Loop is parallelizable\ntest_routine_worker_vector_unnamed:\n     61, Generating Tesla code\n         62, #pragma acc loop worker /* threadIdx.y */\n     62, Loop is parallelizable\ntest_routine_worker_seq_unnamed:\n     68, Generating Tesla code\n         69, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     69, Loop is parallelizable\ntest_routine_worker_loop_named:\n     74, Generating Tesla code\n         76, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         77, #pragma acc loop seq\n     76, Loop is parallelizable\n     77, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_named:\n     83, Generating Tesla code\n         84, #pragma acc loop seq\n     84, Loop is parallelizable\ntest_routine_worker_vector_named:\n     89, Generating Tesla code\n         90, #pragma acc loop worker /* threadIdx.y */\n     90, Loop is parallelizable\ntest_routine_worker_seq_named:\n     95, Generating Tesla code\n         96, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     96, Loop is parallelizable\nvalidate_data:\n    105, Zero trip check eliminated\ntest5:\n    275, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    277, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.1201693329494447
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069371412973851,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT7 -DT8 -o /usa/chrismun/openacc/build/routine_worker.c/routine_worker.c6 /usa/chrismun/openacc/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "called_function_worker:\n     14, Generating Tesla code\n         17, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     17, Loop is parallelizable\ncalled_function_vector:\n     24, Generating Tesla code\n         27, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         28, Vector barrier inserted for vector loop reduction\n     27, Loop is parallelizable\ncalled_function_seq:\n     34, Generating acc routine seq\n         Generating Tesla code\ntest_routine_worker_loop_unnamed:\n     44, Generating Tesla code\n         46, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         47, #pragma acc loop seq\n     46, Loop is parallelizable\n     47, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_unnamed:\n     54, Generating Tesla code\n         55, #pragma acc loop seq\n     55, Loop is parallelizable\ntest_routine_worker_vector_unnamed:\n     61, Generating Tesla code\n         62, #pragma acc loop worker /* threadIdx.y */\n     62, Loop is parallelizable\ntest_routine_worker_seq_unnamed:\n     68, Generating Tesla code\n         69, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     69, Loop is parallelizable\ntest_routine_worker_loop_named:\n     74, Generating Tesla code\n         76, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         77, #pragma acc loop seq\n     76, Loop is parallelizable\n     77, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_named:\n     83, Generating Tesla code\n         84, #pragma acc loop seq\n     84, Loop is parallelizable\ntest_routine_worker_vector_named:\n     89, Generating Tesla code\n         90, #pragma acc loop worker /* threadIdx.y */\n     90, Loop is parallelizable\ntest_routine_worker_seq_named:\n     95, Generating Tesla code\n         96, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     96, Loop is parallelizable\nvalidate_data:\n    105, Zero trip check eliminated\ntest6:\n    310, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    312, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.121066416031681
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0196461470331997,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT8 -o /usa/chrismun/openacc/build/routine_worker.c/routine_worker.c7 /usa/chrismun/openacc/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "called_function_worker:\n     14, Generating Tesla code\n         17, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     17, Loop is parallelizable\ncalled_function_vector:\n     24, Generating Tesla code\n         27, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         28, Vector barrier inserted for vector loop reduction\n     27, Loop is parallelizable\ncalled_function_seq:\n     34, Generating acc routine seq\n         Generating Tesla code\ntest_routine_worker_loop_unnamed:\n     44, Generating Tesla code\n         46, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         47, #pragma acc loop seq\n     46, Loop is parallelizable\n     47, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_unnamed:\n     54, Generating Tesla code\n         55, #pragma acc loop seq\n     55, Loop is parallelizable\ntest_routine_worker_vector_unnamed:\n     61, Generating Tesla code\n         62, #pragma acc loop worker /* threadIdx.y */\n     62, Loop is parallelizable\ntest_routine_worker_seq_unnamed:\n     68, Generating Tesla code\n         69, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     69, Loop is parallelizable\ntest_routine_worker_loop_named:\n     74, Generating Tesla code\n         76, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         77, #pragma acc loop seq\n     76, Loop is parallelizable\n     77, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_named:\n     83, Generating Tesla code\n         84, #pragma acc loop seq\n     84, Loop is parallelizable\ntest_routine_worker_vector_named:\n     89, Generating Tesla code\n         90, #pragma acc loop worker /* threadIdx.y */\n     90, Loop is parallelizable\ntest_routine_worker_seq_named:\n     95, Generating Tesla code\n         96, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     96, Loop is parallelizable\nvalidate_data:\n    105, Zero trip check eliminated\ntest7:\n    345, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    347, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.0716841489775106
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069440323044546,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -o /usa/chrismun/openacc/build/routine_worker.c/routine_worker.c8 /usa/chrismun/openacc/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "called_function_worker:\n     14, Generating Tesla code\n         17, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     17, Loop is parallelizable\ncalled_function_vector:\n     24, Generating Tesla code\n         27, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         28, Vector barrier inserted for vector loop reduction\n     27, Loop is parallelizable\ncalled_function_seq:\n     34, Generating acc routine seq\n         Generating Tesla code\ntest_routine_worker_loop_unnamed:\n     44, Generating Tesla code\n         46, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         47, #pragma acc loop seq\n     46, Loop is parallelizable\n     47, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_unnamed:\n     54, Generating Tesla code\n         55, #pragma acc loop seq\n     55, Loop is parallelizable\ntest_routine_worker_vector_unnamed:\n     61, Generating Tesla code\n         62, #pragma acc loop worker /* threadIdx.y */\n     62, Loop is parallelizable\ntest_routine_worker_seq_unnamed:\n     68, Generating Tesla code\n         69, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     69, Loop is parallelizable\ntest_routine_worker_loop_named:\n     74, Generating Tesla code\n         76, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         77, #pragma acc loop seq\n     76, Loop is parallelizable\n     77, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_named:\n     83, Generating Tesla code\n         84, #pragma acc loop seq\n     84, Loop is parallelizable\ntest_routine_worker_vector_named:\n     89, Generating Tesla code\n         90, #pragma acc loop worker /* threadIdx.y */\n     90, Loop is parallelizable\ntest_routine_worker_seq_named:\n     95, Generating Tesla code\n         96, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     96, Loop is parallelizable\nvalidate_data:\n    105, Zero trip check eliminated\ntest8:\n    380, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    382, Generating Tesla code\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 3.071764972060919
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0192960860440508,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/routine_worker.c/routine_worker.c9 /usa/chrismun/openacc/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "called_function_worker:\n     14, Generating Tesla code\n         17, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n             Generating reduction(+:returned)\n     17, Loop is parallelizable\ncalled_function_vector:\n     24, Generating Tesla code\n         27, #pragma acc loop vector /* threadIdx.x */\n             Generating reduction(+:returned)\n         28, Vector barrier inserted for vector loop reduction\n     27, Loop is parallelizable\ncalled_function_seq:\n     34, Generating acc routine seq\n         Generating Tesla code\ntest_routine_worker_loop_unnamed:\n     44, Generating Tesla code\n         46, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         47, #pragma acc loop seq\n     46, Loop is parallelizable\n     47, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_unnamed:\n     54, Generating Tesla code\n         55, #pragma acc loop seq\n     55, Loop is parallelizable\ntest_routine_worker_vector_unnamed:\n     61, Generating Tesla code\n         62, #pragma acc loop worker /* threadIdx.y */\n     62, Loop is parallelizable\ntest_routine_worker_seq_unnamed:\n     68, Generating Tesla code\n         69, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     69, Loop is parallelizable\ntest_routine_worker_loop_named:\n     74, Generating Tesla code\n         76, #pragma acc loop vector, worker /* threadIdx.x threadIdx.y */\n         77, #pragma acc loop seq\n     76, Loop is parallelizable\n     77, Complex loop carried dependence of a->->,b-> prevents parallelization\n         Loop carried dependence of b-> prevents parallelization\n         Loop carried backward dependence of b-> prevents vectorization\ntest_routine_worker_worker_named:\n     83, Generating Tesla code\n         84, #pragma acc loop seq\n     84, Loop is parallelizable\ntest_routine_worker_vector_named:\n     89, Generating Tesla code\n         90, #pragma acc loop worker /* threadIdx.y */\n     90, Loop is parallelizable\ntest_routine_worker_seq_named:\n     95, Generating Tesla code\n         96, #pragma acc loop worker, vector /* threadIdx.y threadIdx.x */\n     96, Loop is parallelizable\nvalidate_data:\n    105, Zero trip check eliminated\ntest1:\n    135, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    137, Generating Tesla code\ntest2:\n    170, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    172, Generating Tesla code\ntest3:\n    205, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    207, Generating Tesla code\ntest4:\n    240, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    242, Generating Tesla code\ntest5:\n    275, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    277, Generating Tesla code\ntest6:\n    310, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    312, Generating Tesla code\ntest7:\n    345, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    347, Generating Tesla code\ntest8:\n    380, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n][:n]) [if not already present]\n    382, Generating Tesla code\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 3.370111219934188
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0690140690421686,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial.c/serial.c0 /usa/chrismun/openacc/Tests/serial.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:1024]) [if not already present]\n         Generating copy(c[:1024]) [if not already present]\n         Generating copyin(b[:1024]) [if not already present]\n     20, Accelerator serial kernel generated\n         Generating Tesla code\n         22, #pragma acc for seq\n         24, #pragma acc for seq\n         26, #pragma acc for seq\n         28, #pragma acc for seq\n         30, #pragma acc for seq\n         32, #pragma acc for seq\n         34, #pragma acc for seq\n         36, #pragma acc for seq\n         38, #pragma acc for seq\n         40, #pragma acc for seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 3.020569739979692
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018759333062917,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_async.c/serial_async.c0 /usa/chrismun/openacc/Tests/serial_async.c",
                    "config": 1,
                    "errors": "test1:\n     26, Generating copyin(a[:n],c[:n],d[:n],b[:n],e[:n],g[:n],f[:n]) [if not already present]\n     28, Accelerator serial kernel generated\n         Generating Tesla code\n         30, #pragma acc for seq\n     35, Accelerator serial kernel generated\n         Generating Tesla code\n         37, #pragma acc for seq\n     42, Accelerator serial kernel generated\n         Generating Tesla code\n         44, #pragma acc for seq\n     47, Generating update self(c[:n],g[:n],f[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870684494031593
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.119169366080314,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_copy.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_copy.c/serial_copy.c0 /usa/chrismun/openacc/Tests/serial_copy.c",
                    "config": 1,
                    "errors": "test1:\n     16, Generating copy(a[:n]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         18, #pragma acc for seq\n     24, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8708615290233865
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0687023799400777,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_copyin.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_copyin.c/serial_copyin.c0 /usa/chrismun/openacc/Tests/serial_copyin.c",
                    "config": 1,
                    "errors": "test1:\n     14, Generating enter data copyin(hasDevice[:1])\n         Generating present(hasDevice[:1])\n         Generating Tesla code\n     25, Generating copyin(a[:n]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         27, #pragma acc for seq\ntest2:\n     56, Generating copy(b[:n]) [if not already present]\n     58, Generating copyin(a[:n]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         60, #pragma acc for seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8702624069992453
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0688174549723044,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_copyout.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_copyout.c/serial_copyout.c0 /usa/chrismun/openacc/Tests/serial_copyout.c",
                    "config": 1,
                    "errors": "test1:\n     14, Generating enter data copyin(hasDevice[:1])\n         Generating present(hasDevice[:1])\n         Accelerator serial kernel generated\n         Generating Tesla code\n     24, Generating copyin(a[:n]) [if not already present]\n     26, Generating copyout(b[:n]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         28, #pragma acc for seq\ntest2:\n     57, Generating enter data copyin(hasDevice[:1])\n         Generating present(hasDevice[:1])\n         Accelerator serial kernel generated\n         Generating Tesla code\n     67, Generating copyin(a[:n],b[:n]) [if not already present]\n     69, Generating copyout(b[:n]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         71, #pragma acc for seq\ntest3:\n    100, Generating enter data copyin(hasDevice[:1])\n         Generating present(hasDevice[:1])\n         Accelerator serial kernel generated\n         Generating Tesla code\n    110, Generating copyin(a[:n],b[:n]) [if not already present]\n    112, Generating copyout(b[:n]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n        114, #pragma acc for seq\n    119, Generating update self(b[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9714489470934495
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0703742069890723,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_create.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_create.c/serial_create.c0 /usa/chrismun/openacc/Tests/serial_create.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n]) [if not already present]\n         Generating copy(c[:n]) [if not already present]\n     20, Generating create(b[:n]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         22, #pragma acc for seq\n         26, #pragma acc for seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8204331069719046
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0195569689385593,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_default_copy.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_default_copy.c/serial_default_copy.c0 /usa/chrismun/openacc/Tests/serial_default_copy.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n],b[:n]) [if not already present]\n     20, Accelerator serial kernel generated\n         Generating Tesla code\n         22, #pragma acc for seq\n     20, Generating implicit copy(c[:n]) [if not already present]\ntest2:\n     51, Generating enter data copyin(devtest[:1])\n         Generating present(devtest[:1])\n         Generating Tesla code\n     60, Generating enter data copyin(c[:n])\n     63, Memory zero idiom, loop replaced by call to __c_mzero8\n     67, Generating copyin(a[:n],b[:n]) [if not already present]\n     69, Accelerator serial kernel generated\n         Generating Tesla code\n         71, #pragma acc for seq\n     69, Generating implicit copy(c[:n]) [if not already present]\n     81, Generating exit data copyout(c[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.869827216025442
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0690764150349423,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_default_present.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_default_present.c/serial_default_present.c0 /usa/chrismun/openacc/Tests/serial_default_present.c",
                    "config": 1,
                    "errors": "test1:\n      9, Memory zero idiom, loop replaced by call to __c_mzero8\n     14, Generating enter data copyin(a[:n])\n         Accelerator serial kernel generated\n         Generating Tesla code\n         16, #pragma acc for seq\n     14, Generating default present(a[:n])\n     19, Generating exit data copyout(a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8202776630641893
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0691535730147734,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_deviceptr.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_deviceptr.c/serial_deviceptr.c0 /usa/chrismun/openacc/Tests/serial_deviceptr.c",
                    "config": 1,
                    "errors": "test1:\n     10, Memory zero idiom, loop replaced by call to __c_mzero8\n     15, Generating enter data copyin(a[:n])\n     21, Accelerator serial kernel generated\n         Generating Tesla code\n         23, #pragma acc for seq\n     28, Generating exit data copyout(a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7708390400512144
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0684339120052755,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_firstprivate.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_firstprivate.c/serial_firstprivate.c0 /usa/chrismun/openacc/Tests/serial_firstprivate.c",
                    "config": 1,
                    "errors": "test1:\n     23, Generating copyin(a[:n*10],b[:n*10]) [if not already present]\n         Generating copy(d[:n*10]) [if not already present]\n     25, Accelerator serial kernel generated\n         Generating update device(c[:n])\n         Generating Tesla code\n         27, #pragma acc for seq\n         29, #pragma acc for seq\ntest2:\n     69, Generating copyin(a[:n*10],b[:n*10]) [if not already present]\n         Generating copy(d[:n*10]) [if not already present]\n     71, Accelerator serial kernel generated\n         Generating update device(c[:n])\n         Generating Tesla code\n         73, #pragma acc for seq\n         75, #pragma acc for seq\n         79, #pragma acc for seq\n     87, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8701860930304974
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0187771569471806,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_if.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_if.c/serial_if.c0 /usa/chrismun/openacc/Tests/serial_if.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_if.c\", line 10: warning: variable \"accel\" was declared but never referenced\n      int accel = 1;\n          ^\n\n\"/usa/chrismun/openacc/Tests/serial_if.c\", line 44: warning: variable \"accel\" was declared but never referenced\n      int accel = 1;\n          ^\n\n\"/usa/chrismun/openacc/Tests/serial_if.c\", line 90: warning: variable \"host\" was declared but never referenced\n      int host = 0;\n          ^\n\ntest1:\n     19, Accelerator serial kernel generated\n         Generating Tesla code\n         21, #pragma acc for seq\n     19, Generating implicit copyin(a[:n]) [if not already present]\n         Generating implicit copyout(c[:n]) [if not already present]\n         Generating implicit copyin(b[:n]) [if not already present]\ntest2:\n     50, Generating copyin(devtest[:1]) [if not already present]\n         Generating present(devtest[:1])\n         Generating Tesla code\n     62, Generating enter data copyin(c[:n],b[:n],a[:n])\n         Generating present(a[:n],c[:n],b[:n])\n         Accelerator serial kernel generated\n         Generating Tesla code\n         64, #pragma acc for seq\n     67, Generating exit data copyout(c[:n])\n         Generating exit data delete(b[:n],a[:n])\ntest3:\n     99, Generating enter data copyin(b[:n],c[:n],a[:n])\n         Generating present(a[:n],c[:n],b[:n])\n         Accelerator serial kernel generated\n         Generating Tesla code\n        101, #pragma acc for seq\n    104, Generating exit data copyout(c[:n])\n         Generating exit data delete(b[:n],a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8721671459497884
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0191783539485186,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop.c/serial_loop.c0 /usa/chrismun/openacc/Tests/serial_loop.c",
                    "config": 1,
                    "errors": "test1:\n     11, Memory zero idiom, loop replaced by call to __c_mzero8\n     16, Generating copy(a[:n]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         18, #pragma acc for seq\ntest2:\n     48, Generating copy(a[:n],c[:n],b[:n]) [if not already present]\n     50, Accelerator serial kernel generated\n         Generating Tesla code\n         52, #pragma acc for seq\n         56, #pragma acc for seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870246035978198
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069172166986391,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_async.c/serial_loop_async.c0 /usa/chrismun/openacc/Tests/serial_loop_async.c",
                    "config": 1,
                    "errors": "test1:\n     25, Generating copyin(a[:n*10],b[:n*10],c[:n*10]) [if not already present]\n         Generating copy(errors[:10]) [if not already present]\n         Generating copyin(d[:n*10]) [if not already present]\n     26, Accelerator serial kernel generated\n         Generating Tesla code\n         28, #pragma acc for seq\n     30, Accelerator serial kernel generated\n         Generating Tesla code\n         32, #pragma acc for seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.920343214063905
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069313241983764,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_auto.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_auto.c/serial_loop_auto.c0 /usa/chrismun/openacc/Tests/serial_loop_auto.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_auto.c\", line 10: warning: variable \"rolling_total\" was declared but never referenced\n      real_t rolling_total = 0.0;\n             ^\n\ntest1:\n     18, Generating copyout(b[:n]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         20, #pragma acc for seq\ntest2:\n     51, Generating copy(a[:n]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         53, #pragma acc for seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8204309109132737
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0690616481006145,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_gang.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_gang.c/serial_loop_gang.c0 /usa/chrismun/openacc/Tests/serial_loop_gang.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_gang.c\", line 19: error: invalid text in pragma\n          #pragma acc serial loop gang\n                                  ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/serial_loop_gang.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.018917741952464
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/serial_loop_gang.c/serial_loop_gang.c1 /usa/chrismun/openacc/Tests/serial_loop_gang.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_gang.c\", line 37: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1193845609668642
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008444912964478135,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_add_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_add_general.c/serial_loop_reduction_add_general.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_add_general.c",
                    "config": 1,
                    "errors": "test1:\n     17, Generating copyin(a[:n]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         19, #pragma acc for seq\n     17, Generating implicit copy(total) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.770159547100775
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0687725809402764,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_add_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_add_loop.c/serial_loop_reduction_add_loop.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_add_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_add_loop.c\", line 21: error: invalid text in pragma\n          #pragma acc serial loop gang private(avg)\n                                  ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/serial_loop_reduction_add_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.967664300929755
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/serial_loop_reduction_add_loop.c/serial_loop_reduction_add_loop.c1 /usa/chrismun/openacc/Tests/serial_loop_reduction_add_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_add_loop.c\", line 56: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.118995907017961
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008857723092660308,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_add_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_add_vector_loop.c/serial_loop_reduction_add_vector_loop.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_add_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     17, Generating copyin(a[:n*10]) [if not already present]\n         Generating copyout(c[:10]) [if not already present]\n         Generating copyin(b[:n*10]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         19, #pragma acc for seq\n         22, #pragma acc for seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.870792979025282
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068498071981594,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_and_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_and_general.c/serial_loop_reduction_and_general.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_and_general.c",
                    "config": 1,
                    "errors": "test1:\n     22, Accelerator serial kernel generated\n         Generating Tesla code\n         24, #pragma acc for seq\n     22, Generating implicit copy(result) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.770569210057147
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0687929700361565,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_and_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_and_loop.c/serial_loop_reduction_and_loop.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_and_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_and_loop.c\", line 33: error: invalid text in pragma\n          #pragma acc serial loop gang private(temp)\n                                  ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/serial_loop_reduction_and_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0190662420354784
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/serial_loop_reduction_and_loop.c/serial_loop_reduction_and_loop.c1 /usa/chrismun/openacc/Tests/serial_loop_reduction_and_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_and_loop.c\", line 72: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0691103999270126
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008458498981781304,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_and_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_and_vector_loop.c/serial_loop_reduction_and_vector_loop.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_and_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     26, Generating copy(b[:10]) [if not already present]\n         Generating copyin(a[:n*10]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         28, #pragma acc for seq\n         31, #pragma acc for seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8210824739653617
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0194154599448666,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitand_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_bitand_general.c/serial_loop_reduction_bitand_general.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_bitand_general.c",
                    "config": 1,
                    "errors": "test1:\n     33, Accelerator serial kernel generated\n         Generating Tesla code\n         35, #pragma acc for seq\n     33, Generating implicit copy(b) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7709208419546485
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.069138632970862,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitand_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_bitand_loop.c/serial_loop_reduction_bitand_loop.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_bitand_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_bitand_loop.c\", line 31: error: invalid text in pragma\n          #pragma acc serial loop gang private(temp)\n                                  ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/serial_loop_reduction_bitand_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9685288140317425
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/serial_loop_reduction_bitand_loop.c/serial_loop_reduction_bitand_loop.c1 /usa/chrismun/openacc/Tests/serial_loop_reduction_bitand_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_bitand_loop.c\", line 69: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0692554840352386
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008838908048346639,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitand_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_bitand_vector_loop.c/serial_loop_reduction_bitand_vector_loop.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_bitand_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     28, Generating copy(b[:10]) [if not already present]\n         Generating copyin(a[:n*10]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         30, #pragma acc for seq\n         33, #pragma acc for seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8201844060095027
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0689393179491162,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitor_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_bitor_general.c/serial_loop_reduction_bitor_general.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_bitor_general.c",
                    "config": 1,
                    "errors": "test1:\n     26, Accelerator serial kernel generated\n         Generating Tesla code\n         28, #pragma acc for seq\n     26, Generating implicit copy(b) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7707326790550724
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0191029720008373,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitor_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_bitor_loop.c/serial_loop_reduction_bitor_loop.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_bitor_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_bitor_loop.c\", line 34: error: invalid text in pragma\n          #pragma acc serial loop gang private(temp)\n                                  ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/serial_loop_reduction_bitor_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9692017330089584
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/serial_loop_reduction_bitor_loop.c/serial_loop_reduction_bitor_loop.c1 /usa/chrismun/openacc/Tests/serial_loop_reduction_bitor_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_bitor_loop.c\", line 69: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1186610440490767
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009211700991727412,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitor_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_bitor_vector_loop.c/serial_loop_reduction_bitor_vector_loop.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_bitor_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     27, Generating copy(b[:10]) [if not already present]\n         Generating copyin(a[:n*10]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         29, #pragma acc for seq\n         32, #pragma acc for seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7712339049903676
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1189284779829904,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitxor_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_bitxor_general.c/serial_loop_reduction_bitxor_general.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_bitxor_general.c",
                    "config": 1,
                    "errors": "test1:\n     16, Accelerator serial kernel generated\n         Generating Tesla code\n         18, #pragma acc for seq\n     16, Generating implicit copy(b) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.819827541941777
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0194323530886322,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitxor_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_bitxor_loop.c/serial_loop_reduction_bitxor_loop.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_bitxor_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_bitxor_loop.c\", line 24: error: invalid text in pragma\n          #pragma acc serial loop gang private(temp)\n                                  ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/serial_loop_reduction_bitxor_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.019004666013643
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/serial_loop_reduction_bitxor_loop.c/serial_loop_reduction_bitxor_loop.c1 /usa/chrismun/openacc/Tests/serial_loop_reduction_bitxor_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_bitxor_loop.c\", line 60: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1187834839802235
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008552336017601192,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitxor_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_bitxor_vector_loop.c/serial_loop_reduction_bitxor_vector_loop.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_bitxor_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     17, Generating copy(b[:10]) [if not already present]\n         Generating copyin(a[:n*10]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         19, #pragma acc for seq\n         22, #pragma acc for seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820346773019992
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0187753438949585,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_max_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_max_general.c/serial_loop_reduction_max_general.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_max_general.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_max_general.c\", line 32: warning: use of \"=\" where \"==\" may have been intended\n      if (found = 0){\n          ^\n\n\"/usa/chrismun/openacc/Tests/serial_loop_reduction_max_general.c\", line 10: warning: variable \"found\" was set but never used\n      int found = 0;\n          ^\n\ntest1:\n     17, Generating copyin(a[:n]) [if not already present]\n         Generating copy(max) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         19, #pragma acc for seq\n     25, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8208323220023885
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0194100219523534,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_max_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_max_loop.c/serial_loop_reduction_max_loop.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_max_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_max_loop.c\", line 25: error: invalid text in pragma\n          #pragma acc serial loop gang private(temp)\n                                  ^\n\n\"/usa/chrismun/openacc/Tests/serial_loop_reduction_max_loop.c\", line 12: warning: variable \"max\" was declared but never referenced\n      real_t max = 0.0;\n             ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/serial_loop_reduction_max_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0184201520169154
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/serial_loop_reduction_max_loop.c/serial_loop_reduction_max_loop.c1 /usa/chrismun/openacc/Tests/serial_loop_reduction_max_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_max_loop.c\", line 60: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1342319410759956
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009098096983507276,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_max_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_max_vector_loop.c/serial_loop_reduction_max_vector_loop.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_max_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyin(a[:n*10]) [if not already present]\n         Generating copy(max[:10]) [if not already present]\n         Generating copyin(b[:n*10]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         20, #pragma acc for seq\n         23, #pragma acc for seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8205252999905497
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0190081319306046,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_min_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_min_general.c/serial_loop_reduction_min_general.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_min_general.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating copyin(a[:n]) [if not already present]\n         Generating copy(min) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         21, #pragma acc for seq\n     27, FMA (fused multiply-add) instruction(s) generated\n     30, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8218029839918017
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0187731699552387,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_min_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_min_loop.c/serial_loop_reduction_min_loop.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_min_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_min_loop.c\", line 21: error: invalid text in pragma\n          #pragma acc serial loop gang private(temp)\n                                  ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/serial_loop_reduction_min_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9684856220846996
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/serial_loop_reduction_min_loop.c/serial_loop_reduction_min_loop.c1 /usa/chrismun/openacc/Tests/serial_loop_reduction_min_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_min_loop.c\", line 57: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1185870540793985
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008523210999555886,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_min_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_min_vector_loop.c/serial_loop_reduction_min_vector_loop.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_min_vector_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_min_vector_loop.c\", line 20: error: invalid text in pragma\n          #pragma acc serial loop gang private(temp)\n                                  ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/serial_loop_reduction_min_vector_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.118611851008609
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/serial_loop_reduction_min_vector_loop.c/serial_loop_reduction_min_vector_loop.c1 /usa/chrismun/openacc/Tests/serial_loop_reduction_min_vector_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_min_vector_loop.c\", line 48: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.119115734938532
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008527989964932203,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_multiply_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_multiply_general.c/serial_loop_reduction_multiply_general.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_multiply_general.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating copyin(a[:multiplicitive_n]) [if not already present]\n         Generating copy(multiplied_total) [if not already present]\n         Generating copyin(b[:multiplicitive_n]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         21, #pragma acc for seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7717006279854104
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0194319939473644,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_multiply_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_multiply_loop.c/serial_loop_reduction_multiply_loop.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_multiply_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_multiply_loop.c\", line 22: error: invalid text in pragma\n          #pragma acc serial loop gang private(temp)\n                                  ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/serial_loop_reduction_multiply_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.968445915961638
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/serial_loop_reduction_multiply_loop.c/serial_loop_reduction_multiply_loop.c1 /usa/chrismun/openacc/Tests/serial_loop_reduction_multiply_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_multiply_loop.c\", line 58: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.169388902024366
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009146459051407874,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_multiply_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_multiply_vector_loop.c/serial_loop_reduction_multiply_vector_loop.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_multiply_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating copyin(a[:multiplicitive_n*10]) [if not already present]\n         Generating copyout(c[:10]) [if not already present]\n         Generating copyin(b[:multiplicitive_n*10]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         21, #pragma acc for seq\n         24, #pragma acc for seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820903494954109
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0192037119995803,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_or_general.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_or_general.c/serial_loop_reduction_or_general.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_or_general.c",
                    "config": 1,
                    "errors": "test1:\n     23, Accelerator serial kernel generated\n         Generating Tesla code\n         25, #pragma acc for seq\n     23, Generating implicit copy(result) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7837242610985413
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0192911359481514,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_or_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_or_loop.c/serial_loop_reduction_or_loop.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_or_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_or_loop.c\", line 25: error: invalid text in pragma\n          #pragma acc serial loop gang private(temp)\n                                  ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/serial_loop_reduction_or_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0189739579800516
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/serial_loop_reduction_or_loop.c/serial_loop_reduction_or_loop.c1 /usa/chrismun/openacc/Tests/serial_loop_reduction_or_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_reduction_or_loop.c\", line 74: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.168539079022594
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009102805983275175,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_or_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_reduction_or_vector_loop.c/serial_loop_reduction_or_vector_loop.c0 /usa/chrismun/openacc/Tests/serial_loop_reduction_or_vector_loop.c",
                    "config": 1,
                    "errors": "test1:\n     22, Generating copy(b[:10]) [if not already present]\n         Generating copyin(a[:n*10]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         24, #pragma acc for seq\n         27, #pragma acc for seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820314923999831
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.019015218014829,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_seq.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_seq.c/serial_loop_seq.c0 /usa/chrismun/openacc/Tests/serial_loop_seq.c",
                    "config": 1,
                    "errors": "test1:\n     17, Generating copy(b[:n]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         19, #pragma acc for seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7706845980137587
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0189525870373473,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_tile.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_tile.c/serial_loop_tile.c0 /usa/chrismun/openacc/Tests/serial_loop_tile.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_tile.c\", line 58: warning: variable \"temp\" was declared but never referenced\n      real_t temp = 0.0;\n             ^\n\ntest1:\n     20, Generating copy(a[:n],b[:n],d2[:n*n],c[:n]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         22, #pragma acc for seq tile(0,0)\n         23,   tiled */\n         25, #pragma acc for seq\n     33, Zero trip check eliminated\n     35, Zero trip check eliminated\ntest2:\n     67, Generating copyin(a[:n],b[:n]) [if not already present]\n         Generating copyout(d3[:n*(n*n)]) [if not already present]\n         Generating copyin(c[:n]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         69, #pragma acc for seq tile(0,0,0)\n         70,   tiled */\n         71,   tiled */\n     79, Zero trip check eliminated\n     80, Zero trip check eliminated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9201533750165254
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.119108469109051,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_vector.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_vector.c/serial_loop_vector.c0 /usa/chrismun/openacc/Tests/serial_loop_vector.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_vector.c\", line 19: error: invalid text in pragma\n          #pragma acc serial loop vector\n                                  ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/serial_loop_vector.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9687378889648244
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/serial_loop_vector.c/serial_loop_vector.c1 /usa/chrismun/openacc/Tests/serial_loop_vector.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_vector.c\", line 37: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1189482669578865
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008521367912180722,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_vector_blocking.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_vector_blocking.c/serial_loop_vector_blocking.c0 /usa/chrismun/openacc/Tests/serial_loop_vector_blocking.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_vector_blocking.c\", line 36: warning: expression has no effect\n        err + 1;\n        ^\n\ntest1:\n     19, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     21, Accelerator serial kernel generated\n         Generating Tesla code\n         23, #pragma acc for seq\n         28, #pragma acc for seq\n     35, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8700764250243083
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0185628549661487,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_worker.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_worker.c/serial_loop_worker.c0 /usa/chrismun/openacc/Tests/serial_loop_worker.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_worker.c\", line 19: error: invalid text in pragma\n          #pragma acc serial loop worker\n                                  ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/serial_loop_worker.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.969187141978182
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/serial_loop_worker.c/serial_loop_worker.c1 /usa/chrismun/openacc/Tests/serial_loop_worker.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_worker.c\", line 37: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.1691799490945414
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008986416039988399,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_worker_blocking.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_loop_worker_blocking.c/serial_loop_worker_blocking.c0 /usa/chrismun/openacc/Tests/serial_loop_worker_blocking.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_loop_worker_blocking.c\", line 36: warning: expression has no effect\n          err + 1;\n          ^\n\ntest1:\n     19, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     21, Accelerator serial kernel generated\n         Generating Tesla code\n         23, #pragma acc for seq\n         28, #pragma acc for seq\n     35, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8204082370502874
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0187935470603406,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_present.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_present.c/serial_present.c0 /usa/chrismun/openacc/Tests/serial_present.c",
                    "config": 1,
                    "errors": "test1:\n     19, Generating enter data copyin(b[:n],a[:n])\n         Generating present(a[:n],b[:n])\n         Generating copy(c[:n]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         21, #pragma acc for seq\n     24, Generating exit data delete(b[:n],a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.821311778970994
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0200928010744974,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_private.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_private.c/serial_private.c0 /usa/chrismun/openacc/Tests/serial_private.c",
                    "config": 1,
                    "errors": "test1:\n     25, Generating enter data copyin(b[:n*10],d[:10],a[:n*10])\n         Accelerator serial kernel generated\n         Generating Tesla code\n         27, #pragma acc for seq\n         29, #pragma acc for seq\n         33, #pragma acc for seq\n     25, Generating implicit copyout(c[:n]) [if not already present]\n         Generating implicit copy(d[:10]) [if not already present]\n     27, Accelerator restriction: size of the GPU copy of b,a is unknown\n         Generating implicit copyin(b[:],a[:]) [if not already present]\n     37, Generating exit data delete(a[:n*10])\n         Generating exit data copyout(d[:10])\n         Generating exit data delete(b[:n*10])\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8209777149604633
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failing in Thread:1\ncall to cuStreamSynchronize returned error 700: Illegal address during kernel execution\n\n",
                    "export": false,
                    "output": "",
                    "result": 1,
                    "runtime": 2.119341442012228,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/serial_private.c/serial_private.c1 /usa/chrismun/openacc/Tests/serial_private.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_private.c\", line 56: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.119829655974172
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008714994066394866,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_reduction.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_reduction.c/serial_reduction.c0 /usa/chrismun/openacc/Tests/serial_reduction.c",
                    "config": 1,
                    "errors": "test1:\n     15, Generating copyin(a[:n]) [if not already present]\n         Accelerator serial kernel generated\n         Generating Tesla code\n         17, #pragma acc for seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8725167789962143
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0193290470633656,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_scalar_default_firstprivate.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_scalar_default_firstprivate.c/serial_scalar_default_firstprivate.c0 /usa/chrismun/openacc/Tests/serial_scalar_default_firstprivate.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating copyout(b[:n]) [if not already present]\n         Generating copyin(a[:n]) [if not already present]\n     20, Accelerator serial kernel generated\n         Generating Tesla code\n         22, #pragma acc for seq\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8198423699941486
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068951089051552,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_switch.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_switch.c/serial_switch.c0 /usa/chrismun/openacc/Tests/serial_switch.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating enter data copyin(b[:n],c[:n],a[:n])\n         Generating present(a[:n],c[:n],b[:n])\n         Accelerator serial kernel generated\n         Generating Tesla code\n         22, #pragma acc for seq\n     41, Generating exit data copyout(c[:n])\n         Generating exit data delete(b[:n],a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.820868717972189
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0688956030644476,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_wait.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_wait.c/serial_wait.c0 /usa/chrismun/openacc/Tests/serial_wait.c",
                    "config": 1,
                    "errors": "test1:\n     18, Generating enter data create(a[:n])\n         Generating update device(a[:n])\n         Generating present(a[:n])\n         Accelerator serial kernel generated\n         Generating Tesla code\n         20, #pragma acc for seq\n     23, Generating exit data copyout(a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8204434539657086
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0695425160229206,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_while_loop.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/serial_while_loop.c/serial_while_loop.c0 /usa/chrismun/openacc/Tests/serial_while_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_while_loop.c\", line 33: error: expected a \";\"\n      for (int y = 0 y < 10; ++y){\n                     ^\n\n\"/usa/chrismun/openacc/Tests/serial_while_loop.c\", line 33: error: expected a \";\"\n      for (int y = 0 y < 10; ++y){\n                                ^\n\n2 errors detected in the compilation of \"/usa/chrismun/openacc/Tests/serial_while_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 2.0190875119296834
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/serial_while_loop.c/serial_while_loop.c1 /usa/chrismun/openacc/Tests/serial_while_loop.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/serial_while_loop.c\", line 50: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.119222754961811
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00908933102618903,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "set_default_async.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/set_default_async.c/set_default_async.c0 /usa/chrismun/openacc/Tests/set_default_async.c",
                    "config": 1,
                    "errors": "test1:\n     21, Generating copyin(a[:n]) [if not already present]\n         Generating copyout(c[:n]) [if not already present]\n         Generating copyin(b[:n]) [if not already present]\n     24, Generating Tesla code\n         26, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     32, Generating Tesla code\n         34, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     39, Generating Tesla code\n         41, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     49, FMA (fused multiply-add) instruction(s) generated\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.7710662479512393
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.018805537954904,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "set_device_num.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/set_device_num.c/set_device_num.c0 /usa/chrismun/openacc/Tests/set_device_num.c",
                    "config": 1,
                    "errors": "test1:\n     20, Generating enter data copyin(a[:n])\n     24, Generating present(a[:n])\n     26, Generating Tesla code\n         28, #pragma acc loop gang, vector(128) /* blockIdx.x threadIdx.x */\n     34, Generating exit data copyout(a[:n])\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.8700599960284308
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.319469597074203,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "set_device_type.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/set_device_type.c/set_device_type.c0 /usa/chrismun/openacc/Tests/set_device_type.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/set_device_type.c\", line 9: error: Specified device type is not a valid device type. Currently accepted device types are 'nvidia, host, multicore, and default'\n      #pragma acc set device_type(device_type)\n                                  ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/set_device_type.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.967869488056749
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/set_device_type.c/set_device_type.c1 /usa/chrismun/openacc/Tests/set_device_type.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/set_device_type.c\", line 20: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.068385841092095
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00911720294971019,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "shutdown.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/shutdown.c/shutdown.c0 /usa/chrismun/openacc/Tests/shutdown.c",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.118688244954683
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009035940049216151,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "shutdown_device_num.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/shutdown_device_num.c/shutdown_device_num.c0 /usa/chrismun/openacc/Tests/shutdown_device_num.c",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.119301544968039
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 1.9184458940289915,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "shutdown_device_type.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/shutdown_device_type.c/shutdown_device_type.c0 /usa/chrismun/openacc/Tests/shutdown_device_type.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/shutdown_device_type.c\", line 10: error: Specified device type is not a valid device type. Currently accepted device types are 'nvidia, host, multicore, and default'\n      #pragma acc shutdown device_type(device_type)\n                                       ^\n\n\"/usa/chrismun/openacc/Tests/shutdown_device_type.c\", line 7: warning: variable \"device_type\" was set but never used\n      int device_type; \n          ^\n\n1 error detected in the compilation of \"/usa/chrismun/openacc/Tests/shutdown_device_type.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.9683321319753304
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/shutdown_device_type.c/shutdown_device_type.c1 /usa/chrismun/openacc/Tests/shutdown_device_type.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/shutdown_device_type.c\", line 18: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.0687328559579328
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008963481988757849,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "shutdown_device_type_num.c": [
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -o /usa/chrismun/openacc/build/shutdown_device_type_num.c/shutdown_device_type_num.c0 /usa/chrismun/openacc/Tests/shutdown_device_type_num.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/shutdown_device_type_num.c\", line 8: error: expected a \";\"\n      int device_num\n      ^\n\n\"/usa/chrismun/openacc/Tests/shutdown_device_type_num.c\", line 11: error: identifier \"device_num\" is undefined\n      device_num = acc_get_device_num(device_type);\n      ^\n\n\"/usa/chrismun/openacc/Tests/shutdown_device_type_num.c\", line 11: warning: enumerated type mixed with another type\n      device_num = acc_get_device_num(device_type);\n                                      ^\n\n\"/usa/chrismun/openacc/Tests/shutdown_device_type_num.c\", line 11: warning: variable \"device_type\" is used before its value is set\n      device_num = acc_get_device_num(device_type);\n                                      ^\n\n\"/usa/chrismun/openacc/Tests/shutdown_device_type_num.c\", line 12: error: Specified device type is not a valid device type. Currently accepted device types are 'nvidia, host, multicore, and default'\n      #pragma acc shutdown device_type(device_type) device_num(device_num)\n                                       ^\n\n3 errors detected in the compilation of \"/usa/chrismun/openacc/Tests/shutdown_device_type_num.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 1.96873876999598
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -acc -ta=tesla -Minfo=all -DT1 -o /usa/chrismun/openacc/build/shutdown_device_type_num.c/shutdown_device_type_num.c1 /usa/chrismun/openacc/Tests/shutdown_device_type_num.c",
                    "config": 1,
                    "errors": "\"/usa/chrismun/openacc/Tests/shutdown_device_type_num.c\", line 20: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.118985108099878
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00908441108185798,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ]
    },
    "summary": {
        "1": {
            "1": {
                "1": {
                    "acc_async_test.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_async_test_all.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_copyin.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "6": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "7": {
                            "result": "Pass",
                            "run_index": 8
                        }
                    },
                    "acc_copyin_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "4": {
                            "result": "Runtime Error",
                            "run_index": 4
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 6
                        }
                    },
                    "acc_copyout.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_copyout_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 5
                        }
                    },
                    "acc_copyout_finalize.c": {
                        "1": {
                            "result": "Unknown Section Result",
                            "run_index": -1
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 7
                        },
                        "3": {
                            "result": "Compilation Failure",
                            "run_index": 7
                        }
                    },
                    "acc_copyout_finalize_async.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 1
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 2
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "4": {
                            "result": "Compilation Failure",
                            "run_index": 4
                        }
                    },
                    "acc_create.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "5": {
                            "result": "Runtime Error",
                            "run_index": 5
                        }
                    },
                    "acc_create_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "4": {
                            "result": "Runtime Error",
                            "run_index": 4
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 6
                        }
                    },
                    "acc_delete.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_delete_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_delete_finalize.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 2
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 3
                        }
                    },
                    "acc_delete_finalize_async.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 2
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 3
                        }
                    },
                    "acc_deviceptr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_free.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_get_default_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_get_device_num.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_get_num_devices.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_get_property.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_hostptr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_init.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_is_present.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_malloc.c": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "acc_map_data.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_memcpy_device.c": {
                        "1": {
                            "result": "Runtime Error",
                            "run_index": 0
                        }
                    },
                    "acc_memcpy_from_device.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_memcpy_from_device_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_memcpy_to_device.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_memcpy_to_device_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_on_device.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_set_default_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_set_device_num.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_set_device_type.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_shutdown.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_unmap_data.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_update_device.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_update_device_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_update_self.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_update_self_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_wait.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_wait_all.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_wait_all_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_wait_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_bitand_equals.c": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_bitor_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_bitxor_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_bitand_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_bitor_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_bitxor_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_divided_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_bitand_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_bitor_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_bitxor_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_divided_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_lshift_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_minus_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_multiply_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_plus_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_rshift_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_lshift_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_minus_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_multiply_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_plus_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_postdecrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_postincrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_predecrement.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_preincrement.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_rshift_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_divided_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_bitand_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_bitor_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_bitxor_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_divided_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_lshift_x.c": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_minus_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_multiply_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_plus_x.c": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_rshift_x.c": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_lshift_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_minus_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_multiply_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_plus_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_postdecrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_postincrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_predecrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_preincrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_rshift_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_bitand_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_bitor_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_bitxor_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_divided_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_expr_bitand_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_expr_bitor_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_expr_bitxor_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_expr_divided_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_expr_multiply_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_expr_plus_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_lshift_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_minus_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_multiply_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_plus_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_postdecrement.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_postincrement.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_predecrement.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_preincrement.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_rshift_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_x_bitand_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_x_bitor_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_x_bitxor_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_x_divided_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_x_lshift_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_x_minus_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_x_multiply_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_x_plus_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_x_rshift_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_bitand_equals_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_bitor_equals_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_bitxor_equals_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_divided_equals_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_expr_bitand_x_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_expr_bitor_x_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_expr_bitxor_x_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_expr_multiply_x_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_expr_plus_x_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_lshift_equals_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_minus_equals_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_multiply_equals_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_plus_equals_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_postdecrement_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_postincrement_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_predecrement_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_preincrement_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_rshift_equals_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_x_bitand_expr_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_x_bitor_expr_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_x_bitxor_expr_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_x_divided_expr_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_x_lshift_expr_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_x_minus_expr_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_x_multiply_expr_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_x_plus_expr_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_x_rshift_expr_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_update_bitand_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_bitor_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_bitxor_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_divided_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_bitand_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_bitor_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_bitxor_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_divided_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_lshift_x.c": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_minus_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_multiply_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_plus_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_rshift_x.c": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_update_lshift_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_minus_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_multiply_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_plus_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_postdecrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_postincrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_predecrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_preincrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_rshift_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_bitand_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_bitor_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_bitxor_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_divided_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_lshift_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_minus_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_multiply_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_plus_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_rshift_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_bitand_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_bitor_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_bitxor_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_divided_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_lshift_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_minus_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_multiply_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_plus_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_rshift_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_copy_no_lower_bound.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_copyin_no_lower_bound.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_copyout_no_lower_bound.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_copyout_reference_counts.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_create.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_create_no_lower_bound.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_present_no_lower_bound.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_with_changing_subscript.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_with_structs.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "declare_copyin.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 6
                        }
                    },
                    "declare_create.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "5": {
                            "result": "Runtime Error",
                            "run_index": 5
                        }
                    },
                    "declare_device_resident.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "declare_function_scope_copy.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "2": {
                            "result": "Runtime Error",
                            "run_index": 2
                        },
                        "3": {
                            "result": "Runtime Error",
                            "run_index": 3
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 5
                        }
                    },
                    "declare_function_scope_copyin.c": {
                        "1": {
                            "result": "Unknown Section Result",
                            "run_index": -1
                        },
                        "2": {
                            "result": "Runtime Error",
                            "run_index": 7
                        },
                        "3": {
                            "result": "Runtime Error",
                            "run_index": 7
                        }
                    },
                    "declare_function_scope_copyout.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "2": {
                            "result": "Runtime Error",
                            "run_index": 2
                        },
                        "3": {
                            "result": "Runtime Error",
                            "run_index": 3
                        },
                        "4": {
                            "result": "Runtime Error",
                            "run_index": 4
                        }
                    },
                    "declare_function_scope_create.c": {
                        "1": {
                            "result": "Unknown Section Result",
                            "run_index": -1
                        },
                        "2": {
                            "result": "Runtime Error",
                            "run_index": 7
                        },
                        "3": {
                            "result": "Runtime Error",
                            "run_index": 7
                        }
                    },
                    "declare_function_scope_deviceptr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 2
                        },
                        "2": {
                            "result": "Runtime Error",
                            "run_index": 1
                        }
                    },
                    "declare_function_scope_present.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 2
                        },
                        "2": {
                            "result": "Runtime Error",
                            "run_index": 1
                        }
                    },
                    "enter_data_copyin_no_lower_bound.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "enter_data_create.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "enter_data_create_no_lower_bound.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "enter_exit_data_if.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 6
                        }
                    },
                    "exit_data.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "exit_data_copyout_no_lower_bound.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "exit_data_copyout_reference_counts.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "exit_data_delete_no_lower_bound.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "exit_data_finalize.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "host_data.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "init.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "init_device_num.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "init_device_type.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "init_device_type_num.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "kernels_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_copy.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_copyin.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 4
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 4
                        },
                        "3": {
                            "result": "Unknown Section Result",
                            "run_index": -1
                        }
                    },
                    "kernels_copyout.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_create.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_default_copy.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_default_present.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_if.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 2
                        },
                        "3": {
                            "result": "Runtime Failure",
                            "run_index": 5
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 5
                        }
                    },
                    "kernels_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_independent.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_add_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_add_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_add_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_and_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_and_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_and_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitand_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitand_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitand_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitor_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitor_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitor_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitxor_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitxor_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitxor_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_max_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_max_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_max_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_min_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_min_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_min_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_multiply_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_multiply_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_multiply_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_or_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_or_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_or_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_seq.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_tile.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_vector_blocking.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_worker_blocking.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_num_gangs.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_num_workers.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_present.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_scalar_default_copy.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_vector_length.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_wait.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "loop_collapse.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "loop_no_collapse_default.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_copy.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_copyin.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_copyout.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_create.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_default_copy.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_default_present.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_deviceptr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_firstprivate.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_if.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 2
                        },
                        "2": {
                            "result": "Unknown Section Result",
                            "run_index": -1
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 2
                        }
                    },
                    "parallel_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_async.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_auto.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_gang.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_add_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_add_general_type_check_pt1.c": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 9
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "6": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "7": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "8": {
                            "result": "Pass",
                            "run_index": 9
                        }
                    },
                    "parallel_loop_reduction_add_general_type_check_pt2.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "6": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "7": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "8": {
                            "result": "Pass",
                            "run_index": 9
                        }
                    },
                    "parallel_loop_reduction_add_general_type_check_pt3.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_add_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_add_loop_type_check_pt1.c": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_add_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_and_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_and_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_and_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_bitand_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_bitand_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_bitand_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_bitor_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_bitor_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_bitor_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_bitxor_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_bitxor_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_bitxor_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_max_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_max_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_max_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_min_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_min_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_min_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_multiply_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_multiply_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_multiply_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        },
                        "3": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_or_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_or_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_or_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_seq.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_tile.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_vector.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_vector_blocking.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_worker.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_worker_blocking.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_present.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_private.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_reduction.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_scalar_default_firstprivate.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_switch.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_wait.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_while_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "routine_bind.c": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 5
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 2
                        },
                        "3": {
                            "result": "Runtime Failure",
                            "run_index": 5
                        },
                        "4": {
                            "result": "Compilation Failure",
                            "run_index": 4
                        }
                    },
                    "routine_gang.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 1
                        },
                        "10": {
                            "result": "Pass",
                            "run_index": 11
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 11
                        },
                        "3": {
                            "result": "Runtime Failure",
                            "run_index": 11
                        },
                        "4": {
                            "result": "Runtime Failure",
                            "run_index": 11
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 11
                        },
                        "6": {
                            "result": "Pass",
                            "run_index": 11
                        },
                        "7": {
                            "result": "Pass",
                            "run_index": 11
                        },
                        "8": {
                            "result": "Pass",
                            "run_index": 11
                        },
                        "9": {
                            "result": "Pass",
                            "run_index": 11
                        }
                    },
                    "routine_nohost.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "routine_seq.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 5
                        }
                    },
                    "routine_vector.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 7
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 7
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 7
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 7
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 7
                        },
                        "6": {
                            "result": "Pass",
                            "run_index": 7
                        }
                    },
                    "routine_worker.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "6": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "7": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "8": {
                            "result": "Pass",
                            "run_index": 9
                        }
                    },
                    "serial.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_copy.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_copyin.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_copyout.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_create.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_default_copy.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_default_present.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_deviceptr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_firstprivate.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_if.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_auto.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_gang.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_add_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_add_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_add_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_and_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_and_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_and_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitand_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitand_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitand_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitor_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitor_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitor_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitxor_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitxor_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitxor_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_max_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_max_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_max_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_min_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_min_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_min_vector_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_multiply_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_multiply_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_multiply_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_or_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_or_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_or_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_seq.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_tile.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_vector.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_vector_blocking.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_worker.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_worker_blocking.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_present.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_private.c": {
                        "1": {
                            "result": "Runtime Error",
                            "run_index": 0
                        }
                    },
                    "serial_reduction.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_scalar_default_firstprivate.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_switch.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_wait.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_while_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "set_default_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "set_device_num.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "set_device_type.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "shutdown.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "shutdown_device_num.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "shutdown_device_type.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "shutdown_device_type_num.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    }
                }
            }
        }
    },
    "systems": [
        {
            "id": 1,
            "machine": "x86_64",
            "name": null,
            "node": "skywalker",
            "processor": "x86_64",
            "release": "5.4.0-109-generic",
            "version": "#123-Ubuntu SMP Fri Apr 8 09:10:54 UTC 2022"
        }
    ],
    "testsuites": [
        {
            "acc_async_test.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:async,runtime,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n]) async(1)\n    #pragma acc enter data copyin(d[0:n]) create(e[0:n]) async(2)\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1) wait(2)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            e[x] = c[x] + d[x];\n        }\n    }\n    #pragma acc exit data copyout(e[0:n]) async(1)\n\n    while (!acc_async_test(1));\n    for (int x = 0; x < n; ++x){\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:async,runtime,construct-independent,V:1.0-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[0:n]) copyout(e[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                e[x] = c[x] + d[x];\n            }\n        }\n        while (!acc_async_test(1));\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:async,runtime,construct-independent,V:2.5-2.7\nint test3() {\n    int err = 0;\n    real_t* a = (real_t*)malloc(n * sizeof(real_t));\n    real_t* b = (real_t*)malloc(n * sizeof(real_t));\n    real_t* c = (real_t*)malloc(n * sizeof(real_t));\n    real_t* d = (real_t*)malloc(n * sizeof(real_t));\n    real_t* e = (real_t*)malloc(n * sizeof(real_t));\n    int async_val = acc_get_default_async();\n\n    for (int x = 0; x < n; ++x) {\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[0:n]) copyout(e[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                e[x] = c[x] + d[x];\n            }\n        }\n        while (!acc_async_test(async_val));\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x) {\n        failed = failed + test3();\n    }\n    if (failed != 0) {\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_async_test_all.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:async,runtime,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t **a = (real_t **)malloc(10 * sizeof(real_t*));\n    real_t **b = (real_t **)malloc(10 * sizeof(real_t*));\n    real_t **c = (real_t **)malloc(10 * sizeof(real_t*));\n    real_t **d = (real_t **)malloc(10 * sizeof(real_t*));\n    real_t **e = (real_t **)malloc(10 * sizeof(real_t*));\n\n    for (int x = 0; x < 10; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        d[x] = (real_t *)malloc(n * sizeof(real_t));\n        e[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 0;\n            d[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            e[x][y] = 0;\n        }\n    }\n\n    #pragma acc enter data create(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n], d[0:10][0:n], e[0:10][0:n])\n    for (int x = 0; x < 10; ++x){\n        #pragma acc update device(a[x:1][0:n], b[x:1][0:n], d[x:1][0:n]) async(x)\n        #pragma acc parallel present(a[x:1][0:n], b[x:1][0:n], c[x:1][0:n]) async(x)\n        {\n            #pragma acc loop\n            for (int y = 0; y < n; ++y){\n                c[x][y] = a[x][y] + b[x][y];\n            }\n        }\n        #pragma acc parallel present(c[x:1][0:n], d[x:1][0:n], e[x:1][0:n]) async(x)\n        {\n            #pragma acc loop\n            for (int y = 0; y < n; ++y){\n                e[x][y] = c[x][y] + d[x][y];\n            }\n        }\n        #pragma acc update host(e[x:1][0:n]) async(x)\n    }\n   \n    while(!acc_async_test_all());\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(e[x][y] - (a[x][y] + b[x][y] + d[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n    #pragma acc exit data delete(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n], d[0:10][0:n], e[0:10][0:n])\n    for (int x = 0; x < 10; ++x){\n        free(a[x]);\n        free(b[x]);\n        free(c[x]);\n        free(d[x]);\n        free(e[x]);\n    }\n    free(a);\n    free(b);\n    free(c);\n    free(d);\n    free(e);\n    \n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:async,runtime,construct-independent,V:1.0-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10*n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n], d[0:10*n]) copyout(c[0:10*n], e[0:10*n])\n    {\n        for (int x = 0; x < 10; ++x){\n            #pragma acc parallel present(a[0:10*n], b[0:10*n], c[0:10*n]) async(x)\n            {\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    c[x * n + y] = a[x * n + y] + b[x * n + y];\n                }\n            }\n            #pragma acc parallel present(c[0:10*n], d[0:10*n], e[0:10*n]) async(x)\n            {\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    e[x * n + y] = c[x * n + y] + d[x * n + y];\n                }\n            }\n        }\n        while(!acc_async_test_all());\n    }\n\n    for (int x = 0; x < 10*n; ++x){\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    \n    free(a);\n    free(b);\n    free(c);\n    free(d);\n    free(e);\n    \n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:async,runtime,construct-independent,V:2.5-2.7\nint test3(){\n    int err = 0;\n    real_t **a = (real_t **)malloc(10 * sizeof(real_t *));\n    real_t **b = (real_t **)malloc(10 * sizeof(real_t *));\n    real_t **c = (real_t **)malloc(10 * sizeof(real_t *));\n    real_t **d = (real_t **)malloc(10 * sizeof(real_t *));\n    real_t **e = (real_t **)malloc(10 * sizeof(real_t *));\n\n    for (int x = 0; x < 10; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        d[x] = (real_t *)malloc(n * sizeof(real_t));\n        e[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 0;\n            d[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            e[x][y] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:10][0:n], b[0:10][0:n], d[0:10][0:n]) copyout(c[0:10][0:n], e[0:10][0:n])\n    {\n        for (int x = 0; x < 10; ++x){\n            acc_set_default_async(x);\n            #pragma acc parallel present(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n]) async\n            {\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    c[x][y] = a[x][y] + b[x][y];\n                }\n            }\n            #pragma acc parallel present(c[0:10][0:n], d[0:10][0:n], e[0:10][0:n]) async\n            {\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    e[x][y] = c[x][y] + d[x][y];\n                }\n            }\n        }\n        while (!acc_async_test_all());\n    }\n\n    int count = 0;\n    int total = 0;\n    for (int x = 0; x < 10; ++x) {\n        for (int y = 0; y < n; ++y) {\n            if (fabs(e[x][y]) < PRECISION) {\n                count += 1;\n            }\n            total += 1;\n        }\n    }\n    printf(\"%d out of %d\\n\", count, total);\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(e[x][y] - (a[x][y] + b[x][y] + d[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n    \n    for (int x = 0; x < 10; ++x){\n        free(a[x]);\n        free(b[x]);\n        free(c[x]);\n        free(d[x]);\n        free(e[x]);\n    }\n    free(a);\n    free(b);\n    free(c);\n    free(d);\n    free(e);\n    \n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyin.c": {
                "num tests": 7,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n\n    #pragma acc data copy(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_copyout(a, n * sizeof(real_t));\n    acc_copyout(b, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(time(NULL));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n\n    #pragma acc data copy(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(time(NULL));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * dev_test = (int *)malloc(n * sizeof(int));\n\n    dev_test[0] = 1;\n    #pragma acc enter data copyin(dev_test[0:1])\n    #pragma acc parallel present(dev_test[0:1])\n    {\n        dev_test[0] = 0;\n    }\n\n    if (dev_test[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            a_copy[x] = a[x];\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            b_copy[x] = b[x];\n            c[x] = 0.0;\n        }\n\n        acc_copyin(a, n * sizeof(real_t));\n        acc_copyin(b, n * sizeof(real_t));\n\n        for (int x = 0; x < n; ++x){\n            a[x] = 0;\n            b[x] = 0;\n        }\n\n        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n\n        acc_copyout(a, n * sizeof(real_t));\n        acc_copyout(b, n * sizeof(real_t));\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(a[x] - a_copy[x]) > PRECISION){\n                err += 1;\n            }\n            if (fabs(b[x] - b_copy[x]) > PRECISION){\n                err += 1;\n            }\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:runtime,data,executable-data,construct-independent,compatibility-features,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(time(NULL));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_pcopyin(a, n * sizeof(real_t));\n    acc_pcopyin(b, n * sizeof(real_t));\n\n    #pragma acc data copy(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:runtime,data,executable-data,construct-independent,compatibility-features,V:2.0-2.7\nint test5(){\n    int err = 0;\n    srand(time(NULL));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_present_or_copyin(a, n * sizeof(real_t));\n    acc_present_or_copyin(b, n * sizeof(real_t));\n\n    #pragma acc data copyout(c[0:n]) present(a[0:n], b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n//T6:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7\nint test6() {\n    int err = 0;\n    srand(time(NULL));\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x) {\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n])\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T6\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x) {\n        failed = failed + test6();\n    }\n    if (failed != 0) {\n        failcode = failcode + (1 << 5);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "7": {
                        "content": "#ifndef T7\n//T7:runtime,data,executable-data,construct-independent,reference-counting,devonly,V:2.5-2.7\nint test7() {\n    int err = 0;\n    srand(time(NULL));\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    int * dev_test = (int *)malloc(n * sizeof(int));\n\n    dev_test[0] = 1;\n    #pragma acc enter data copyin(dev_test[0:1])\n    #pragma acc parallel present(dev_test[0:1])\n    {\n        dev_test[0] = 0;\n    }\n\n    if (dev_test[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            a_copy[x] = a[x];\n            b_copy[x] = b[x];\n            c[x] = 0;\n        }\n        \n        acc_copyin(a, n * sizeof(real_t));\n        acc_copyin(b, n * sizeof(real_t));\n\n        for (int x = 0; x < n; ++x){\n            a[x] = 0;\n            b[x] = 0;\n        }\n\n        acc_copyin(a, n * sizeof(real_t));\n        acc_copyin(b, n * sizeof(real_t));\n\n        #pragma acc data copyout(c[0:n])\n        {\n            #pragma acc parallel present(a[0:n], b[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n\n        #pragma acc exit data delete(a[0:n], b[0:n])\n        #pragma acc exit data delete(a[0:n], b[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T7\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x) {\n        failed = failed + test7();\n    }\n    if (failed != 0) {\n        failcode = failcode + (1 << 6);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting",
                            "devonly"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyin_async.c": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:async,data,executable-data,runtime,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        a_host[x] = a[x];\n        b_host[x] = b[x];\n    }\n\n    acc_copyin_async(a, n * sizeof(real_t), 1);\n    acc_copyin_async(b, n * sizeof(real_t), 2);\n    #pragma acc data copyout(c[0:n]) present(a[0:n], b[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] * a[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] * b[x];\n            }\n        }\n        #pragma acc parallel async(2) wait(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > PRECISION * 4){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "data",
                            "executable-data",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 1;\n    }\n\n    acc_copyin_async(a, n*sizeof(real_t), 1);\n    acc_copyin_async(b, n*sizeof(real_t), 2);\n\n    #pragma acc data copyout(c[0:n])\n    {\n        while (!acc_async_test_all());\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_copyin_async(a, n * sizeof(real_t), 1);\n    acc_copyin_async(b, n * sizeof(real_t), 2);\n\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc wait\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err = err + 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(n * sizeof(real_t));\n    real_t * e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) copyout(e[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyin_async(c, n * sizeof(real_t), 1);\n        #pragma acc exit data delete(c[0:n]) async(1)\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                e[x] = c[x] + d[x];\n            }\n        }\n    }\n    #pragma acc wait\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 0;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 1;\n    }\n\n    if (devtest[0] == 0){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n            a_copy[x] = a[x];\n            b_copy[x] = b[x];\n        }\n\n        acc_copyin_async(a, n * sizeof(real_t), 1);\n        acc_copyin_async(b, n * sizeof(real_t), 2);\n\n        for (int x = 0; x < n; ++x) {\n            a[x] = 0;\n            b[x] = 0;\n        }\n\n        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n        {\n            #pragma acc wait\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x) {\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n\n        #pragma acc exit data delete(a[0:n], b[0:n])\n\n        for (int x = 0; x < n; ++x) {\n            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_create(c, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_copyout(c, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_copyout(c, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_async.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n], f[0:n])\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])\n    {\n        #pragma acc parallel async(1) present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2) present(f[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        acc_copyout_async(c, n * sizeof(real_t), 1);\n        acc_copyout_async(f, n * sizeof(real_t), 2);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,async,data,executable-data,internal-control-values,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int def_async_var = acc_get_default_async();\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyout_async(c, n * sizeof(real_t), def_async_var);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "data",
                            "executable-data",
                            "internal-control-values",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,async,data,executable-data,internal-control-values,construct-independent,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int def_async_var = acc_get_default_async();\n\n    acc_set_default_async(def_async_var + 1);\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    \n    #pragma acc enter data create(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyout_async(c, n * sizeof(real_t), def_async_var + 1);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "data",
                            "executable-data",
                            "internal-control-values",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:runtime,async,data,executable-data,construct-independent,V:2.5-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc enter data copyin(c[0:n])\n        acc_copyout_async(c, n * sizeof(real_t), 1);\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] += a[x] + b[x];\n            }\n        }\n        acc_copyout_async(c, n * sizeof(real_t), 1);\n    }\n    \n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_finalize.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc enter data create(c[0:n])\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n    acc_copyout_finalize(c, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data copyin(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n    acc_copyout_finalize(c, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data copyin(c[0:n])\n    #pragma acc enter data copyin(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyout_finalize(c, n * sizeof(real_t));\n        #pragma acc enter data copyin(c[0:n])\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {\n            err += 1;\n        }\n    }\n    \n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_finalize_async.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n], f[0:n])\n    #pragma acc enter data create(c[0:n], f[0:n])\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n]) present(c[0:n], f[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        acc_copyout_finalize_async(c, n * sizeof(real_t), 1);\n        acc_copyout_finalize_async(f, n * sizeof(real_t), 2);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,async,construct-independent,internal-control-values,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int def_async_var = acc_get_default_async();\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc enter data create(c[0:n])\n    \n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyout_finalize_async(c, n * sizeof(real_t), def_async_var);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "internal-control-values"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,async,construct-independent,internal-control-values,set,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int def_async_var = acc_get_default_async();\n\n    acc_set_default_async(def_async_var + 1);\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc enter data create(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyout_async(c, n * sizeof(real_t), def_async_var + 1);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "internal-control-values",
                            "set"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc enter data create(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyout_finalize_async(c, n * sizeof(real_t), 1);\n        #pragma acc enter data copyin(c[0:n]) async(1)\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {\n            err += 1;\n        }\n    }\n    \n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_create.c": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_create(c, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_copyout(c, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_create(c, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,compatibility-features,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_pcreate(c, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "compatibility-features",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:runtime,data,executable-data,compatibility-features,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_present_or_create(c, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "compatibility-features",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:runtime,data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * dev_test = (int *)malloc(sizeof(int));\n\n    dev_test[0] = 1;\n    #pragma acc enter data copyin(dev_test[0:1])\n    #pragma acc parallel present(dev_test[0:1])\n    {\n        dev_test[0] = 0;\n    }\n    if (dev_test[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 1;\n        }\n\n        #pragma acc enter data copyin(c[0:n])\n        for (int x = 0; x < n; ++x){\n            c[x] = 0;\n        }\n        acc_create(c, n * sizeof(real_t));\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel present(c[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x) {\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n\n        #pragma acc exit data delete(c[0:n])\n        #pragma acc exit data copyout(c[0:n])\n    \n        for (int x = 0; x < n; ++x) {\n            if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_create_async.c": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,data,executable-data,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])\n    {\n        acc_create_async(c, n * sizeof(real_t), 1);\n        acc_create_async(f, n * sizeof(real_t), 2);\n        #pragma acc data present(c[0:n], f[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n            #pragma acc parallel async(2)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    f[x] = d[x] + e[x];\n                }\n            }\n            #pragma acc wait\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n], f[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_create_async(c, n * sizeof(real_t), 1);\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        while (!acc_async_test_all());\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_create_async(c, n * sizeof(real_t), 1);\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc wait\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(n * sizeof(real_t));\n    real_t * e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) copyout(e[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_create_async(c, n * sizeof(real_t), 1);\n        #pragma acc exit data delete(c[0:n]) async(1)\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                e[x] = c[x] + d[x];\n            }\n        }\n    }\n    #pragma acc wait\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:runtime,data,executable-data,devonly,async,construct-independent,reference-counting,V:2.5-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n    \n    devtest[0] = 0;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 1;\n    }\n\n    if (devtest[0] == 0){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc enter data create(c[0:n])\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel present(c[0:n]) async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x) {\n                    c[x] = a[x] + b[x];\n                }\n            }\n            acc_create_async(c, n * sizeof(real_t), 1);\n            #pragma acc parallel present(c[0:n]) async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x) {\n                    c[x] += a[x] + b[x];\n                }\n            }\n            #pragma acc exit data copyout(c[0:n]) async(1)\n            #pragma acc wait\n        }\n\n        for (int x = 0; x < n; ++x) {\n            if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n])\n\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_delete(a, n * sizeof(real_t));\n    acc_delete(b, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_delete(a, n * sizeof(real_t));\n    acc_delete(b, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_async.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,async,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], d[0:n], e[0:n])\n\n    #pragma acc data present(a[0:n], b[0:n], d[0:n], e[0:n]) copyout(c[0:n], f[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        acc_delete_async(a, n * sizeof(real_t), 1);\n        acc_delete_async(b, n * sizeof(real_t), 1);\n        acc_delete_async(d, n * sizeof(real_t), 2);\n        acc_delete_async(e, n * sizeof(real_t), 2);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "async"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n    int* devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n        #pragma acc data present(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] * b[x];\n                }\n            }\n        }\n        acc_delete_async(c, n * sizeof(real_t), 1);\n        #pragma acc enter data copyin(c[0:n]) async(1)\n        #pragma acc data present(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n        #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_finalize.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,reference-counting,construct-independent,syntactic,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n])\n    #pragma acc enter data copyin(a[0:n], b[0:n])\n\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_delete_finalize(a, n * sizeof(real_t));\n    acc_delete_finalize(b, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "reference-counting",
                            "construct-independent",
                            "syntactic"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,reference-counting,syntactic,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_delete_finalize(a, n * sizeof(real_t));\n    acc_delete_finalize(b, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "reference-counting",
                            "syntactic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_finalize_async.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,reference-counting,syntactic,construct-independent,async,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], d[0:n], e[0:n])\n    #pragma acc enter data copyin(a[0:n], b[0:n], d[0:n], e[0:n])\n\n    #pragma acc data present(a[0:n], b[0:n], d[0:n], e[0:n]) copyout(c[0:n], f[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        acc_delete_finalize_async(a, n * sizeof(real_t), 1);\n        acc_delete_finalize_async(b, n * sizeof(real_t), 1);\n        acc_delete_finalize_async(d, n * sizeof(real_t), 2);\n        acc_delete_finalize_async(e, n * sizeof(real_t), 2);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "reference-counting",
                            "syntactic",
                            "construct-independent",
                            "async"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,reference-counting,devonly,async,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n    int* devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n        #pragma acc enter data copyin(c[0:n])\n        #pragma acc data present(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] * b[x];\n                }\n            }\n        }\n        acc_delete_finalize_async(c, n * sizeof(real_t), 1);\n        #pragma acc enter data copyin(c[0:n]) async(1)\n        #pragma acc data present(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n        #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "reference-counting",
                            "devonly",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_deviceptr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_ptr;\n    real_t *b_ptr;\n    real_t *c_ptr;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])\n\n    a_ptr = acc_deviceptr(a);\n    b_ptr = acc_deviceptr(b);\n    c_ptr = acc_deviceptr(c);\n\n    #pragma acc data deviceptr(a_ptr, b_ptr, c_ptr)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c_ptr[x] = a_ptr[x] + b_ptr[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_free.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,V:2.6-2.7\nint test1(){\n    int err = 0;\n    int *a = (int *)acc_malloc(n * sizeof(int));\n    size_t initial_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);\n\n    acc_free(a);\n    size_t final_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);\n    if (final_memory < initial_memory + n * sizeof(int)){\n        err += 1;\n    }\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_default_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,construct-independent,internal-control-values,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    int holder = acc_get_default_async();\n\n    for(int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc wait(holder)\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    if (acc_get_default_async() < 0){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "internal-control-values"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_device_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,devonly,internal-control-values,syntactic,V:1.0-2.7\nint test1(){\n    int err = 0;\n\n    if (acc_get_device_type() != acc_device_none){\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            acc_set_device_num(x, acc_get_device_type());\n            if (acc_get_device_num(acc_get_device_type()) != x){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "devonly",
                            "internal-control-values",
                            "syntactic"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_num_devices.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,devonly,internal-control-values,syntactic,V:1.0-2.7\nint test1(){\n    int err = 0;\n\n    if(acc_get_device_type() != acc_device_none && acc_get_num_devices(acc_get_device_type()) == 0){ //Can't have zero of current device type\n          err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "devonly",
                            "internal-control-values",
                            "syntactic"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_property.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,devonly,syntactic,V:2.6-2.7\nint test1(){\n    int err = 0;\n\n    if (acc_get_device_type() != acc_device_none){\n        const char* returned_string1;\n        const char* returned_string2;\n        const char* returned_string3;\n        int returned_int;\n        returned_int = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_memory);\n        returned_int = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);\n        returned_string1 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_name);\n        returned_string2 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_vendor);\n        returned_string3 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_driver);\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "devonly",
                            "syntactic"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_hostptr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_ptr;\n\n    a_ptr = acc_create(a, n * sizeof(real_t));\n\n    if (a != acc_hostptr(acc_deviceptr(a))){\n        err += 1;\n    }\n\n    acc_delete(a, n * sizeof(real_t));\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_init.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,init,syntactic,V:2.5-2.7\nint test1(){\n    int err = 0;\n\n    if (acc_get_device_type() != acc_device_none){\n        acc_init(acc_get_device_type());\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "init",
                            "syntactic"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_is_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,devonly,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    #pragma acc enter data create(a[0:n])\n    if (acc_is_present(a, n * sizeof(real_t)) == 0){\n        err += 1;\n    }\n    #pragma acc exit data delete(a[0:n])\n\n    if (devtest[0] == 1){\n        if (acc_is_present(a, n * sizeof(real_t)) != 0){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_malloc.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,V:1.0-2.7\nint test1(){\n    int err = 0;\n    size_t initial_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);\n    int *a = (int *)acc_malloc(n * sizeof(int));\n\n    if (initial_memory == 0){\n        return err;\n    }\n    size_t final_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);\n    if (final_memory + n * sizeof(int) > initial_memory){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_map_data.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d;\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    d = (real_t *)acc_malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    acc_map_data(c, d, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc update host(c[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x]))> PRECISION){\n            err += 1;\n        }\n    }\n\n    acc_unmap_data(c);\n    acc_free(d);\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d;\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    d = (real_t *)acc_malloc(2 * n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    acc_map_data(c, d, n * sizeof(real_t));\n    acc_map_data(e, &(d[n]), n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n], e[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                e[x] = a[x] * b[x];\n            }\n        }\n    }\n\n    #pragma acc update host(c[0:n])\n    #pragma acc update host(e[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(e[x] - (a[x] * b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    acc_unmap_data(c);\n    acc_unmap_data(e);\n    acc_free(d);\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d;\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    d = (real_t *)acc_malloc(n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) deviceptr(d)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                d[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_map_data(c, d, n * sizeof(real_t));\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc update host(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - 2 * (a[x] + b[x])) > 2 * PRECISION){\n            err += 1;\n        }\n    }\n\n    acc_unmap_data(c);\n    acc_free(d);\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_memcpy_device.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *hostdata = (real_t *)malloc(3 * n * sizeof(real_t));\n    real_t *devdata;\n\n    for (int x = 0; x < n; ++x){\n        hostdata[x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[2*n + x] = 1;\n    }\n\n    devdata = acc_copyin(hostdata, 3 * n * sizeof(real_t));\n    #pragma acc enter data create(a[0:n], b[0:n], c[0:n])\n    acc_memcpy_device(a, devdata, n * sizeof(real_t));\n    acc_memcpy_device(b, devdata+n, n * sizeof(real_t));\n    acc_memcpy_device(c, devdata+2*n, n * sizeof(real_t));\n\n    #pragma acc data present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(a[0:n], b[0:n], c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - hostdata[x]) > PRECISION){\n            err += 1;\n        }\n        if (fabs(b[x] - hostdata[n + x]) > PRECISION){\n            err += 1;\n        }\n        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    #pragma acc exit data delete(hostdata[0:3*n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_memcpy_from_device.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *hostdata = (real_t *)malloc(3 * n * sizeof(real_t));\n    real_t *devdata;\n\n    for (int x = 0; x < n; ++x){\n        hostdata[x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[2*n + x] = 1;\n    }\n\n    devdata = acc_copyin(hostdata, 3 * n * sizeof(real_t));\n\n    #pragma acc data deviceptr(devdata)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[2*n + x] += devdata[x] + devdata[n + x];\n            }\n        }\n    }\n\n    acc_memcpy_from_device(a, devdata, n * sizeof(real_t));\n    acc_memcpy_from_device(b, &(devdata[n]), n * sizeof(real_t));\n    acc_memcpy_from_device(c, &(devdata[2*n]), n * sizeof(real_t));\n\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - hostdata[x]) > PRECISION){\n            err += 1;\n        }\n        if (fabs(b[x] - hostdata[n + x]) > PRECISION){\n            err += 1;\n        }\n        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    #pragma acc exit data delete(hostdata[0:3*n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_memcpy_from_device_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n    real_t *hostdata = (real_t *)malloc(6 * n * sizeof(real_t));\n    real_t *hostdata_copy = (real_t *)malloc(6 * n * sizeof(real_t));\n\n    real_t *devdata;\n\n    for (int x = 0; x < n; ++x){\n        hostdata[x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[2*n + x] = 1;\n        hostdata[3*n + x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[4*n + x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[5*n + x] = 2;\n    }\n\n    for (int x = 0; x < 6*n; ++x){\n        hostdata_copy[x] = hostdata[x];\n    }\n\n    devdata = acc_copyin(hostdata, 6 * n * sizeof(real_t));\n\n    #pragma acc data deviceptr(devdata)\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[x] = devdata[x] * devdata[x];\n            }\n        }\n        acc_memcpy_from_device_async(a, devdata, n * sizeof(real_t), 1);\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[n + x] = devdata[n + x] * devdata[n + x];\n            }\n        }\n        acc_memcpy_from_device_async(b, &(devdata[n]), n * sizeof(real_t), 2);\n        #pragma acc parallel async(4)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[3*n + x] = devdata[3*n + x] * devdata[3*n + x];\n            }\n        }\n        acc_memcpy_from_device_async(d, &(devdata[3*n]), n * sizeof(real_t), 4);\n        #pragma acc parallel async(5)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[4*n + x] = devdata[4*n + x] * devdata[4*n + x];\n            }\n        }\n        acc_memcpy_from_device_async(e, &(devdata[4*n]), n * sizeof(real_t), 5);\n        #pragma acc parallel async(3) wait(1, 2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[2*n + x] += devdata[x] + devdata[n + x];\n            }\n        }\n        acc_memcpy_from_device_async(c, &(devdata[2*n]), n * sizeof(real_t), 3);\n        #pragma acc parallel async(6) wait(4, 5)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[5*n + x] += devdata[3*n + x] + devdata[4*n + x];\n            }\n        }\n        acc_memcpy_from_device_async(f, &(devdata[5*n]), n * sizeof(real_t), 6);\n    }\n\n    #pragma acc wait(1)\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - hostdata_copy[x] * hostdata_copy[x]) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc wait(2)\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - hostdata_copy[n + x] * hostdata_copy[n + x]) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc wait(4)\n    for (int x = 0; x < n; ++x){\n        if (fabs(d[x] - hostdata_copy[3*n + x] * hostdata_copy[3*n + x]) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc wait(5)\n    for (int x = 0; x < n; ++x){\n        if (fabs(e[x] - hostdata_copy[4*n + x] * hostdata_copy[4*n + x]) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc wait(3)\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc wait(6)\n    for (int x = 0; x < n; ++x){\n        if (fabs(f[x] - (2 + d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    #pragma acc exit data delete(hostdata[0:6*n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_memcpy_to_device.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *hostdata = (real_t *)malloc(3 * n * sizeof(real_t));\n    real_t *devdata;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 1;\n    }\n\n    devdata = acc_create(hostdata, 3 * n * sizeof(real_t));\n\n    acc_memcpy_to_device(devdata, a, n * sizeof(real_t));\n    acc_memcpy_to_device(&(devdata[n]), b, n * sizeof(real_t));\n    acc_memcpy_to_device(&(devdata[2*n]), c, n * sizeof(real_t));\n\n    #pragma acc data deviceptr(devdata)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[2*n + x] += devdata[x] + devdata[n + x];\n            }\n        }\n    }\n    #pragma acc exit data copyout(hostdata[0:3*n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(hostdata[2 * n + x] - (1 + hostdata[n + x] + hostdata[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_memcpy_to_device_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e_host = (real_t *)malloc(n * sizeof(real_t));\n\n    real_t *hostdata = (real_t *)malloc(6 * n * sizeof(real_t));\n    real_t *devdata;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 1;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 2;\n\n        a_host[x] = a[x];\n        b_host[x] = b[x];\n        d_host[x] = d[x];\n        e_host[x] = e[x];\n    }\n\n    devdata = acc_create(hostdata, 6 * n * sizeof(real_t));\n\n    acc_memcpy_to_device_async(devdata, a, n * sizeof(real_t), 1);\n    acc_memcpy_to_device_async(&(devdata[n]), b, n * sizeof(real_t), 2);\n    acc_memcpy_to_device_async(&(devdata[2*n]), c, n * sizeof(real_t), 3);\n    acc_memcpy_to_device_async(&(devdata[3*n]), d, n * sizeof(real_t), 4);\n    acc_memcpy_to_device_async(&(devdata[4*n]), e, n * sizeof(real_t), 5);\n    acc_memcpy_to_device_async(&(devdata[5*n]), f, n * sizeof(real_t), 6);\n\n    #pragma acc data deviceptr(devdata)\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[x] = devdata[x] * devdata[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[n + x] = devdata[n + x] * devdata[n + x];\n            }\n        }\n        #pragma acc parallel async(4)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[3*n + x] = devdata[3*n + x] * devdata[3*n + x];\n            }\n        }\n        #pragma acc parallel async(5)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[4*n + x] = devdata[4*n + x] * devdata[4*n + x];\n            }\n        }\n        #pragma acc parallel async(3) wait(1, 2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[2*n + x] += devdata[x] + devdata[n + x];\n            }\n        }\n        #pragma acc parallel async(6) wait(4, 5)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[5*n + x] += devdata[3*n + x] + devdata[4*n + x];\n            }\n        }\n    }\n\n    #pragma acc update host(hostdata[2*n:n]) async(3)\n    #pragma acc update host(hostdata[5*n:n]) async(6)\n\n    #pragma acc wait(3)\n    for (int x = 0; x < n; ++x){\n        if (fabs(hostdata[2*n + x] - (1 + a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4 * PRECISION){\n            err += 1;\n        }\n    }\n\n    #pragma acc wait(6)\n    for (int x = 0; x < n; ++x){\n        if (fabs(hostdata[5*n + x] - (2 + d_host[x] * d_host[x] + e_host[x] * e_host[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    #pragma acc exit data delete(hostdata[0:6*n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_on_device.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    int device_type = acc_get_device_type();\n\n    if (device_type != acc_device_none){\n        #pragma acc data copy(err)\n        {\n            #pragma acc parallel\n            {\n                if (acc_on_device(device_type) == 0){\n                    err += 1;\n                }\n            }\n        }\n    }\n    else{\n        #pragma acc parallel\n        {\n            if (acc_on_device(acc_device_host) == 0){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_set_default_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,construct-independent,set,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        a_host[x] = a[x];\n        b_host[x] = b[x];\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        acc_set_default_async(1);\n        #pragma acc parallel async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] * a[x];\n            }\n        }\n        acc_set_default_async(2);\n        #pragma acc parallel async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] * b[x];\n            }\n        }\n        #pragma acc parallel async(1) wait(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc wait(1)\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4*PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "set"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_set_device_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,devonly,construct-independent,set,V:2.0-2.7\nint test1(){\n    int err = 0;\n\n    if (acc_get_device_type() != acc_device_none){\n        real_t **host_copy = (real_t **)malloc(acc_get_num_devices(acc_get_device_type()) * sizeof(real_t *));\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            host_copy[x] = (real_t *)malloc(n * sizeof(real_t));\n        }\n        real_t *a = (real_t *)malloc(n * sizeof(real_t));\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            for (int y = 0; y < n; ++y){\n                a[y] = rand() / (real_t)(RAND_MAX / 10);\n                host_copy[x][y] = a[y];\n            }\n            acc_set_device_num(x, acc_get_device_type());\n            #pragma acc enter data copyin(a[0:n])\n        }\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            acc_set_device_num(x, acc_get_device_type());\n            #pragma acc data present(a[0:n])\n            {\n                #pragma acc parallel\n                {\n                    #pragma acc loop\n                    for (int y = 0; y < n; ++y){\n                        a[y] = a[y] + 1;\n                    }\n                }\n            }\n        }\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            acc_set_device_num(x, acc_get_device_type());\n            #pragma acc exit data copyout(a[0:n])\n            for (int y = 0; y < n; ++y){\n                if (fabs(a[y] - (host_copy[x][y] + 1)) > PRECISION){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "devonly",
                            "construct-independent",
                            "set"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_set_device_type.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,internal-control-values,syntactic,V:2.0-2.7\nint test1(){\n    int err = 0;\n\n    int device_type = acc_get_device_type();\n\n    acc_set_device_type(device_type);\n    if (acc_get_device_type() != device_type){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "internal-control-values",
                            "syntactic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_shutdown.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,devonly,shutdown,V:2.0-2.7\nint test1(){\n    int err = 0;\n\n    if (acc_get_device_type() != acc_device_none){\n        acc_shutdown(acc_get_device_type());\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "devonly",
                            "shutdown"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_unmap_data.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d;\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    d = (real_t *)acc_malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    acc_map_data(c, d, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc update host(c[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x]))> PRECISION){\n            err += 1;\n        }\n    }\n\n    acc_unmap_data(c);\n    acc_free(d);\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d;\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    d = (real_t *)acc_malloc(2 * n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    acc_map_data(c, d, n * sizeof(real_t));\n    acc_map_data(e, &(d[n]), n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n], e[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                e[x] = a[x] * b[x];\n            }\n        }\n    }\n\n    #pragma acc update host(c[0:n])\n    #pragma acc update host(e[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(e[x] - (a[x] * b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    acc_unmap_data(c);\n    acc_unmap_data(e);\n    acc_free(d);\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d;\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    d = (real_t *)acc_malloc(n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) deviceptr(d)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                d[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_map_data(c, d, n * sizeof(real_t));\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc update host(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - 2 * (a[x] + b[x])) > 2 * PRECISION){\n            err += 1;\n        }\n    }\n\n    acc_unmap_data(c);\n    acc_free(d);\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_device.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc data copyout(c[0:n]) create(a[0:n], b[0:n])\n    {\n        acc_update_device(a, n * sizeof(real_t));\n        acc_update_device(b, n * sizeof(real_t));\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    a[x] = a[x] * a[x];\n                }\n            }\n            acc_update_device(a, n * sizeof(real_t));\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = b[x] * b[x];\n                }\n            }\n            acc_update_device(b, n * sizeof(real_t));\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_device_async.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        a_host[x] = a[x];\n        b_host[x] = b[x];\n    }\n\n\n\n    #pragma acc data copyout(c[0:n]) create(a[0:n], b[0:n])\n    {\n        acc_update_device_async(a, n * sizeof(real_t), 1);\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] * a[x];\n            }\n        }\n        acc_update_device_async(b, n * sizeof(real_t), 2);\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] * b[x];\n            }\n        }\n        #pragma acc parallel async(1) wait(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc wait(1)\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,async,devonly,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    a[x] = a[x] * a[x];\n                }\n            }\n            acc_update_device_async(a, n * sizeof(real_t), 1);\n            #pragma acc parallel async(2)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = b[x] * b[x];\n                }\n            }\n            acc_update_device_async(b, n * sizeof(real_t), 2);\n            #pragma acc parallel async(1) wait(2)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n            #pragma acc wait(1)\n        }\n\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_self.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc data create(c[0:n]) copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_update_self(c, n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] * a[x];\n            }\n        }\n        acc_update_self(a, n * sizeof(real_t));\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] * b[x];\n            }\n        }\n        acc_update_self(b, n * sizeof(real_t));\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_self_async.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = 0;\n    }\n\n\n\n    #pragma acc data create(c[0:n], d[0:n]) copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                d[x] = a[x] * b[x];\n            }\n        }\n        acc_update_self_async(c, n * sizeof(real_t), 1);\n        acc_update_self_async(d, n * sizeof(real_t), 2);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(d[x] - (a[x] * b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7\nint test2(){\n\tint err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    a[x] = a[x] * a[x];\n                }\n            }\n            acc_update_self_async(a, n * sizeof(real_t), 1);\n            #pragma acc parallel async(2)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = b[x] * b[x];\n                }\n            }\n            acc_update_self_async(b, n * sizeof(real_t), 2);\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    a[x] = a[x] + 1;\n                }\n            }\n            #pragma acc parallel async(2)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = b[x] + 1;\n                }\n            }\n            #pragma acc parallel async(1) wait(2)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] * b[x];\n                }\n            }\n            #pragma acc wait(1)\n        }\n\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - ((a[x] + 1) * (b[x] + 1))) > 4 * PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,construct-independent,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n]) async(1)\n    #pragma acc enter data copyin(d[0:n]) create(e[0:n]) async(2)\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1) wait(2)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            e[x] = c[x] + d[x];\n        }\n    }\n    #pragma acc exit data copyout(e[0:n]) async(1)\n\n    acc_wait(1);\n    for (int x = 0; x < n; ++x){\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n], c[0:n], d[0:n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait_all.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,construct-independent,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n        d[x] = 0;\n        a_host[x] = a[x];\n        b_host[x] = b[x];\n        c_host[x] = c[x];\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] * a[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] * b[x];\n            }\n        }\n        #pragma acc parallel async(3)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = c[x] * c[x];\n            }\n        }\n        acc_wait_all();\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                d[x] = a[x] + b[x] + c[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(d[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x] + c_host[x] * c_host[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait_all_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,construct-independent,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n    real_t *g = (real_t *)malloc(n * sizeof(real_t));\n    real_t *h = (real_t *)malloc(n * sizeof(real_t));\n    real_t *i = (real_t *)malloc(n * sizeof(real_t));\n    real_t *j = (real_t *)malloc(n * sizeof(real_t));\n    real_t *k = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *g_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n        g[x] = rand() / (real_t)(RAND_MAX / 10);\n        h[x] = rand() / (real_t)(RAND_MAX / 10);\n        i[x] = 0;\n        j[x] = 0;\n        k[x] = 0;\n        a_host[x] = a[x];\n        d_host[x] = d[x];\n        g_host[x] = g[x];\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], g[0:n], h[0:n]) create(c[0:n], f[0:n], i[0:n], j[0:n]) copyout(k[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        #pragma acc parallel async(3)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                i[x] = g[x] + h[x];\n            }\n        }\n        acc_wait_all_async(4);\n        #pragma acc parallel async(4)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                j[x] = c[x] + f[x] + i[x];\n            }\n        }\n        #pragma acc parallel async(1)\n        {\n            for (int x = 0; x < n; ++x){\n                a[x] = b[x] * c[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            for (int x = 0; x < n; ++x){\n                d[x] = e[x] * f[x];\n            }\n        }\n        #pragma acc parallel async(3)\n        {\n            for (int x = 0; x < n; ++x){\n                g[x] = h[x] * i[x];\n            }\n        }\n        acc_wait_all_async(4);\n        #pragma acc parallel async(4)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                k[x] = j[x] + a[x] + d[x] + g[x];\n            }\n        }\n        #pragma acc wait(4)\n    }\n\n    real_t temp;\n    for (int x = 0; x < n; ++x){\n        temp = a_host[x] + b[x] + d_host[x] + e[x] + g_host[x] + h[x];\n        temp += b[x] * (a_host[x] + b[x]) + e[x] * (d_host[x] + e[x]) + h[x] * (g_host[x] + h[x]);\n        if (fabs(k[x] - temp) > PRECISION * 10){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,construct-independent,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n    real_t *g = (real_t *)malloc(n * sizeof(real_t));\n    real_t *h = (real_t *)malloc(n * sizeof(real_t));\n    real_t *i = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n        g[x] = rand() / (real_t)(RAND_MAX / 10);\n        h[x] = 0;\n        i[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], g[0:n]) create(c[0:n], f[0:n], h[0:n]) copyout(i[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_wait_async(1, 2);\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                h[x] = c[x] + g[x];\n            }\n        }\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        acc_wait_async(1, 2);\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                i[x] = h[x] + f[x];\n            }\n        }\n        #pragma acc wait(2)\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(i[x] - (a[x] + b[x] + g[x] + d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_bitand_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n        }\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] &= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_bitor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] |= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_bitxor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] ^= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_bitand_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            b[x] += 1<<y;\n        }\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    b[x] = totals[x%(n/10 + 1)] &= a[x];\n            }\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        for (iterator = x, iterator2 = 0; iterator < n; iterator += n/10 + 1, iterator2++){\n            temp_a[iterator2] = a[iterator];\n            temp_b[iterator2] = b[iterator];\n        }\n        if (!is_possible(temp_a, temp_b, iterator2, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_bitor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int temp_indexer = 0;\n    int absolute_indexer = 0;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    b[x] = totals[x%(n/10 + 1)] |= a[x];\n            }\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < (n/10 + 1); ++x){\n        for (absolute_indexer = x, temp_indexer = 0; absolute_indexer < n; absolute_indexer += n/10 + 1, temp_indexer++){\n            temp_a[temp_indexer] = a[absolute_indexer];\n            temp_b[temp_indexer] = b[absolute_indexer];\n        }\n        if (!(is_possible(temp_a, temp_b, temp_indexer, 0))){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_bitxor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int * temp_a = (int *)malloc(10 * sizeof(int));\n    int * temp_b = (int *)malloc(10 * sizeof(int));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    b[x] = totals[x%(n/10 + 1)] ^= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (temp_iterator = 0, ab_iterator = x; ab_iterator < n; temp_iterator++, ab_iterator += n/10 + 1){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n        }\n        if (!(is_possible(temp_a, temp_b, temp_iterator, 0))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_divided_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%(n/10 + 1)] /= (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < (n/10 + 1); ++x){\n        temp_iterator = 0;\n        for (ab_iterator = x; ab_iterator < n;  ab_iterator+=((n/10) + 1)){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n            temp_c[temp_iterator] = c[ab_iterator];\n            temp_iterator++;\n        }\n        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_bitand_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *passed_a = (int *)malloc(10 * sizeof(int));\n    int *passed_b = (int *)malloc(10 * sizeof(int));\n    int passed_total = 0;\n    int absolute_indexer;\n    int passed_indexer;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                     b[x] = totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 8; ++x){\n        passed_total += 1<<x;\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        for (absolute_indexer = x, passed_indexer = 0; absolute_indexer < n; absolute_indexer += (n/10 + 1), passed_indexer++){\n            passed_a[passed_indexer] = a[absolute_indexer];\n            passed_b[passed_indexer] = b[absolute_indexer];\n        }\n        if (!is_possible(passed_a, passed_b, passed_indexer - 1, passed_total)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_bitor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *passed_a = (int *)malloc(10 * sizeof(int));\n    int *passed_b = (int *)malloc(10 * sizeof(int));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    b[x] = totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_a[passed_indexer] = a[absolute_indexer];\n            passed_b[passed_indexer] = b[absolute_indexer];\n        }\n        if (!is_possible(passed_a, passed_b, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_bitxor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *passed_a = (int *)malloc(10 * sizeof(int));\n    int *passed_b = (int *)malloc(10 * sizeof(int));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    b[x] = totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_a[passed_indexer] = a[absolute_indexer];\n            passed_b[passed_indexer] = b[absolute_indexer];\n        }\n        if (!(is_possible(passed_a, passed_b, passed_indexer - 1, 0))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_divided_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));\n    int indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n\n    for (int x = 0; x < (n/10 + 1); ++x){\n        indexer = x;\n        while (indexer < n){\n            passed[indexer/(n/10 + 1)] = (a[x] + b[x]);\n            indexer += (n/10 + 1);\n        }\n        if (!(possible_result(passed, 10, 1, totals[x]))){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < (n/10 + 1); ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_lshift_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(3 * n * sizeof(int));\n    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};\n    int result;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 3; ++y){\n            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n]) copyout(c[0:3*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 3; ++y){\n                    #pragma acc atomic capture\n                        c[x * 3 + y] = b[x] = a[x * 3 + y] << b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 6; ++y){\n            result = 0;\n            for (int z = 0; z < 3; ++z){\n                result = a[x * 3 + orders[y * 3 + z]] << result;\n            }\n            if (result == b[x]){\n                break;\n            }\n        }\n        if (result != b[x]){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!(is_possible(&(a[x*3]), &(c[x*3]), 3, 0))){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_minus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(((n/10) + 1) * sizeof(real_t));\n    int indexer = 0;\n    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_b = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < (n/10) + 1; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    b[x] = totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];\n            }\n        }\n    }\n    for (int x = 0; x < (n/10) + 1; ++x){\n        indexer = x;\n        while (indexer < n){\n            passed[indexer/((int) (n/10) + 1)] = a[indexer];\n            indexer += (n/10) + 1;\n        }\n        if (!(possible_result(passed, 10, 0, totals[x]))){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_a[passed_indexer] = a[absolute_indexer];\n            passed_b[passed_indexer] = b[absolute_indexer];\n        }\n        if (!is_possible(passed_a, passed_b, passed_indexer - 1, 0)){\n            err += 1;\n        }\n        break;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_multiply_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_plus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((int)(n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((int)(n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%((int)(n/10 + 1))] = (a[x] + b[x]) + totals[x%((int) n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%((int)(n/10 + 1))] += (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_rshift_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(3 * n * sizeof(int));\n    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};\n    int result;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 3; ++y){\n            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n]) copyout(c[0:3*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop independent\n                for (int y = 0; y < 3; ++y){\n                    #pragma acc atomic capture\n                        c[x * 3 + y] = b[x] = a[x * 3 + y] >> b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 6; ++y){\n            result = 0;\n            for (int z = 0; z < 3; ++z){\n                result = a[x * 3 + orders[y * 3 + z]] >> result;\n            }\n            if (result == b[x]){\n                break;\n            }\n        }\n        if (result != b[x]){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(&(a[3*x]), &(c[3*x]), 3, 0)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_lshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic capture\n                            c[x * 7 + y] = a[x] <<= 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_minus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%10] -= (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_multiply_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%(n/10 + 1)] *= a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_plus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%(n/10 + 1)] += a[x] * b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_postdecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = (distribution[(int) (a[x]*b[x]/10)])--;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    bool found = false;\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y > -distribution_comparison[x]; --y){\n            for (int z = 0; z < n; ++z){\n                if (y == c[z] && x == (int) (a[x] * b[x] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_postincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = distribution[(int) (a[x]*b[x]/10)]++;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]++;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    bool found = false;\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < distribution_comparison[x]; ++y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y && (int) (a[z]*b[z]/10) == x){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_predecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = --distribution[(int) (a[x]*b[x]/10)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    bool found = false;\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y > distribution[x]; --y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y - 1 && x == (int) (a[z] * b[z] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_preincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = ++distribution[(int) (a[x]*b[x]/10)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]++;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    bool found = false;\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < distribution[x]; ++y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y + 1 && x == (int) (a[z] * b[z] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_rshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1<<8;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<8;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic capture\n                            c[x * 7 + y] = a[x] >>= 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<8){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_divided_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] /= (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_bitand_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_bitor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_bitxor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_divided_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));\n    int indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n\n    for (int x = 0; x < (n/10 + 1); ++x){\n        indexer = x;\n        while (indexer < n){\n            passed[indexer/(n/10 + 1)] = (a[x] + b[x]);\n            indexer += (n/10 + 1);\n        }\n        if (!(possible_result(passed, 10, 1, totals[x]))){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_lshift_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};\n    int result;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 3; ++y){\n            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 3; ++y){\n                    #pragma acc atomic\n                        b[x] = a[x * 3 + y] << b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 6; ++y){\n            result = 0;\n            for (int z = 0; z < 3; ++z){\n                result = a[x * 3 + orders[y * 3 + z]] << result;\n            }\n            if (result == b[x]){\n                break;\n            }\n        }\n        if (result != b[x]){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_minus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(((n/10) + 1) * sizeof(real_t));\n    int indexer = 0;\n    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < (n/10) + 1; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];\n            }\n        }\n    }\n    for (int x = 0; x < (n/10) + 1; ++x){\n        indexer = x;\n        while (indexer < n){\n            passed[indexer/((int) (n/10) + 1)] = a[indexer];\n            indexer += (n/10) + 1;\n        }\n        if (!(possible_result(passed, 10, 0, totals[x]))){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_multiply_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_plus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic\n                        totals[(int) ((a[x] + b[x])/2)] = a[x] * b[x] + totals[(int) ((a[x] + b[x])/2)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] != totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_rshift_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};\n    int result;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 3; ++y){\n            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop independent\n                for (int y = 0; y < 3; ++y){\n                    #pragma acc atomic\n                        b[x] = a[x * 3 + y] >> b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 6; ++y){\n            result = 0;\n            for (int z = 0; z < 3; ++z){\n                result = a[x * 3 + orders[y * 3 + z]] >> result;\n            }\n            if (result == b[x]){\n                break;\n            }\n        }\n        if (result != b[x]){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_lshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic\n                            a[x] <<= 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_minus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%10] -= (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_multiply_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] *= a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_plus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] += a[x] * b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > (n/10 + 1) * PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_postdecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    distribution[(int) (a[x] * b[x] / 10)]--;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_postincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic\n                        distribution[(int) (a[x]*b[y]/10)]++;\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            distribution_comparison[(int) (a[x]*b[y]/10)]++;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_predecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic\n                        --distribution[(int) (a[x]*b[y]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            distribution_comparison[(int) (a[x]*b[y]/10)]--;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_preincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic\n                        ++distribution[(int) (a[x]*b[y]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            distribution_comparison[(int) (a[x]*b[y]/10)]++;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_rshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<7;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic\n                            a[x] >>= 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<7){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_copy = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        b_copy[x] = b[x];\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = b[x];\n                    b[x] = a[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (abs(c[x] - b_copy[x]) > PRECISION){\n            err++;\n        }\n        if (abs(b[x] - a[x]) > PRECISION){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_bitand_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] &= a[x];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        int y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, y - x, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_bitor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] |= a[x];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] |= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_bitxor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] ^= a[x];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] ^= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_divided_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x/10];\n                    totals[x/10] /= (a[x] + b[x]);\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        temp_iterator = 0;\n        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n            temp_c[temp_iterator] = c[ab_iterator];\n            temp_iterator++;\n        }\n        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_expr_bitand_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] = a[x] & totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        int y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, y - x, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_expr_bitor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] = a[x] | totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] |= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_expr_bitxor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] = a[x] ^ totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] ^= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_expr_divided_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t* passed_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t* passed_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x/10];\n                    totals[x/10] = (a[x] + b[x]) / totals[x/10];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        for (int y = 0; y < 10 && (x + y) < n; ++y){\n            passed_a[y] = a[x + y];\n            passed_b[y] = b[x + y];\n        }\n        if (!(is_possible_2(passed_a, passed_b, 10, 1, totals[x/10]))){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        temp_iterator = 0;\n        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n            temp_c[temp_iterator] = c[ab_iterator];\n            temp_iterator++;\n        }\n        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_expr_multiply_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%(n/10 + 1)];\n                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_expr_plus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%(n/10 + 1)];\n                    totals[x%(n/10 + 1)] = (a[x] * b[x]) + totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_lshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            c[x * 7 + y] = a[x];\n                            a[x] <<= 1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_minus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%10];\n                    totals[x%10] -= (a[x] + b[x]);\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_multiply_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%(n/10 + 1)];\n                    totals[x%(n/10 + 1)] *= a[x] + b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_plus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%(n/10 + 1)];\n                    totals[x%(n/10 + 1)] += a[x] * b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_postdecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                    (distribution[(int) (a[x]*b[x]/10)])--;\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y > -distribution_comparison[x]; --y){\n            for (int z = 0; z < n; ++z){\n                if (y == c[z] && x == (int) (a[x] * b[x] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_postincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                    distribution[(int) (a[x]*b[x]/10)]++;\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]++;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < distribution_comparison[x]; ++y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y && (int) (a[z]*b[z]/10) == x){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_predecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                    --distribution[(int) (a[x]*b[x]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y > distribution[x]; --y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y && x == (int) (a[z] * b[z] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_preincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                    ++distribution[(int) (a[x]*b[x]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]++;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < distribution[x]; ++y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y && x == (int) (a[z] * b[z] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_rshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1<<8;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<8;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            c[x * 7 + y] = a[x];\n                            a[x] >>= 1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<8){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_bitand_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] = totals[x/10] & a[x];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        int y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, y - x, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_bitor_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n    int y;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] = totals[x/10] | a[x];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] |= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_bitxor_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n    int y;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] = totals[x/10] ^ a[x];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] ^= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_divided_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x/10];\n                    totals[x/10] = totals[x/10] / (a[x] + b[x]);\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        temp_iterator = 0;\n        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n            temp_c[temp_iterator] = c[ab_iterator];\n            temp_iterator++;\n        }\n        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_lshift_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            c[x * 7 + y] = a[x];\n                            a[x] = a[x] << 1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_minus_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%10];\n                    totals[x%10] = totals[x%10] - (a[x] + b[x]);\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_multiply_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%(n/10 + 1)];\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_plus_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%(n/10 + 1)];\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] + (a[x] * b[x]);\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_rshift_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1<<8;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<8;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            c[x * 7 + y] = a[x];\n                            a[x] = a[x] >> 1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<8){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_bitand_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] &= a[x];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        int y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, y - x, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_bitor_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] |= a[x];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] |= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_bitxor_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] ^= a[x];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] ^= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_divided_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n      #pragma acc parallel\n      {\n          #pragma acc loop\n          for (int x = 0; x < n; ++x){\n              #pragma acc atomic update capture\n              {\n                  totals[x/10] /= (a[x] + b[x]);\n                  c[x] = totals[x/10];\n              }\n          }\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        temp_iterator = 0;\n        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n            temp_c[temp_iterator] = c[ab_iterator];\n            temp_iterator++;\n        }\n        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_expr_bitand_x_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] = a[x] & totals[x/10];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        int y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, y - x, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_expr_bitor_x_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] = a[x] | totals[x/10];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] |= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_expr_bitxor_x_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n    int y;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] = a[x] ^ totals[x/10];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] ^= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_expr_multiply_x_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];\n                    c[x] = totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_expr_plus_x_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%(n/10 + 1)] = (a[x] * b[x]) + totals[x%(n/10 + 1)];\n                    c[x] = totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_lshift_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            a[x] <<= 1;\n                            c[x * 7 + y] = a[x];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_minus_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%10] -= (a[x] + b[x]);\n                    c[x] = totals[x%10];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_multiply_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%(n/10 + 1)] *= a[x] + b[x];\n                    c[x] = totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_plus_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%(n/10 + 1)] += a[x] * b[x];\n                    c[x] = totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_postdecrement_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    (distribution[(int) (a[x]*b[x]/10)])--;\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y > -distribution_comparison[x]; --y){\n            for (int z = 0; z < n; ++z){\n                if (y - 1 == c[z] && x == (int) (a[x] * b[x] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_postincrement_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    distribution[(int) (a[x]*b[x]/10)]++;\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]++;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < distribution_comparison[x]; ++y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y + 1 && (int) (a[z]*b[z]/10) == x){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_predecrement_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    --distribution[(int) (a[x]*b[x]/10)];\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y > distribution[x]; --y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y - 1 && x == (int) (a[z] * b[z] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_preincrement_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    ++distribution[(int) (a[x]*b[x]/10)];\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]++;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < distribution[x]; ++y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y + 1 && x == (int) (a[z] * b[z] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_rshift_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1<<8;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<8;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            a[x] >>= 1;\n                            c[x * 7 + y] = a[x];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<8){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_bitand_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] = totals[x/10] & a[x];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        int y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, y - x, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_bitor_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] = totals[x/10] | a[x];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] |= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_bitxor_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] = totals[x/10] ^ a[x];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] ^= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_divided_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x/10] = totals[x/10] / (a[x] + b[x]);\n                    c[x] = totals[x/10];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        temp_iterator = 0;\n        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n            temp_c[temp_iterator] = c[ab_iterator];\n            temp_iterator++;\n        }\n        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_lshift_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            a[x] = a[x] << 1;\n                            c[x * 7 + y] = a[x];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_minus_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%10] = totals[x%10] - (a[x] + b[x]);\n                    c[x] = totals[x%10];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_multiply_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);\n                    c[x] = totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_plus_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] + (a[x] * b[x]);\n                    c[x] = totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_rshift_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1<<8;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<8;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            a[x] = a[x] >> 1;\n                            c[x * 7 + y] = a[x];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<8){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_bitand_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] &= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_bitor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] |= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_bitxor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] ^= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_divided_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] /= (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_bitand_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_bitor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_bitxor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_divided_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));\n    int indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n\n    for (int x = 0; x < (n/10 + 1); ++x){\n        indexer = x;\n        while (indexer < n){\n            passed[indexer/(n/10 + 1)] = (a[x] + b[x]);\n            indexer += (n/10 + 1);\n        }\n        if (!(possible_result(passed, 10, 1, totals[x]))){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_lshift_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};\n    int result;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 3; ++y){\n            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 3; ++y){\n                    #pragma acc atomic update\n                        b[x] = a[x * 3 + y] << b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 6; ++y){\n            result = 0;\n            for (int z = 0; z < 3; ++z){\n                result = a[x * 3 + orders[y * 3 + z]] << result;\n            }\n            if (result == b[x]){\n                break;\n            }\n        }\n        if (result != b[x]){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_minus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(((n/10) + 1) * sizeof(real_t));\n    int indexer = 0;\n    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < (n/10) + 1; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];\n            }\n        }\n    }\n    for (int x = 0; x < (n/10) + 1; ++x){\n        indexer = x;\n        while (indexer < n){\n            passed[indexer/((int) (n/10) + 1)] = a[indexer];\n            indexer += (n/10) + 1;\n        }\n        if (!(possible_result(passed, 10, 0, totals[x]))){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_multiply_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_plus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic update\n                        totals[(int) ((a[x] + b[x])/2)] = a[x] * b[x] + totals[(int) ((a[x] + b[x])/2)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > 10 * PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_rshift_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};\n    int result;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 3; ++y){\n            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop independent\n                for (int y = 0; y < 3; ++y){\n                    #pragma acc atomic update\n                        b[x] = a[x * 3 + y] >> b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 6; ++y){\n            result = 0;\n            for (int z = 0; z < 3; ++z){\n                result = a[x * 3 + orders[y * 3 + z]] >> result;\n            }\n            if (result == b[x]){\n                break;\n            }\n        }\n        if (result != b[x]){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_lshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update\n                            a[x] <<= 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_minus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%10] -= (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_multiply_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] *= a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_plus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] += a[x] * b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > (n/10 + 1) * PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_postdecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    distribution[(int) (a[x] * b[x] / 10)]--;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_postincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic update\n                        distribution[(int) (a[x]*b[y]/10)]++;\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            distribution_comparison[(int) (a[x]*b[y]/10)]++;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_predecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic update\n                        --distribution[(int) (a[x]*b[y]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            distribution_comparison[(int) (a[x]*b[y]/10)]--;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_preincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic update\n                        ++distribution[(int) (a[x]*b[y]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            distribution_comparison[(int) (a[x]*b[y]/10)]++;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_rshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<7;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update\n                            a[x] >>= 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<7){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_bitand_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] & a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_bitor_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_bitxor_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] =  totals[x%(n/10 + 1)] ^ a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_divided_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] / (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_lshift_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update\n                            a[x] = a[x] << 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_minus_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%10] = totals[x%10] - (a[x] + b[x]);\n            }\n        }\n    }\n\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_multiply_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_plus_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic update\n                        totals[(int) ((a[x] + b[x])/2)] = totals[(int) ((a[x] + b[x])/2)] + a[x] * b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_rshift_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<7;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update\n                            a[x] = a[x] >> 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<7){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_bitand_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] & a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_bitor_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_bitxor_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] =  totals[x%(n/10 + 1)] ^ a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_divided_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] / (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_lshift_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic\n                            a[x] = a[x] << 1;\n                    }\n                }\n            }\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_minus_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%10] = totals[x%10] - (a[x] + b[x]);\n            }\n        }\n    }\n\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_multiply_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_plus_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic\n                        totals[(int) ((a[x] + b[x])/2)] = totals[(int) ((a[x] + b[x])/2)] + a[x] * b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_rshift_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<7;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic\n                            a[x] = a[x] >> 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<7){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copy_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copyin_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[:n], b[:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copyout_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copyout_reference_counts.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,reference-counting,devonly,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n\n    if (devtest[0] == 1) {\n        #pragma acc data copyin(c[0:n])\n        {\n            #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n            {\n                #pragma acc parallel\n                {\n                    #pragma acc loop\n                    for (int x = 0; x < n; ++x){\n                        c[x] += a[x] + b[x];\n                    }\n                }\n            }\n            for (int x = 0; x < n; ++x){\n                if (fabs(c[x]) > PRECISION){\n                    err += 1;\n                    break;\n                }\n            }\n        }\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err += 1;\n                break;\n            }\n        }\n\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "reference-counting",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,data-region,reference-counting,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err += 1;\n                break;\n            }\n        }\n    }\n    #pragma acc exit data copyout(c[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "reference-counting",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:data,data-region,construct-independent,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n        #pragma acc exit data delete(c[0:n])\n    }\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_create.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc data create(b[0:n])\n    {\n        #pragma acc data copyin(a[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n        #pragma acc data copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION) {\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,data-region,construct-independent,compatibility-features,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc data present_or_create(b[0:n])\n    {\n        #pragma acc data copyin(a[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n        #pragma acc data copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION) {\n            err += 2;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:data,data-region,construct-independent,compatibility-features,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc data pcreate(b[0:n])\n    {\n        #pragma acc data copyin(a[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n        #pragma acc data copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION){\n            err += 4;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_create_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(n * sizeof(real_t));\n    real_t * e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[:n]) copyout(e[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                e[x] = c[x] + d[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_present_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_with_changing_subscript.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int length = n;\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:length], b[0:length]) copyout(c[0:length])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < length; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        length = 1;\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_with_structs.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    multi_item * a = (multi_item *)malloc(n * sizeof(multi_item));\n\n    for (int x = 0; x < n; ++x){\n        a[x].a = rand() / (real_t)(RAND_MAX / 10);\n        a[x].b = rand() / (real_t)(RAND_MAX / 10);\n        a[x].c = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x].c = a[x].a + a[x].b;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x].c - (a[x].a + a[x].b)) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_copyin.c": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + fixed_size_array[x%10];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + fixed_size_array[x%10])) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(scalar)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + scalar;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + scalar)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 1; ++x){\n                extern_multiplyData_copyin(a, n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:declare,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 1; ++x){\n                multiplyData(a);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:declare,construct-independent,attach,V:2.6-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    datapointer = a;\n    #pragma acc enter data copyin(a[0:n]) attach(datapointer)\n    #pragma acc data present(datapointer[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                datapointer[x] = datapointer[x] * 2;\n            }\n        }\n    }\n    #pragma acc exit data copyout(a[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "attach"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_create.c": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n    #pragma acc update device(n)\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 10; ++x){\n                fixed_size_array[x] = x*x;\n            }\n        }\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + fixed_size_array[x%10];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + (x%10) * (x%10))) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n    #pragma acc update device(n)\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    scalar = 10;\n    #pragma acc update device(scalar)\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + scalar;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + 10)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n    #pragma acc update device(n)\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc update device(mult_create)\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 1; ++x){\n                extern_multiplyData_create(a, n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:declare,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n    #pragma acc update device(n)\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 1; ++x){\n                multiplyData(a);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:declare,construct-independent,V:2.6-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n    #pragma acc update device(n)\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n    datapointer = a;\n\n    #pragma acc data copyin(a[0:n]) attach(datapointer)\n    {\n        #pragma acc parallel present(datapointer[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                datapointer[x] = datapointer[x] * 2;\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(a[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_device_resident.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    #pragma acc parallel\n    {\n      mult_device_resident = 2;\n      scalar = 10;\n      for (int x = 0; x < 10; ++x){\n        fixed_size_array[x] = x*x;\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 10; ++x){\n                fixed_size_array[x] = x*x;\n            }\n        }\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + fixed_size_array[x%10];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + (x%10) * (x%10))) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    #pragma acc parallel\n    {\n      mult_device_resident = 2;\n      scalar = 10;\n      for (int x = 0; x < 10; ++x){\n        fixed_size_array[x] = x*x;\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + scalar;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + 10)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    #pragma acc parallel\n    {\n      mult_device_resident = 2;\n      scalar = 10;\n      for (int x = 0; x < 10; ++x){\n        fixed_size_array[x] = x*x;\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 1; ++x){\n                extern_multiplyData_device_resident(a, n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_copy.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 1;\n        }\n    }\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            copyin_copyout_test(a[x], b[x], c[x]);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 2;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            #pragma acc data copy(c[x:1][0:n])\n            {\n                copyin_copyout_test(a[x], b[x], c[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (2 + a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,devonly,reference-counting,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 3;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copyin(c[x:1][0:n])\n                {\n                    copyin_copyout_test(a[x], b[x], c[x]);\n                    for (int y = 0; y < n; ++y){\n                        if (fabs(c[x][y] - 3) > PRECISION){\n                            err += 1;\n                        }\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - 3) > PRECISION){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:declare,construct-independent,devonly,reference-counting,V:2.5-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[1] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 4;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copy(c[x:1][0:n])\n                {\n                    copyin_copyout_test(a[x], b[x], c[x]);\n                    for (int y = 0; y < n; ++y){\n                        if (fabs(c[x][y] - 4) > PRECISION){\n                            err += 1;\n                        }\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - (4 + a[x][y] + b[x][y])) > PRECISION){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_copyin.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 1;\n        }\n    }\n\n    #pragma acc data copy(c[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            function_test(a[x], b[x], c[x]);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,devonly,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t ** a_host = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** b_host = (real_t **)malloc(n * sizeof(real_t *));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a_host[x] = (real_t *)malloc(n * sizeof(real_t));\n            b_host[x] = (real_t *)malloc(n * sizeof(real_t));\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                a_host[x][y] = a[x][y];\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b_host[x][y] = b[x][y];\n                c[x][y] = 0;\n            }\n        }\n\n        #pragma acc data copy(a[0:n][0:n], b[0:n][0:n], c[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                function_test_dev_only(a[x], b[x], c[x]);\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                if (fabs(a[x][y] + 1) > PRECISION){\n                    err += 1;\n                }\n                if (fabs(b[x][y] + 1) > PRECISION){\n                    err += 1;\n                }\n                if (fabs(c[x][y] - (a_host[x][y] + b_host[x][y])) > PRECISION){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,devonly,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t ** a_host = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** b_host = (real_t **)malloc(n * sizeof(real_t *));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                a_host[x][y] = a[x][y];\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b_host[x][y] = b[x][y];\n                c[x][y] = 1;\n            }\n        }\n\n        #pragma acc data copy(c[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                function_test_dev_only(a[x], b[x], c[x]);\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                if (fabs(a[x][y] - a_host[x][y]) > PRECISION){\n                    err += 1;\n                }\n                if (fabs(b[x][y] - b_host[x][y]) > PRECISION){\n                    err += 1;\n                }\n                if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_copyout.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 1;\n        }\n    }\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            copyout_test(a[x], b[x], c[x]);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 2;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            #pragma acc data copy(c[x:1][0:n])\n            {\n                copyout_test(a[x], b[x], c[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,devonly,reference-counting,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 3;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copyin(c[x:1][0:n])\n                {\n                    copyout_test(a[x], b[x], c[x]);\n                    for (int y = 0; y < n; ++y){\n                        if (fabs(c[x][y] - 3) > PRECISION){\n                            err += 1;\n                        }\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - 3) > PRECISION){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:declare,construct-independent,devonly,reference-counting,V:2.5-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 4;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copy(c[x:1][0:n])\n                {\n                    copyout_test(a[x], b[x], c[x]);\n                    for (int y = 0; y < n; ++y){\n                        if (fabs(c[x][y] - 4) > PRECISION){\n                            err += 1;\n                        }\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_create.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        d[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 1;\n            d[x][y] = 0;\n        }\n    }\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copyout(d[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            create_test(a[x], b[x], c[x], d[x]);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(d[x][y] - (a[x][y] * (a[x][y] + b[x][y]))) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 2;\n            d[x][y] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copy(c[0:n][0:n]) copyout(d[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            create_as_present(a[x], b[x], c[x], d[x]);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (2 + a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n            if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,devonly,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 3;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copyin(c[x:1][0:n]) copyout(d[x:1][0:n])\n                {\n                    create_as_present(a[x], b[x], c[x], d[x]);\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - 3) > PRECISION){\n                        err += 1;\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 2){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_deviceptr.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,runtime,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** devpointer_c = (real_t **)malloc(n * sizeof(real_t *));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        d[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 1;\n            d[x][y] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copy(c[0:n][0:n]) copyout(d[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            devpointer_c[x] = acc_deviceptr(c[x]);\n            declare_deviceptr(a[x], b[x], devpointer_c[x], d[x]);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n            if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,runtime,construct-independent,devonly,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** devpointer_c = (real_t **)malloc(n * sizeof(real_t *));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 3;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copyout(d[x:1][0:n])\n                {\n                    devpointer_c[x] = acc_copyin(c[x], n * sizeof(real_t));\n                    declare_deviceptr(a[x], b[x], devpointer_c[x], d[x]);\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - 3) > PRECISION){\n                        err += 1;\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 10){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "runtime",
                            "construct-independent",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_present.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,present,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        d[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 1;\n            d[x][y] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copyout(d[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            #pragma acc data copy(c[x:1][0:n])\n            {\n                present(a[x], b[x], c[x], d[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n            if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "present",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,present,devonly,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 3;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copyin(c[x:1][0:n]) copyout(d[x:1][0:n])\n                {\n                    present(a[x], b[x], c[x], d[x]);\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - 3) > PRECISION){\n                        err += 1;\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 2){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "present",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_data_copyin_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,syntactic,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[:n], b[:n]) create(c[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "syntactic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_data_create.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data create(b[0:n])\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel present(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = b[x];\n            }\n        }\n    }\n    #pragma acc exit data delete(b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION) {\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,executable-data,construct-independent,compatibility-features,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data present_or_create(b[0:n])\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel present(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = b[x];\n            }\n        }\n    }\n    #pragma acc exit data delete(b[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION) {\n            err += 2;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:data,executable-data,construct-independent,compatibility-features,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data pcreate(b[0:n])\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel present(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = b[x];\n            }\n        }\n    }\n    #pragma acc exit data delete(b[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION){\n            err += 4;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_data_create_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,syntactic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "syntactic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_exit_data_if.c": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,construct-independent,if,reference-counting,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int dev = 1;\n    int host = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) if(dev)\n    #pragma acc data create(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) if(dev)\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent",
                            "if",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,executable-data,construct-independent,if,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int dev = 1;\n    int host = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(a[0:n], b[0:n]) if(host)\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) if(host)\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:data,executable-data,construct-independent,devonly,if,reference-counting,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int dev = 1;\n    int host = 0;\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            a_copy[x] = a[x];\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            b_copy[x] = b[x];\n            c[x] = 0.0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n]) if(dev)\n        for (int x = 0; x < n; ++x){\n            a[x] = 0;\n            b[x] = 0;\n        }\n        #pragma acc data create(a[0:n], b[0:n]) copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n        #pragma acc exit data copyout(a[0:n], b[0:n]) if(dev)\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent",
                            "devonly",
                            "if",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:data,executable-data,if,construct-independent,devonly,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int dev = 1;\n    int host = 0;\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0.0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n]) if(host)\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            a_copy[x] = a[x];\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            b_copy[x] = b[x];\n        }\n        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n        #pragma acc exit data copyout(a[0:n], b[0:n]) if(host)\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "if",
                            "construct-independent",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:data,executable-data,if,construct-independent,devonly,V:2.0-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int dev = 1;\n    int host = 0;\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0.0;\n        }\n\n        #pragma acc enter data create(a[0:n], b[0:n]) if(host)\n        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n        #pragma acc exit data copyout(a[0:n], b[0:n]) if(host)\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "if",
                            "construct-independent",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,devonly,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            a_copy[x] = a[x];\n        }\n\n        #pragma acc enter data copyin(a[0:n])\n        #pragma acc parallel present(a[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] + 1;\n            }\n        }\n        #pragma acc exit data delete(a[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(a[x] - a_copy[x]) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,executable-data,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_copy[x] = a[x];\n    }\n\n    #pragma acc enter data copyin(a[0:n])\n    #pragma acc parallel present(a[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = a[x] + 1;\n        }\n    }\n    #pragma acc exit data copyout(a[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (a_copy[x] + 1)) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_copyout_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,syntactic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "syntactic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_copyout_reference_counts.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n          a[x] = rand() / (real_t)(RAND_MAX / 10);\n          b[x] = rand() / (real_t)(RAND_MAX / 10);\n          c[x] = 0.0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n        #pragma acc data copyin(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n            #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])\n        }\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err += 1;\n            }\n        }\n\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,executable-data,reference-counting,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc data copyin(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 2;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "reference-counting",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:data,executable-data,reference-counting,construct-independent,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc enter data create(c[0:n])\n    #pragma acc parallel\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] += a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(c[0:n])\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 4;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "reference-counting",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_delete_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,construct-independent,syntactic,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(a[:n], b[:n]) copyout(c[0:n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent",
                            "syntactic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_finalize.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,reference-counting,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc enter data create(a[0:n], b[0:n], c[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data copyout(a[0:n], b[0:n], c[0:n])\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "reference-counting",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,executable-data,reference-counting,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n]) finalize\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "reference-counting",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "host_data.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,host-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    int * high = (int *)malloc(n * sizeof(int));\n    int high_current_index = 0;\n    size_t * a_points = (size_t *)malloc(n * sizeof(void *));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        if (a[x] > 5) {\n            high[high_current_index] = x;\n            high_current_index += 1;\n        }\n    }\n\n    #pragma acc enter data copyin(a[0:n])\n\n    #pragma acc host_data use_device(a)\n    {\n        int x = 0;\n        for (x = 0; x < high_current_index; ++x){\n            a_points[x] = (size_t) a + (high[x]*sizeof(real_t*));\n        }\n        for (; x < n; ++x){\n            a_points[x] = 0;\n        }\n    }\n    #pragma acc enter data copyin(a_points[0:n])\n    #pragma acc parallel present(a[0:n], a_points[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            if (a_points[x] != 0){\n                *((real_t *) a_points[x]) -= 5;\n            }\n        }\n    }\n    #pragma acc exit data delete(a_points[0:n]) copyout(a[0:n])\n    for (int x = 0; x < n; ++x){\n        if (a[x] < 0 || a[x] > 5) {\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "host-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "id": 1,
            "init.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:init,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    #pragma acc init\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "init"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "init_device_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:init,runtime,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int device_num = acc_get_device_num(acc_get_device_type());\n\n    #pragma acc init device_num(device_num)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "init",
                            "runtime"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "init_device_type.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:init,runtime,V:2.5-2.7\nint test1(){\n    int err = 0;\n    int device_type = acc_get_device_type();\n    srand(SEED);\n\n    #pragma acc init device_type(device_type)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "init",
                            "runtime"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "init_device_type_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:init,runtime,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int device_type = acc_get_device_type();\n    int device_num = acc_get_device_num(device_type);\n\n    #pragma acc init device_type(device_type) device_num(device_num)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "init",
                            "runtime"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,async,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * restrict a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict d = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict e = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict f = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict g = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n      \tb[x] = rand() / (real_t)(RAND_MAX / 10);\n      \tc[x] = 0.0;\n      \td[x] = rand() / (real_t)(RAND_MAX / 10);\n      \te[x] = rand() / (real_t)(RAND_MAX / 10);\n      \tf[x] = 0.0;\n      \tg[x] = 0.0;\n    }\n    #pragma acc enter data create(g[0:n], c[0:n], f[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])\n    {\n        #pragma acc kernels async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc kernels async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        #pragma acc kernels wait(1, 2) async(3)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                g[x] = c[x] + f[x];\n            }\n        }\n    }\n    #pragma acc wait(1, 2)\n    #pragma acc update host(c[0:n], f[0:n])\n    #pragma acc exit data copyout(g[0:n]) async(3)\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n      \t}\n        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc wait(3)\n    for (int x = 0; x < n; ++x){\n        if (fabs(g[x] - (c[x] + f[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc exit data delete(c[0:n], f[0:n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "async",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_copy.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,data-region,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 1;\n    }\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc kernels copy(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc kernels present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n          a[x] = rand() / (real_t)(RAND_MAX / 10);\n          b[x] = rand() / (real_t)(RAND_MAX / 10);\n          c[x] = 1;\n        }\n        #pragma acc data copyin(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc kernels copy(c[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - 1) > PRECISION && (a[x] + b[x]) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc kernels present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++ x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 1;\n        }\n\n        #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                c[x] = 0;\n            }\n            #pragma acc kernels copy(c[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n            for (int x = 0; x < n; ++x){\n                if (fabs(c[x]) > PRECISION) {\n                    err += 1;\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_copyin.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,data-region,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n\n    #pragma acc data copy(b[0:n])\n    {\n        #pragma acc kernels copyin(a[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] += a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc kernels present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = 0.0;\n        }\n\n        #pragma acc data copy(a[0:n], b[0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                a[x] = -1;\n            }\n            #pragma acc kernels copyin(a[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(b[x] - a[x]) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:kernels,data,data-region,devonly,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = 0;\n        }\n        #pragma acc kernels copyin(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(b[x]) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "devonly"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_copyout.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,data-region,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc kernels copyout(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc kernels present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = 0;\n        }\n\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc kernels copyout(b[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(b[x]) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_create.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,data-region,devonly,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n          a[x] = rand() / (real_t)(RAND_MAX / 10);\n          b[x] = 0.0;\n        }\n\n        #pragma acc data copyin(a[0:n])\n        {\n            #pragma acc kernels create(b[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(b[x]) > PRECISION){\n                err += 1;\n            }\n        }\n\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "devonly"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,data,data-region,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc kernels create(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:kernels,data,data-region,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(c[0:n])\n    {\n        #pragma acc kernels create(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_default_copy.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data-region,default-mapping,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t c[n];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc kernels\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data-region",
                            "default-mapping"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,data-region,default-mapping,reference-counting,devonly,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t c[n];\n    int * devtest = (int *)malloc(sizeof(real_t));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc kernels present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 1;\n        }\n\n        #pragma acc enter data copyin(c[0:n])\n        for (int x = 0; x < n; ++x){\n            c[x] = 0.0;\n        }\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc kernels\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err += 1;\n            }\n        }\n\n        #pragma acc exit data copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data-region",
                            "default-mapping",
                            "reference-counting",
                            "devonly"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_default_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,data-region,default,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n]), create(b[0:n])\n    #pragma acc kernels default(present)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n    #pragma acc exit data delete(a[0:n]), copyout(b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "default"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_if.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,if,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int data_on_device = 0;\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "if"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,if,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n]) create(b[0:n])\n    data_on_device = 1;\n\n    #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n    #pragma acc exit data copyout(b[0:n]) delete(a[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:kernels,if,devonly,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    int data_on_device = 0;\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = 0;\n        }\n\n        #pragma acc enter data copyin(a[0:n]) create(b[0:n])\n        for (int x = 0; x < n; ++x){\n            a[x] = -1;\n        }\n\n        #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n        for (int x = 0; x < n; ++x){\n            if (fabs(a[x] + 1) > PRECISION){\n                err += 1;\n            }\n            if (fabs(b[x]) > PRECISION){\n                err += 1;\n            }\n        }\n        #pragma acc exit data copyout(a[0:n], b[0:n])\n        data_on_device = 0;\n        for (int x = 0; x < n; ++x){\n            if (fabs(a[x] - b[x]) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "if",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:kernels,if,devonly,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    int data_on_device = 0;\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = 0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n])\n        #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n        for (int x = 0; x < n; ++x){\n            if (fabs(a[x] - b[x]) > PRECISION) {\n                err += 1;\n            }\n        }\n        #pragma acc exit data copyout(a[0:n], b[0:n])\n        for (int x = 0; x < n; ++x){\n            if (fabs(b[x]) > PRECISION && b[x] != a[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "if",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(1024 * sizeof(real_t));\n    real_t * b = (real_t *)malloc(1024 * sizeof(real_t));\n\n    for (int x = 0; x < 1024; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc kernels loop copy(a[0:1024]) copyout(b[0:1024])\n    for (int _0 = 0; _0 < 2; ++_0){\n        #pragma acc loop\n        for (int _1 = 0; _1 < 2; ++_1){\n            #pragma acc loop\n            for (int _2 = 0; _2 < 2; ++_2){\n                #pragma acc loop\n                for (int _3 = 0; _3 < 2; ++_3){\n                    #pragma acc loop\n                    for (int _4 = 0; _4 < 2; ++_4){\n                        #pragma acc loop\n                        for (int _5 = 0; _5 < 2; ++_5){\n                            #pragma acc loop\n                            for (int _6 = 0; _6 < 2; ++_6){\n                                #pragma acc loop\n                                for (int _7 = 0; _7 < 2; ++_7){\n                                    #pragma acc loop\n                                    for (int _8 = 0; _8 < 2; ++_8){\n                                        #pragma acc loop\n                                        for (int _9 = 0; _9 < 2; ++_9){\n                                            b[_0 * 512 + _1 * 256 + _2 * 128 + _3 * 64 + _4 * 32 + _5 * 16 + _6 * 8 + _7 * 4 + _8 * 2 + _9] = a[_0 * 512 + _1 * 256 + _2 * 128 + _3 * 64 + _4 * 32 + _5 * 16 + _6 * 8 + _7 * 4 + _8 * 2 + _9];\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 1024; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_independent.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc kernels loop independent\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_add_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    real_t total = 10; //Should be innitialized to 0 anyway.\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc kernels loop reduction(+:total)\n        for (int x = 0; x < n; ++x){\n            total += a[x] + b[x];\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        total -= a[x] + b[x];\n    }\n    if (fabs(total - 10) > PRECISION * (2 * n - 1)){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_add_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,combined-constructs,reduction,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t avg = 0.0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) create(c[0:10*n]) copyout(d[0:10*n])\n    {\n        #pragma acc kernels loop gang private(avg)\n        for (int x = 0; x < 10; ++x){\n            avg = 0;\n            #pragma acc loop worker reduction(+:avg)\n            for (int y = 0; y < n; ++y){\n                avg += c[x * n + y] = a[x * n + y] + b[x * n + y];\n            }\n            avg = avg / n;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                d[x * n + y] = c[x * n + y] - avg;\n            }\n        }\n    }\n\n    real_t rolling_total = 0;\n\n    for (int x = 0; x < 10; ++x){\n        rolling_total = 0;\n        for (int y = 0; y < n; ++y){\n            rolling_total += a[x * n + y] + b[x * n + y];\n        }\n        rolling_total = rolling_total / n;\n        for (int y = 0; y < n; ++y){\n            if (fabs(d[x * n + y] - ((a[x * n + y] + b[x * n + y]) - rolling_total)) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "combined-constructs",
                            "reduction"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_add_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for(int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0.0;\n            #pragma acc loop vector reduction(+:temp)\n            for (int y = 0; y < n; ++y){\n                temp += a[(x * n) + y] + b[(x * n) + y];\n            }\n            c[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            c[x] -= a[(x * n) + y] + b[(x * n) + y];\n        }\n        if (fabs(c[x]) > PRECISION * (2 * n - 1)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_and_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    char * a = (char *)malloc(n * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char result = 1;\n\n    for (int x = 0; x < n; ++x){\n        if(rand() / (real_t)(RAND_MAX) < false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc kernels loop reduction(&&:result)\n        for (int x = 0; x < n; ++x){\n            result = result && a[x];\n        }\n    }\n\n    char found = 0;\n    for (int x = 0; x < n; ++x){\n        if (a[x] == 0){\n            found = 1;\n            break;\n        }\n    }\n    if (found == result){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_and_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * a_copy = (char *)malloc(10 * n * sizeof(char));\n    char * has_false = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 10; ++x){\n        has_false[x] = 0;\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (rand() / (real_t)(RAND_MAX) < false_margin){\n                a[x * n + y] = 1;\n                a_copy[x * n + y] = 1;\n            }\n            else {\n                a[x * n + y] = 0;\n                a_copy[x * n + y] = 0;\n                has_false[x] = 1;\n            }\n        }\n    }\n\n    char temp = 1;\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop worker reduction(&&:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp && a[x * n + y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                if(temp == 1){\n                    if  (a[x * n + y] == 1){\n                        a[x * n + y] = 0;\n                    }\n                    else {\n                        a[x * n + y] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){\n                err = 1;\n            }\n            else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_and_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * sizeof(char));\n    char * has_false = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 10; ++x){\n        has_false[x] = 0;\n    }\n    for (int x = 0; x < 10 * n; ++x){\n        if(rand() / (real_t)(RAND_MAX) < false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n            has_false[x/n] = 1;\n        }\n    }\n    char temp = 1;\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop vector reduction(&&:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp && a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (has_false[x] == b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitand_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    n = 10;\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    unsigned int b = 0;\n    for (int x = 0; x < 16; ++x){\n        temp = 1;\n        for (int y = 0; y < x; ++y){\n            temp *= 2;\n        }\n        b += temp;\n    }\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc kernels loop reduction(&:b)\n        for (int x = 0; x < n; ++x){\n            b = b & a[x];\n        }\n    }\n    unsigned int host_b = a[0];\n\n    for (int x = 1; x < n; ++x){\n        host_b = host_b & a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitand_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < 10 * n; ++x){\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    #pragma acc data copyin(a[0:10 * n]) copy(b[0:10 * n], c[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int y = 0; y < 10; ++y){\n            temp = a[y * n];\n            #pragma acc loop worker reduction(&:temp)\n            for (int x = 1; x < n; ++x){\n                temp = temp & a[y * n + x];\n            }\n            c[y] = temp;\n            #pragma acc loop worker\n            for (int x = 0; x < n; ++x){\n                b[y * n + x] = b[y * n + x] + c[y];\n            }\n        }\n    }\n    unsigned int* host_c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    for (int x = 0; x < 10; ++x){\n        host_c[x] = a[x * n];\n        for (int y = 1; y < n; ++y){\n            host_c[x] = host_c[x] & a[x * n + y];\n        }\n        if (host_c[x] != c[x]){\n          err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + c[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitand_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int c = 0;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc kernels loop private(c)\n        for (int x = 0; x < 10; ++x){\n            c = a[x * n];\n            #pragma acc loop vector reduction(&:c)\n            for (int y = 1; y < n; ++y){\n                c = c & a[x * n + y];\n            }\n            b[x] = c;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host & a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitor_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int b = 0;\n    unsigned int host_b = a[0];\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX > false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc kernels loop reduction(|:b)\n        for (int x = 0; x < n; ++x){\n            b = b | a[x];\n        }\n    }\n\n\n    for (int x = 1; x < n; ++x){\n        host_b = host_b | a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitor_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int host_c;\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            b[x * n + y] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n            b_copy[x * n + y] = b[x * n + y];\n            for (int z = 0; z < 16; ++z){\n                if (rand() / (real_t) RAND_MAX > false_margin){\n                    temp = 1;\n                    for (int i = 0; i < z; ++i){\n                        temp = temp * 2;\n                    }\n                    a[x * n + y] += temp;\n                }\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(|:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp | a[x * n + y];\n            }\n            c[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                b[x * n + y] = b[x * n + y] + c[x];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        host_c = a[x * n];\n        for (int y = 1; y < n; ++y){\n            host_c = host_c | a[x * n + y];\n        }\n        if (host_c != c[x]){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + host_c){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitor_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX > false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    temp = 0;\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(|:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp | a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host | a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitxor_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    unsigned int b = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n    unsigned int host_b = a[0];\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc kernels loop reduction(^:b)\n        for (int x = 0; x < n; ++x){\n            b = b ^ a[x];\n        }\n    }\n\n\n    for (int x = 1; x < n; ++x){\n        host_b = host_b ^ a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitxor_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int temp = 0;\n\n    for (int x = 0; x < 10*n; ++x){\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(^:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp ^ a[x * n + y];\n            }\n            c[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                b[x * n + y] = b[x * n + y] + c[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = temp ^ a[x * n + y];\n        }\n        if (temp != c[x]){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + c[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitxor_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    unsigned int temp = 0;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(^:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp ^ a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host ^ a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_max_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t max = 0.0;\n    int found = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(max)\n    {\n        #pragma acc kernels loop reduction(max:max)\n        for (int x = 0; x < n; ++x){\n            max = fmax(a[x] * b[x], max);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(max - (a[x] * b[x] + PRECISION)) < 0){\n            err = 1;\n        }\n        if (fabs(max - (a[x] * b[x] - PRECISION)) > 0){\n            found = 1;\n        }\n    }\n    if (found = 0){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_max_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * maximum = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n    real_t max = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n        c[x] = 0.0;\n    }\n    for (int x = 0; x < 10; ++x){\n        maximum[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], maximum[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(max:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmax(a[x * n + y] * b[x * n + y], temp);\n            }\n            maximum[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / maximum[x];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = fmax(temp, a[x * n + y] * b[x * n + y]);\n        }\n        if (fabs(temp - maximum[x]) > PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (c[x * n + y] > 1){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_max_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * max = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n    real_t temp_max;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(max[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(max:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmax(a[x * n + y] * b[x * n + y], temp);\n            }\n            max[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp_max = 0;\n        for (int y = 0; y < n; ++y){\n            if (temp_max < a[x * n + y] * b[x * n + y]){\n                temp_max = a[x * n + y] * b[x * n + y];\n            }\n        }\n        if (fabs(temp_max - max[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_min_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t min = 1000.0;\n    int found = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(min)\n    {\n        #pragma acc kernels loop reduction(min:min)\n        for (int x = 0; x < n; ++x){\n            min = fmin(a[x] * b[x], min);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs((a[x] * b[x]) - (min + PRECISION)) < 0){\n            err = 1;\n        }\n        if (fabs(min - (a[x] * b[x])) < PRECISION){\n            found = 1;\n        }\n    }\n    if (found == 0){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_min_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * minimum = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = 1 + rand() / (real_t)(RAND_MAX/10);\n        b[x] = 1 + rand() / (real_t)(RAND_MAX/10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], minimum[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1000;\n            #pragma acc loop reduction(min:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmin(a[x * n + y] * b[x * n + y], temp);\n            }\n            minimum[x] = temp;\n            #pragma acc loop\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / minimum[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 1000;\n        for (int y = 0; y < n; ++y){\n            temp = fmin(temp, a[x * n + y] * b[x * n + y]);\n        }\n        if (fabs(temp - minimum[x]) > PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x * n + y] - (a[x * n + y] * b[x * n + y] / minimum[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_min_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * min = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 100;\n    real_t temp_min;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(min[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 100;\n            #pragma acc loop vector reduction(min:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmin(a[x * n + y] * b[x * n + y], temp);\n            }\n            min[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp_min = 100;\n        for (int y = 0; y < n; ++y){\n            if (temp_min > a[x * n + y] * b[x * n + y]){\n                temp_min = a[x * n + y] * b[x * n + y];\n            }\n        }\n        if (fabs(temp_min - min[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_multiply_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    int multiplicitive_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(multiplicitive_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(multiplicitive_n * sizeof(real_t));\n\n    real_t multiplied_total = 1.0;\n\n    for (int x = 0; x < multiplicitive_n; ++x){\n        a[x] = rand() / (real_t) RAND_MAX;\n        b[x] = rand() / (real_t) RAND_MAX;\n    }\n\n    #pragma acc data copyin(a[0:multiplicitive_n], b[0:multiplicitive_n]) copy(multiplied_total)\n    {\n        #pragma acc kernels loop reduction(*:multiplied_total)\n        for (int x = 0; x < multiplicitive_n; ++x){\n            multiplied_total *= a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < multiplicitive_n; ++x){\n        multiplied_total /= (a[x] + b[x]);\n    }\n    if (fabs(multiplied_total - 1) > PRECISION * (2 * multiplicitive_n - 1)){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_multiply_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;\n        b[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;\n        c[x] = 0.0;\n    }\n\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10*n]) copy(totals[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop worker reduction(*:temp)\n            for (int y = 0; y < n; ++y){\n                temp *= a[x * n + y] + b[x * n + y];\n            }\n            totals[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] + b[x * n + y]) / totals[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 1;\n        for (int y = 0; y < n; ++y){\n            temp *= a[x * n + y] + b[x * n + y];\n        }\n        if (fabs(temp - totals[x]) > (temp / 2 + totals[x] / 2) * PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x * n + y] - ((a[x * n + y] + b[x * n + y]) / totals[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_multiply_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    int multiplicitive_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < 10 * multiplicitive_n; ++x){\n        a[x] = rand() / (real_t) RAND_MAX;\n        b[x] = rand() / (real_t) RAND_MAX;\n    }\n\n    #pragma acc data copyin(a[0:10*multiplicitive_n], b[0:10*multiplicitive_n]) copyout(c[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1.0;\n            #pragma acc loop vector reduction(*:temp)\n            for (int y = 0; y < multiplicitive_n; ++y){\n                temp *= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];\n            }\n            c[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < multiplicitive_n; ++y){\n            c[x] /= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        if (fabs(c[x] - 1) > PRECISION * (4 * multiplicitive_n - 1)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_or_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char result = 0;\n    char found = 0;\n\n    for (int x = 0; x < n; ++x){\n        if(a[x] = rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc kernels loop reduction(||:result)\n        for (int x = 0; x < n; ++x){\n            result = result || a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (a[x] == 1){\n            found = 1;\n        }\n    }\n    if (found != result){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_or_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * a_copy = (char *)malloc(10 * n * sizeof(char));\n    char * results = (char *)malloc(10 * sizeof(char));\n    char temp = 0;\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 10 * n; ++x){\n        if (rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n            a_copy[x] = 1;\n        }\n        else{\n            a[x] = 0;\n            a_copy[x] = 0;\n        }\n    }\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(||:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp || a[x * n + y];\n            }\n            results[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                if(results[x] == 1){\n                    if (a[x * n + y] == 1){\n                        a[x * n + y] = 0;\n                    }\n                    else{\n                        a[x * n + y] = 1;\n                    }\n                }\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = temp || a_copy[x * n + y];\n        }\n        if (temp != results[x]) {\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (temp == 1){\n                if (a[x * n + y] == a_copy[x * n + y]){\n                    err += 1;\n                }\n            }\n            else {\n                if (a[x * n + y] != a_copy[x * n + y]){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_or_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char temp = 0;\n    char found;\n\n    for (int x = 0; x < 10 * n; ++x){\n        if(rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(||:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp || a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        found = 0;\n        for (int y = 0; y < n; ++y){\n            if (a[x * n + y] &! 0){\n                found = 1;\n            }\n        }\n        if (found != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_seq.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,combined-constructs,V:1.0-2.7\nint test1(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t temp = 0.0;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = 0.0;\n  }\n\n  #pragma acc data copyin(a[0:n]) copy(b[0:n])\n  {\n      #pragma acc kernels loop seq\n      for (int x = 1; x < n; ++x){\n          b[x] = b[x-1] + a[x];\n      }\n  }\n\n  for (int x = 1; x < n; ++x){\n      temp += a[x];\n      if (fabs(b[x] - temp) > PRECISION){\n          err = 1;\n      }\n  }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_tile.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,tile,reduction,combined-constructs,V:2.0-2.7\nint test1(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t * c = (real_t *)malloc(n * sizeof(real_t));\n  real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));\n  real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));\n  real_t temp = 0.0;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = rand() / (real_t)(RAND_MAX / 10);\n  }\n  #pragma acc data copy(a[0:n], b[0:n], c[0:n], d2[0:n*n])\n  {\n      #pragma acc kernels loop tile(*, *) reduction(+:temp)\n      for (int x = 0; x < n; ++x){\n          for (int y = 0; y < n; ++y){\n              temp = 0;\n              for (int z = 0; z < n; ++z){\n                  temp += a[x] + b[y] + c[z];\n              }\n              d2[x * n + y] = temp;\n          }\n      }\n  }\n  for (int x = 0; x < n; ++x){\n      for (int y = 0; y < n; ++y){\n          temp = 0.0;\n          for (int z = 0; z < n; ++z){\n              temp += a[x] + b[y] + c[z];\n          }\n          if (fabs(temp - d2[x * n + y]) > PRECISION * n){\n              err += 1;\n          }\n      }\n  }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "tile",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,loop,tile,combined-constructs,V:2.0-2.7\nint test2(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t * c = (real_t *)malloc(n * sizeof(real_t));\n  real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));\n  real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));\n  real_t temp = 0.0;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = rand() / (real_t)(RAND_MAX / 10);\n  }\n\n  #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d3[0:n*n*n])\n  {\n      #pragma acc kernels loop tile(n/10, n, n*2)\n      for (int x = 0; x < n; ++x){\n          for (int y = 0; y < n; ++y){\n              for (int z = 0; z < n; ++z){\n                  d3[(n * n * x) + (n * y) + z] = a[x] + b[x] + c[x];\n              }\n          }\n      }\n  }\n\n  for (int x = 0; x < n; ++x){\n      for (int y = 0; y < n; ++y){\n          for (int z = 0; z < n; ++z){\n              if (fabs(d3[(n * n * x) + (n * y) + z] - a[x] - b[x] - c[x]) > PRECISION * 2){\n                  err = 1;\n              }\n          }\n      }\n  }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "tile",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_vector_blocking.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,V:1.0-2.7\nint test1(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t * c = (real_t *)malloc(n * sizeof(real_t));\n  real_t multiplyer = 1;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = 0.0;\n  }\n\n  #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n  {\n    #pragma acc kernels\n    {\n      #pragma acc loop vector\n      for (int x = 0; x < n; ++x){\n        c[x] = (a[x] + b[x]) * multiplyer;\n      }\n      multiplyer += 1;\n      #pragma acc loop vector\n      for (int x = 0; x < n; ++x){\n        c[x] += (a[x] + b[x]) * multiplyer;\n      }\n    }\n  }\n\n  for (int x = 0; x < n; ++x){\n    if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){\n      err + 1;\n      break;\n    }\n  }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_worker_blocking.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,V:1.0-2.7\nint test1(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t * c = (real_t *)malloc(n * sizeof(real_t));\n  real_t multiplyer = 1;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = 0.0;\n  }\n\n  #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n  {\n    #pragma acc kernels\n    {\n      #pragma acc loop worker\n      for (int x = 0; x < n; ++x){\n        c[x] = (a[x] + b[x]) * multiplyer;\n      }\n      multiplyer += 1;\n      #pragma acc loop worker\n      for (int x = 0; x < n; ++x){\n        c[x] += (a[x] + b[x]) * multiplyer;\n      }\n    }\n  }\n\n  for (int x = 0; x < n; ++x){\n    if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){\n      err + 1;\n      break;\n    }\n  }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_num_gangs.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * restrict a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc kernels loop num_gangs(16)\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_num_workers.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * restrict a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc kernels loop num_workers(16)\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,structured-data,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n]) create(b[0:n])\n    #pragma acc kernels present(a[0:n], b[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n    #pragma acc exit data copyout(b[0:n]) delete(a[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "structured-data"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_scalar_default_copy.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,data-region,default-mapping,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t sum = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    for (int x = 0; x < n; ++x){\n        sum = sum + a[x];\n    }\n\n    #pragma acc data copyin(b[0:n])\n    {\n        #pragma acc kernels num_gangs(1) vector_length(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                sum = sum + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        sum = sum - (a[x] + b[x]);\n    }\n\n    if (fabs(sum) > (2 * n - 2) * PRECISION){\n        err += 1;\n        sum = 0.0;\n        for (int x = 0; x < n; ++x){\n            sum = sum + a[x];\n        }\n        sum = 0.0;\n        for (int x = 0; x < n; ++x){\n            sum = sum + b[x];\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "default-mapping"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_vector_length.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc kernels vector_length(16)\n        {\n            #pragma acc loop vector\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_wait.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n]) async(1)\n    #pragma acc kernels wait(1)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] += a[x] + b[x];\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "loop_collapse.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:loop,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x * n] = a[x * n] + b[x * n];\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop independent collapse(1)\n            for (int x = 0; x < 10; ++x){\n                for (int y = 1; y < n; ++y){\n                    c[x * n + y] = c[x * n + y - 1] + a[x * n + y] + b[x * n + y];\n                }\n            }\n        }\n    }\n\n    real_t total;\n    for (int x = 0; x < 10; ++x){\n        total = 0;\n        for (int y = 0; y < n; ++y){\n            total += a[x * n + y] + b[x * n + y];\n            if (fabs(c[x * n + y] - total) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "loop",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:loop,syntactic,construct-independent,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop independent collapse(2)\n            for (int x = 0; x < 10; ++x){\n                for (int y = 0; y < n; ++y){\n                    c[x * n + y] = a[x * n + y] + b[x * n + y];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "loop",
                            "syntactic",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "loop_no_collapse_default.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:loop,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t total = 0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x * n] = a[x * n] + b[x * n];\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop independent\n            for (int x = 0; x < 10; ++x){\n                for (int y = 1; y < n; ++y){\n                    c[x * n + y] = c[x * n + y - 1] + a[x * n + y] + b[x * n + y];\n                }\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        total = 0;\n        for (int y = 0; y < n; ++y){\n            total += a[x * n + y] + b[x * n +y];\n            if (fabs(total - c[x * n + y]) > PRECISION * y){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "loop",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t* a = (real_t *) malloc(1024 * sizeof(real_t));\n    real_t* b = (real_t *) malloc(1024 * sizeof(real_t));\n    real_t* c = (real_t *) malloc(1024 * sizeof(real_t));\n\n    for(int x = 0; x < 1024; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:1024], b[0:1024]) copy(c[0:1024])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int _0 = 0; _0 < 2; ++_0){\n                #pragma acc loop\n                for (int _1 = 0; _1 < 2; ++_1){\n                    #pragma acc loop\n                    for (int _2 = 0; _2 < 2; ++_2){\n                        #pragma acc loop\n                        for (int _3 = 0; _3 < 2; ++_3){\n                            #pragma acc loop\n                            for (int _4 = 0; _4 < 2; ++_4){\n                                #pragma acc loop\n                                for (int _5 = 0; _5 < 2; ++_5){\n                                    #pragma acc loop\n                                    for (int _6 = 0; _6 < 2; ++_6){\n                                        #pragma acc loop\n                                        for (int _7 = 0; _7 < 2; ++_7){\n                                            #pragma acc loop\n                                            for (int _8 = 0; _8 < 2; ++_8){\n                                                #pragma acc loop\n                                                for (int _9 = 0; _9 < 2; ++_9){\n                                                    c[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] =\n                                                    a[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] +\n                                                    b[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9];\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 1024; ++x){\n        if(fabs(c[x] - (a[x] +b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,async,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(n * sizeof(real_t));\n    real_t * e = (real_t *)malloc(n * sizeof(real_t));\n    real_t * f = (real_t *)malloc(n * sizeof(real_t));\n    real_t * g = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0.0;\n        g[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], c[0:n], f[0:n], g[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        #pragma acc parallel wait(1, 2) async(3)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                g[x] = c[x] + f[x];\n            }\n        }\n        #pragma acc update host(c[0:n]) async(1)\n        #pragma acc update host(f[0:n]) async(2)\n        #pragma acc update host(g[0:n]) async(3)\n\n        #pragma acc wait(1)\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n        #pragma acc wait(2)\n        for (int x = 0; x < n; ++x){\n            if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n                err += 1;\n            }\n        }\n        #pragma acc wait(3)\n        for (int x = 0; x < n; ++x){\n            if (fabs(g[x] - (a[x] + b[x] + d[x] + e[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "async",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_copy.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,data-region,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_host[x] = a[x];\n    }\n\n    #pragma acc parallel copy(a[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 2 * a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (2 * a_host[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_copyin.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,data-region,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int* hasDevice = (int *) malloc(sizeof(int));\n    hasDevice[0] = 1;\n    #pragma acc enter data copyin(hasDevice[0:1])\n    #pragma acc parallel present(hasDevice[0:1])\n    {\n      hasDevice[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_copy[x] = a[x];\n        b[x] = 0.0;\n    }\n\n    #pragma acc parallel copyin(a[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 0.0;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (((fabs(a[x] - a_copy[x]) > PRECISION) && (hasDevice[0] == 1)) || ((hasDevice[0] == 0) && (fabs(a[x]) > PRECISION))){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,data,data-region,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copy(b[0:n])\n    {\n        #pragma acc parallel copyin(a[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_copyout.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,data-region,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel copyout(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,data,data-region,devonly,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    int* hasDevice = (int *) malloc(sizeof(int));\n    hasDevice[0] = 1;\n    #pragma acc enter data copyin(hasDevice[0:1])\n    #pragma acc parallel present(hasDevice[0:1])\n    {\n      hasDevice[0] = 0;\n    }\n\n    if (hasDevice[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = a[x];\n        }\n\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel copyout(b[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = b[x] - a[x];\n                }\n            }\n        }\n        for (int x = 0; x < n; ++x){\n          if (fabs(a[x] - b[x]) > PRECISION){\n            err += 2;\n            break;\n          }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:parallel,data,data-region,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel copyout(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] - a[x];\n            }\n        }\n        #pragma acc update host(b[0:n])\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x]) > 2 * PRECISION){\n            err += 4;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_create.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,data-region,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(c[0:n])\n    {\n        #pragma acc parallel create(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - c[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_default_copy.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,data-region,default-mapping,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t c[n];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region",
                            "default-mapping"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,data,data-region,default-mapping,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t c[n];\n    int * devtest = (int *)malloc(sizeof(real_t));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 1;\n        }\n\n        #pragma acc enter data copyin(c[0:n])\n        for (int x = 0; x < n; ++x){\n            c[x] = 0.0;\n        }\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err += 1;\n            }\n        }\n\n        #pragma acc exit data copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region",
                            "default-mapping"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_default_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,default,data,data-region,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0.0;\n    }\n    #pragma acc enter data copyin(a[0:n])\n    #pragma acc parallel default(present)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 1.0;\n        }\n    }\n    #pragma acc exit data copyout(a[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - 1.0) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "default",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_deviceptr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,runtime,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n])\n    b = (real_t *) acc_deviceptr(a);\n    if (b == NULL){\n        err = 1;\n    }\n    else{\n        #pragma acc parallel deviceptr(b)\n        {\n            #pragma acc loop\n            for (int x = 0; x < (int) n/2; ++x){\n                b[x] = 1;\n            }\n        }\n        #pragma acc exit data copyout(a[0:n])\n    }\n    for (int x = 0; x < n; ++x){\n        if (x < (int) n/2){\n            if (fabs(a[x] - 1) > PRECISION){\n                err = 1;\n            }\n        }\n        else {\n            if (fabs(a[x]) > PRECISION){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "runtime"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_firstprivate.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,firstprivate,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10*n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        d[x] = 0.0;\n    }\n    for (int x = 0; x < n; ++x){\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n        c_copy[x] = c[x];\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])\n    {\n        #pragma acc parallel firstprivate(c[0:n])\n        {\n            #pragma acc loop gang\n            for (int x = 0; x < 10; ++x){\n                #pragma acc loop worker\n                for (int y = 0; y < n; ++y){\n                    d[x * n + y] = a[x * n + y] + b[x * n + y] + c[y];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(d[x * n + y] - (a[x * n + y] + b[x * n + y] + c_copy[y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "firstprivate"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,firstprivate,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10*n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        d[x] = 0.0;\n    }\n    for (int x = 0; x < n; ++x){\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])\n    {\n        #pragma acc parallel firstprivate(c[0:n])\n        {\n            #pragma acc loop gang independent\n            for (int x = 0; x < 10; ++x){\n                #pragma acc loop worker independent\n                for (int y = 0; y < n; ++y){\n                    c[y] = a[x * n + y] - b[x * n + y];\n                }\n                #pragma acc loop worker independent\n                for (int y = 0; y < n; ++y){\n                    d[x * n + y] = a[x * n + y] + b[x * n + y] + c[y];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x){\n        if (fabs(d[x] - 2 * a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "firstprivate"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_if.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,if,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int accel = 1;\n    int host = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n    #pragma acc parallel if(host)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "if"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,if,devonly,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * dev_test = (int *)malloc(sizeof(int));\n    int accel = 1;\n    int host = 0;\n\n    dev_test[0] = 1;\n    #pragma acc data copyin(dev_test[0:1])\n    #pragma acc parallel\n    {\n      dev_test[0] = 0;\n    }\n\n    if (devtest[0] != 0){\n        for (int x = 0; x < n;  ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n        #pragma acc parallel if(host) present(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n        #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "if",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:parallel,if,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int accel = 1;\n    int host = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n\n    #pragma acc parallel if(accel) present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] += a[x] + b[x];\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION * 2){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0;\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 1.0;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - 1.0) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,loop,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n      a[x] = 0.0;\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copy(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = b[x];\n            }\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] += c[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] + c[x])) > PRECISION * 2){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,async,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n\t\tint * errors = (int *)malloc(10 * sizeof(int));\n\n\t\tfor (int x = 0; x < 10; ++x){\n\t\t\terrors[x] = 0;\n\t\t}\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n        d[x] = a[x] + b[x];\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n], c[0:10*n], d[0:10*n]) copy(errors[0:10])\n    {\n        for (int x = 0; x < 10; ++x){\n            #pragma acc parallel loop async(x)\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = a[x * n + y] + b[x * n + y];\n            }\n            #pragma acc parallel loop async(x) reduction(+:errors[x])\n            for (int y = 0; y < n; ++y){\n                if(c[x * n + y] - d[x * n + y] > PRECISION || d[x * n + y] - c[x * n + y] > PRECISION){\n                    errors[x] += 1;\n                }\n            }\n        }\n\t\t\t\t#pragma acc wait\n    }\n\n    for (int x = 0; x < 10; ++x){\n        err += errors[x];\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "async",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_auto.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,combined-constructs,syntactic,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n      #pragma acc parallel loop auto\n      for (int x = 0; x < n; ++x){\n        b[x] = a[x];\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n      if (fabs(b[x] - a[x]) > PRECISION){\n        err = 1;\n      }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "combined-constructs",
                            "syntactic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,loop,combined-constructs,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_copy[x] = a[x];\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n      #pragma acc parallel loop auto\n      for (int x = 1; x < n; ++x){\n        a[x] = a[x - 1] + a[x];\n      }\n    }\n\n    real_t rolling_total = 0.0;\n    for (int x = 0; x < n; ++x){\n      rolling_total += a_copy[x];\n      if (fabs(rolling_total - a[x]) > PRECISION){\n        err = 1;\n      }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_gang.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc parallel loop gang\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t total;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    total = 10;\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(total)\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x){\n            total += a[x] + b[x];\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        total -= a[x] + b[x];\n    }\n    if (fabs(total - 10) > PRECISION * (2 * n - 1)){ //199 = # of mathematical operations necessary\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,loop,reduction,combined-constructs,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * 10 * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * 10 * sizeof(real_t));\n    real_t c[10];\n    real_t c_host[10];\n\n    for (int x = 0; x < 10 * n; ++x) {\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        c[x] = 1.0;\n        c_host[x] = 1.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n])\n    {\n        #pragma acc parallel loop reduction(+:c[0:10])\n        for (int x = 0; x < n; ++x) {\n            for (int y = 0; y < 10; ++y) {\n                c[y] += a[x * 10 + y] + b[x * 10 + y];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        for (int y = 0; y < 10; ++y) {\n            c_host[y] += a[x * 10 + y] + b[x * 10 + y];\n        }\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        if (fabs(c_host[x] - c[x]) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_general_type_check_pt1.c": {
                "num tests": 8,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test1() {\n    int err = 0;\n    srand(SEED);\n    _Bool* a = (_Bool*)malloc(n * sizeof(_Bool));\n    _Bool* b = (_Bool*)malloc(n * sizeof(_Bool));\n    _Bool total = 1;\n    _Bool host_total = 1;\n\n    for (int x = 0; x < n; ++x) {\n        if ((rand()/((real_t) RAND_MAX)) > .5) {\n            a[x] = 1;\n        }\n        else {\n            a[x] = 0;\n        }\n        if ((rand()/((real_t) RAND_MAX)) > .5) {\n            b[x] = 1;\n        }\n        else {\n            b[x] = 0;\n        }\n    }\n    \n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n    \n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (total != host_total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x) {\n        failed = failed + test1();\n    }\n    if (failed != 0) {\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * sizeof(char));\n    char * b = (char *)malloc(n * sizeof(char));\n    char total = 10;\n    char host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(UCHAR_MAX / 10);\n        b[x] = rand() / (real_t)(UCHAR_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (host_total != total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    signed char * a = (signed char *)malloc(n * sizeof(signed char));\n    signed char * b = (signed char *)malloc(n * sizeof(signed char));\n    signed char total = 10;\n    signed char host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (host_total != total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    unsigned char * a = (unsigned char *)malloc(n * sizeof(unsigned char));\n    unsigned char * b = (unsigned char *)malloc(n * sizeof(unsigned char));\n    unsigned char total = 10;\n    unsigned char host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (total != host_total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    short int * a = (short int *)malloc(n * sizeof(short int));\n    short int * b = (short int *)malloc(n * sizeof(short int));\n    short int total = 10;\n    short int host_total = 10;    \n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (total != host_total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n//T6:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test6(){\n    int err = 0;\n    srand(SEED);\n    int * a = (int *)malloc(n * sizeof(int));\n    int * b = (int *)malloc(n * sizeof(int));\n    int total = 10;\n    int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (total != host_total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T6\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test6();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 5);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "7": {
                        "content": "#ifndef T7\n//T7:parallel,reduction,combined-constructs,loop,nonvalidating,V:1.0-2.7\nint test7(){\n    int err = 0;\n    srand(SEED);\n    long int * a = (long int *)malloc(n * sizeof(long int));\n    long int * b = (long int *)malloc(n * sizeof(long int));\n    long int total = 10;\n    long int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    return err;\n}\n#endif\n#ifndef T7\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test7();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 6);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop",
                            "nonvalidating"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "8": {
                        "content": "#ifndef T8\n//T8:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test8(){\n    int err = 0;\n    srand(SEED);\n    long long int * a = (long long int *)malloc(n * sizeof(long long int));\n    long long int * b = (long long int *)malloc(n * sizeof(long long int));\n    long long int total = 10;\n    long long int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (host_total != total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T8\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test8();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 7);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_general_type_check_pt2.c": {
                "num tests": 8,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned short int * a = (unsigned short int*)malloc(n * sizeof(unsigned short int));\n    unsigned short int * b = (unsigned short int *)malloc(n * sizeof(unsigned short int));\n    unsigned short int total = 10;\n    unsigned short int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (host_total != total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(n * sizeof(unsigned int));\n    unsigned int total = 10;\n    unsigned int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (host_total != total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    unsigned long int * a = (unsigned long int *)malloc(n * sizeof(unsigned long int));\n    unsigned long int * b = (unsigned long int *)malloc(n * sizeof(unsigned long int));\n    unsigned long int total = 10;\n    unsigned long int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (host_total != total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    unsigned long long int * a = (unsigned long long int *)malloc(n * sizeof(unsigned long long int));\n    unsigned long long int * b = (unsigned long long int *)malloc(n * sizeof(unsigned long long int));\n    unsigned long long int total = 10;\n    unsigned long long int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n    \n    if (total != host_total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    float * a = (float *)malloc(n * sizeof(float));\n    float * b = (float *)malloc(n * sizeof(float));\n    float total = 10;\n    float host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (fabsf(total - host_total) > PRECISION) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n//T6:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test6(){\n    int err = 0;\n    srand(SEED);\n    double * a = (double *)malloc(n * sizeof(double));\n    double * b = (double *)malloc(n * sizeof(double));\n    double total = 10;\n    double host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (fabs(host_total - total) > PRECISION) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T6\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test6();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 5);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "7": {
                        "content": "#ifndef T7\n//T7:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test7(){\n    int err = 0;\n    srand(SEED);\n    long double * a = (long double *)malloc(n * sizeof(long double));\n    long double * b = (long double *)malloc(n * sizeof(long double));\n    long double total = 10;\n    long double host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    \n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x){\n            total += a[x] + b[x];\n        }\n    }\n    \n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (fabsl(host_total - total) > PRECISION) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T7\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test7();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 6);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "8": {
                        "content": "#ifndef T8\n//T8:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test8(){\n    int err = 0;\n    srand(SEED);\n    float _Complex * a = (float _Complex *)malloc(n * sizeof(float _Complex));\n    float _Complex * b = (float _Complex *)malloc(n * sizeof(float _Complex));\n    float _Complex total = 10 + 10 * I;\n    float _Complex host_total = 10 + 10 * I;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;\n        b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (fabsf(crealf(total) - crealf(host_total)) > PRECISION) {\n        err += 1;\n    }\n    if (fabsf(cimagf(total) - cimagf(host_total)) > PRECISION) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T8\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test8();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 7);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_general_type_check_pt3.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    double _Complex * a = (double _Complex *)malloc(n * sizeof(double _Complex));\n    double _Complex * b = (double _Complex *)malloc(n * sizeof(double _Complex));\n    double _Complex total = 10 + 10 * I;\n    double _Complex host_total = 10 + 10 * I;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;\n        b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (fabs(creal(total) - creal(host_total)) > PRECISION) {\n        err += 1;\n    }\n    if (fabs(cimag(total) - cimag(host_total)) > PRECISION) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    long double _Complex * a = (long double _Complex*)malloc(n * sizeof(long double _Complex));\n    long double _Complex * b = (long double _Complex*)malloc(n * sizeof(long double _Complex));\n    long double _Complex total = 10 + 10 * I;\n    long double _Complex host_total = 10 + 10 * I;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;\n        b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (fabsl(creall(total) - creall(host_total)) > PRECISION) {\n        err += 1;\n    }\n    if (fabsl(cimagl(total) - cimagl(host_total)) > PRECISION) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t* b = (real_t*)malloc(10 * n * sizeof(real_t));\n    real_t* c = (real_t*)malloc(10 * n * sizeof(real_t));\n    real_t* d = (real_t*)malloc(10 * n * sizeof(real_t));\n    real_t avg = 0.0;\n    real_t rolling_total = 0;\n\n    for (int x = 0; x < 10 * n; ++x) {\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) create(c[0:10*n]) copyout(d[0:10*n])\n    {\n        #pragma acc parallel loop gang private(avg)\n        for (int x = 0; x < 10; ++x) {\n            avg = 0;\n            #pragma acc loop worker reduction(+:avg)\n            for (int y = 0; y < n; ++y) {\n                avg += c[x * n + y] = a[x * n + y] + b[x * n + y];\n            }\n            avg = avg / n;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y) {\n                d[x * n + y] = c[x * n + y] - avg;\n            }\n        }\n    }\n\n\n    for (int x = 0; x < 10; ++x) {\n        rolling_total = 0;\n        for (int y = 0; y < n; ++y) {\n            rolling_total += a[x * n + y] + b[x * n + y];\n        }\n        rolling_total = rolling_total / n;\n        for (int y = 0; y < n; ++y) {\n            if (fabs(d[x * n + y] - ((a[x * n + y] + b[x * n + y]) - rolling_total)) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,loop,reduction,combined-constructs,V:2.7-2.7\nint test2() {\n    int err = 0;\n    srand(SEED);\n    real_t* a = (real_t*)malloc(25 * n * sizeof(real_t));\n    real_t* b = (real_t*)malloc(25 * n * sizeof(real_t));\n    real_t* c = (real_t*)malloc(25 * n * sizeof(real_t));\n    real_t* d = (real_t*)malloc(25 * n * sizeof(real_t));\n    real_t avgs[5];\n    real_t host_avgs[5];\n\n    for (int x = 0; x < 25 * n; ++x) {\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copyout(c[0:25*n], d[0:25*n])\n    {\n        #pragma acc parallel loop gang private(avgs)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                avgs[y] = 0;\n            }\n            #pragma acc loop worker reduction(+:avgs)\n            for (int y = 0; y < 5 * n; ++y) {\n                avgs[y % 5] += c[x * 5 * n + y] = a[x * 5 * n + y] + b[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                avgs[y] = avgs[y] / n;\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * n; ++y) {\n                d[x * 5 * n + y] = c[x * 5 * n + y] - avgs[y % 5];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            host_avgs[y] = 0;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            host_avgs[y % 5] += a[x * 5 * n + y] + b[x * 5 * n + y];\n            if (fabs(c[x * 5 * n + y] - (a[x * n * 5 + y] + b[x * n * 5 + y])) > PRECISION) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5; ++y) {\n            host_avgs[y] = host_avgs[y] / n;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            if (fabs(d[x * 5 * n + y] - (c[x * 5 * n + y] - host_avgs[y % 5])) > PRECISION){\n                err += 1;\n            \n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_loop_type_check_pt1.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    _Bool * a = (_Bool *)malloc(10 * n * sizeof(_Bool));\n    _Bool * b = (_Bool *)malloc(10 * n * sizeof(_Bool));\n    _Bool * c = (_Bool *)malloc(10 * n * sizeof(_Bool));\n    _Bool * d = (_Bool *)malloc(10 * n * sizeof(_Bool));\n    _Bool total = 1;\n    _Bool host_total = 1;\n\n    for (int x = 0; x < 10 * n; ++x){\n        if ((rand() / ((real_t)RAND_MAX)) > .5) {\n            a[x] = 1;\n        }\n        else {\n            a[x] = 0;\n        }\n        if ((rand() / ((real_t)RAND_MAX)) > .5) {\n            b[x] = 1;\n        }\n        else {\n            b[x] = 0;\n        }\n        if ((rand() / ((real_t)RAND_MAX)) > .5) {\n            c[x] = 1;\n        }\n        else {\n            c[x] = 0;\n        }\n    }\n    /*\n    #pragma acc data copyin(a[0:10*n], b[0:10*n], c[0:10*n]) copyout(d[0:10*n])\n    {\n        #pragma acc parallel loop gang private(total)\n        for (int x = 0; x < 10; ++x) {\n            total = 1;\n            #pragma acc loop worker reduction(+:total)\n            for (int y = 0; y < n; ++y) {\n                total += a[x * n + y] + b[x * n + y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y) {\n                d[x * n + y] = c[x * n + y] + total;\n            }\n        }\n    }\n    */\n    for (int x = 0; x < 10; ++x) {\n        host_total = 1;\n        for (int y = 0; y < n; ++y) {\n            host_total += a[x * n + y] + b[x * n + y];\n        }\n        for (int y = 0; y < n; ++y) {\n            if (d[x * n + y] != (host_total + c[x * n + y])) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * n * sizeof(char));\n    char * c = (char *)malloc(10 * n * sizeof(char));\n    char * d = (char *)malloc(10 * n * sizeof(char));\n    char total = 10;\n    char host_total = 10;\n    char temp;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:10*n],b[0:10*n], c[0:10*n]) copyout(d[0:10*n])\n    {\n        #pragma acc parallel loop gang private(total)\n        for (int x = 0; x < 10; ++x) {\n            total = 10;\n            #pragma acc loop worker reduction(+:total)\n            for (int y = 0; y < n; ++y) {\n                total += a[x * n + y] + b[x * n + y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y) {\n                d[x * n + y] = c[x * n + y] + total;\n            }\n        }\n    }\n    int error_count = 0;\n    int total_count = 0;\n    for (int x = 0; x < 10; ++x) {\n        host_total = 10;\n        for (int y = 0; y < n; ++y) {\n            host_total += a[x * n + y] + b[x * n + y];\n        }\n        for (int y = 0; y < n; ++y) {\n            temp = host_total + c[x * n + y];\n            if (d[x * n + y] != temp) {\n                err += 1;\n                error_count += 1;\n                printf(\"Error location x: %d \\t y: %d\\n\", x, y); \n                printf(\"%d != %d\\n\", d[x * n + y], temp);\n            }\n            total_count += 1;\n        }\n    }\n\n    printf(\"%d out of %d failed\\n\", error_count, total_count);\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for(int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0.0;\n            #pragma acc loop vector reduction(+:temp)\n            for (int y = 0; y < n; ++y){\n                temp += a[(x * n) + y] + b[(x * n) + y];\n            }\n            c[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            c[x] -= a[(x * n) + y] + b[(x * n) + y];\n        }\n        if (fabs(c[x]) > PRECISION * (2 * n - 1)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(25 * sizeof(real_t));\n    real_t * c_host = (real_t *)malloc(25 * sizeof(real_t));\n    real_t temp[5];\n\n    for (int x = 0; x < 25 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    for (int x = 0; x < 25; ++x) {\n        c[x] = 0;\n        c_host[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copyout(c[0:25])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                temp[y] = 0;\n            }\n            #pragma acc loop vector reduction(+:temp)\n            for (int y = 0; y < 5 * n; ++y) {\n                temp[y % 5] += a[x * 5 * n + y] + b[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                c[x * 5 + y] = temp[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5 * n; ++y) {\n            c_host[x * 5 + (y % 5)] += a[x * 5 * n + y] + b[x * 5 * n + y];\n        }\n    }\n\n    for (int x = 0; x < 25; ++x) {\n        if (fabs(c[x] - c_host[x]) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_and_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    char * a = (char *)malloc(n * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char result = 1;\n    char found = 0;\n\n    for (int x = 0; x < n; ++x){\n        if(rand() / (real_t)(RAND_MAX) < false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel loop reduction(&&:result)\n        for (int x = 0; x < n; ++x){\n            result = result && a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (a[x] == 0){\n            found = 1;\n            break;\n        }\n    }\n    if (found == result){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * 5 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5/n));\n    char result[5];\n    char host_result[5];\n\n    for (int x = 0; x < 5; ++x) {\n        result[x] = 1;\n        host_result[x] = 1;\n    }\n\n    for (int x = 0; x < 5 * n; ++x) {\n        if (rand() / (real_t)(RAND_MAX) < false_margin) {\n            a[x] = 1;\n        }\n        else {\n            a[x] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:5*n])\n    {\n        #pragma acc parallel loop reduction(&&:result)\n        for (int x = 0; x < 5 * n; ++x) {\n            result[x%5] = result[x%5] && a[x];\n        }\n    }\n\n    for (int x = 0; x < 5 * n; ++x) {\n        host_result[x%5] = host_result[x%5] && a[x];\n    }\n\n    for (int x = 0; x < 5; ++x){\n        if (host_result[x] != result[x]) {\n            err += 1;\n        } \n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_and_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * a_copy = (char *)malloc(10 * n * sizeof(char));\n    char * has_false = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char temp = 1;\n\n    for (int x = 0; x < 10; ++x){\n        has_false[x] = 0;\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (rand() / (real_t)(RAND_MAX) < false_margin){\n                a[x * n + y] = 1;\n                a_copy[x * n + y] = 1;\n            }\n            else {\n                a[x * n + y] = 0;\n                a_copy[x * n + y] = 0;\n                has_false[x] = 1;\n            }\n        }\n    }\n\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop worker reduction(&&:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp && a[x * n + y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                a[x * n + y] = a[x * n + y] ^ temp;\n            }\n        }\n    }\n\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){\n                err = 1;\n            }\n            else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * 25 * sizeof(char));\n    char * a_copy = (char *)malloc(n * 25 * sizeof(char));\n    char * has_false = (char *)malloc(25 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char device[5];\n    char host[5];\n\n    for (int x = 0; x < 5; ++x) {\n        device[x] = 1;\n        host[x] = 1;\n        for (int y = 0; y < 5; ++y) {\n            has_false[x * 5 + y] = 0;\n        }\n    }\n\n    for (int x = 0; x < 25 * n; ++x){\n        if (rand() / (real_t)(RAND_MAX) < false_margin) {\n            a[x] = 1;\n            a_copy[x] = 1;\n        }\n        else {\n            a[x] = 0;\n            a_copy[x] = 0;\n            has_false[x % 25] = 1;\n        }\n    }\n\n    #pragma acc data copy(a[0:25*n])\n    {\n        #pragma acc parallel loop gang private(device)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                device[y] = 1;\n            }\n            #pragma acc loop worker reduction(&&:device)\n            for (int y = 0; y < 5 * n; ++y) {\n                device[y%5] = device[y%5] && a[x * 5 * n + y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * n; ++y) {\n                a[x * 5 * n + y] = a[x * 5 * n + y] ^ device[y%5];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            host[y] = 1;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            host[y%5] = host[y%5] && a_copy[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            if (a[x * 5 * n + y] != (a_copy[x * 5 * n + y] ^ host[y % 5])) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_and_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * sizeof(char));\n    char * has_false = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char temp = 1;\n\n    for (int x = 0; x < 10; ++x){\n        has_false[x] = 0;\n    }\n    for (int x = 0; x < 10 * n; ++x){\n        if(rand() / (real_t)(RAND_MAX) < false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n            has_false[x/n] = 1;\n        }\n    }\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop vector reduction(&&:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp && a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (has_false[x] == b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(25 * n * sizeof(char));\n    char * b = (char *)malloc(25 * sizeof(char));\n    char * has_false = (char *)malloc(25 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char device[5];\n    char host[5];\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5 * n; ++y){\n            if (rand() / (real_t)(RAND_MAX) < false_margin) {\n                a[x] = 1;\n            }\n            else {\n                a[x] = 0;\n                has_false[x * 5 + y % 5];\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copy(b[0:25])\n    {\n        #pragma acc parallel loop private(device)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                device[y] = 1;\n            }\n            #pragma acc loop vector reduction(&&:device)\n            for (int y = 0; y < 5 * n; ++y) {\n                device[y%5] = device[y%5] && a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y){\n                b[x * 5 + y] = device[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            host[y] = 1;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            host[y%5] = host[y%5] && a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (b[x * 5 + y] != host[y]) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitand_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    n = 10;\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int b;\n    unsigned int host_b;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n\n    b = a[0];\n    host_b = a[0];\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel loop reduction(&:b)\n        for (int x = 0; x < n; ++x){\n            b = b & a[x];\n        }\n    }\n\n    for (int x = 1; x < n; ++x){\n        host_b = host_b & a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int device[10];\n    unsigned int host[10];\n\n    for (int x = 0; x < 10 * n; ++x) {\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t)RAND_MAX < false_margin) {\n                a[x] += 1<<y;\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        device[x] = 0;\n        host[x] = 0;\n        for (int y = 0; y < 16; ++y) {\n            device[x] += 1<<y;\n            host[x] += 1<<y;\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n])\n    {\n        #pragma acc parallel loop reduction(&:device)\n        for (int x = 0; x < 10 * n; ++x) {\n            device[x%10] = device[x%10] & a[x];\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x) {\n        host[x%10] = host[x%10] & a[x];\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        if (host[x] != device[x]) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitand_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int * host_c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = 0;\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                a[x] += 1 << y;\n            }\n        }\n    }\n    #pragma acc data copyin(a[0:10 * n]) copy(b[0:10 * n], c[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int y = 0; y < 10; ++y){\n            temp = a[y * n];\n            #pragma acc loop worker reduction(&:temp)\n            for (int x = 1; x < n; ++x){\n                temp = temp & a[y * n + x];\n            }\n            c[y] = temp;\n            #pragma acc loop worker\n            for (int x = 0; x < n; ++x){\n                b[y * n + x] = b[y * n + x] + c[y];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        host_c[x] = a[x * n];\n        for (int y = 1; y < n; ++y){\n            host_c[x] = host_c[x] & a[x * n + y];\n        }\n        if (host_c[x] != c[x]){\n          err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + c[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(25 * sizeof(unsigned int));\n    unsigned int device[5];\n    unsigned int host[5];\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    \n    for (int x = 0; x < 25 * n; ++x){\n        a[x] = 0;\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        for (int y = 0; y < 16; ++y) {\n            if (rand() / (real_t)RAND_MAX < false_margin) {\n                a[x] += 1 << y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copy(b[0:25*n], c[0:25])\n    {\n        #pragma acc parallel loop gang private(device)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                device[y] = a[x * 5 * n + y];\n            }\n            #pragma acc loop worker reduction(&:device)\n            for (int y = 0; y < 5 * n; ++y) {\n                device[y%5] = device[y%5] & a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                c[x * 5 + y] = device[y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * n; ++y) {\n                b[x * 5 * n + y] = b[x * 5 * n + y] + c[x * 5 + (y % 5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            host[y] = a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            host[y%5] = host[y%5] & a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (host[y] != c[x * 5 + y]) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            if (b[x * 5 * n + y] != (host[y%5] + b_copy[x * 5 * n + y])) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitand_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int c = 0;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                a[x] += 1 << y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copyout(b[0:10])\n    {\n        #pragma acc parallel loop private(c)\n        for (int x = 0; x < 10; ++x){\n            c = a[x * n];\n            #pragma acc loop vector reduction(&:c)\n            for (int y = 1; y < n; ++y){\n                c = c & a[x * n + y];\n            }\n            b[x] = c;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host & a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int c[5];\n    unsigned int * b_host = (unsigned int *)malloc(5 * sizeof(unsigned int));\n    \n\n    for (int x = 0; x < 25 * n; ++x){\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y) {\n            if (rand() / (real_t)RAND_MAX < false_margin) {\n                a[x] += 1 << y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copyout(b[0:25])\n    {\n        #pragma acc parallel loop private(c)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                c[y] = a[x * 5 * n + y];\n            }\n            #pragma acc loop vector reduction(&:c)\n            for (int y = 0; y < 5 * n; ++y) {\n                c[y%5] = c[y%5] & a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                b[x * 5 + y] = c[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            b_host[y] = a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            b_host[y%5] = b_host[y%5] & a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (b_host[y] != b[x * 5 + y]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitor_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int b = 0;\n    unsigned int host_b;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX > false_margin){\n                a[x] += 1 << y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel loop reduction(|:b)\n        for (int x = 0; x < n; ++x){\n            b = b | a[x];\n        }\n    }\n\n    host_b = a[0];\n    for (int x = 1; x < n; ++x){\n        host_b = host_b | a[x];\n    }\n\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(5 * n * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int b[5];\n    unsigned int host_b[5];\n\n    for (int x = 0; x < 5 * n; ++x){\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y) {\n            if (rand() / (real_t) RAND_MAX > false_margin) {\n                a[x] += 1 << y;\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        b[x] = 0;\n        host_b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:5*n])\n    {\n        #pragma acc parallel loop reduction(|:b)\n        for (int x = 0; x < 5 * n; ++x) {\n            b[x%5] = b[x%5] | a[x];\n        }\n    }\n\n    for (int x = 0; x < 5 * n; ++x){\n        host_b[x%5] = host_b[x%5] | a[x];\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        if (host_b[x] != b[x]) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitor_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int host_c;\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            b[x * n + y] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n            b_copy[x * n + y] = b[x * n + y];\n            for (int z = 0; z < 16; ++z){\n                a[x * n + y] += (1<<z);\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(|:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp | a[x * n + y];\n            }\n            c[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                b[x * n + y] = b[x * n + y] + c[x];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        host_c = a[x * n];\n        for (int y = 1; y < n; ++y){\n            host_c = host_c | a[x * n + y];\n        }\n        if (host_c != c[x]){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + host_c){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(25 * sizeof(unsigned int));\n    unsigned int temp[5];\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 25 * n; ++x){\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        for (int y = 0; y < 16; ++y) {\n            if (rand() / (real_t)RAND_MAX > false_margin) {\n                a[x] += (1<<y);\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copy(b[0:25*n], c[0:25])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                temp[y] = 0;\n            }\n            #pragma acc loop worker reduction(|:temp)\n            for (int y = 0; y < 5 * n; ++y) {\n                temp[y%5] = temp[y%5] | a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                c[x * 5 + y] = temp[y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * n; ++y) {\n                b[x * 5 * n + y] = b[x * 5 * n + y] + c[x * 5 + (y % 5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x){\n        for (int y = 0; y < 5; ++y){\n            temp[y] = 0;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            temp[y%5] = temp[y%5] | a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5; ++y){\n            if (c[x * 5 + y] != temp[y]) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            if ((b_copy[x * 5 * n + y] + c[x * 5 + (y % 5)]) != b[x * 5 * n + y]) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitor_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX > false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    temp = 0;\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(|:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp | a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host | a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));\n\n    unsigned int reduced[5];\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    \n    for (int x = 0; x < 25 * n; ++x) {\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y) {\n            if (rand() / (real_t)RAND_MAX > false_margin) {\n                a[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copy(b[0:25])\n    {\n        #pragma acc parallel loop private(reduced)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                reduced[y] = 0;\n            }\n            #pragma acc loop vector reduction(|:reduced)\n            for (int y = 0; y < 5 * n; ++y) {\n                reduced[y%5] = reduced[y%5] | a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                b[x * 5 + y] = reduced[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            reduced[y] = 0;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            reduced[y%5] = reduced[y%5] | a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (b[x * 5 + y] != reduced[y]) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitxor_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    unsigned int b = 0;\n    unsigned int host_b = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel loop reduction(^:b)\n        for (int x = 0; x < n; ++x){\n            b = b ^ a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        host_b = host_b ^ a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int b[10];\n    unsigned int host_b[10];\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        b[x] = 0;\n        host_b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n])\n    {\n        #pragma acc parallel loop reduction(^:b)\n        for (int x = 0; x < 10 * n; ++x) {\n            b[x % 10] = b[x % 10] ^ a[x];\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x) {\n        host_b[x % 10] = host_b[x % 10] ^ a[x];\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        if (host_b[x] != b[x]) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitxor_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int temp = 0;\n\n    for (int x = 0; x < 10*n; ++x){\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(^:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp ^ a[x * n + y];\n            }\n            c[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                b[x * n + y] = b[x * n + y] + c[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = temp ^ a[x * n + y];\n        }\n        if (temp != c[x]){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + c[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,nonvalidating,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(25 * sizeof(unsigned int));\n\n    unsigned int temp[5];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n    }\n\n    for (int x = 0; x < 25; ++x) {\n        c[x] = 0;\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        temp[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copy(b[0:25*n], c[0:25])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                temp[y] = 0;\n            }\n            #pragma acc loop worker reduction(^:temp)\n            for (int y = 0; y < 5 * n; ++y) {\n                temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                c[x * 5 + y] = temp[y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * n; ++y) {\n                b[x * 5 * n + y] = b[x * 5 * n + y] + c[x * 5 + (y % 5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            temp[y] = 0;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];\n        }\n        \n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitxor_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    unsigned int temp = 0;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(^:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp ^ a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host ^ a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));\n\n    unsigned int temp[5];\n\n    for (int x = 0; x < 25 * n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copy(b[0:25])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y){\n                temp[y] = 0;\n            }\n            #pragma acc loop vector reduction(^:temp)\n            for (int y = 0; y < 5 * n; ++y) {\n                temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                b[x * 5 + y] = temp[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            temp[y] = 0;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (b[x * 5 + y] != temp[y]) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_max_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t max = 0.0;\n    int found = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(max:max)\n        for (int x = 0; x < n; ++x){\n            max = fmax(a[x] * b[x], max);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(max - (a[x] * b[x] + PRECISION)) < 0){\n            err = 1;\n        }\n        if (fabs(max - (a[x] * b[x] - PRECISION)) > 0){\n            found = 1;\n        }\n    }\n    if (found = 0){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t maximums[10];\n    real_t max_host[10];\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        maximums[x] = 0;\n        max_host[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n])\n    {\n        #pragma acc parallel loop reduction(max:maximums)\n        for (int x = 0; x < 10 * n; ++x) {\n            maximums[x%10] = fmax(a[x] * b[x], maximums[x%10]);\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x) {\n        max_host[x%10] = fmax(a[x] * b[x], maximums[x%10]);\n    }\n    \n    for (int x = 0; x < 10; ++x) {\n        if (fabs(max_host[x] - maximums[x]) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_max_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * maximum = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n    real_t max = 0.0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n        c[x] = 0.0;\n    }\n    for (int x = 0; x < 10; ++x){\n        maximum[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], maximum[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(max:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmax(a[x * n + y] * b[x * n + y], temp);\n            }\n            maximum[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / maximum[x];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = fmax(temp, a[x * n + y] * b[x * n + y]);\n        }\n        if (fabs(temp - maximum[x]) > PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (c[x * n + y] > 1){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * maximum = (real_t *)malloc(25 * sizeof(real_t));\n    real_t * host_maximum = (real_t *)malloc(25 * sizeof(real_t));\n    real_t temp[5];\n\n    for (int x = 0; x < 25 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    for (int x = 0; x < 25; ++x) {\n        maximum[x] = 0;\n        host_maximum[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(c[0:25*n], maximum[0:25])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                temp[y] = 0;\n            }\n            #pragma acc loop worker reduction(max:temp)\n            for (int y = 0; y < 5 * n; ++y) {\n                temp[y%5] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], temp[y%5]);\n            }\n            for (int y = 0; y < 5; ++y) {\n                maximum[x * 5 + y] = temp[y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * n; ++y) {\n                c[x * 5 * n + y] = (a[x * 5 * n + y] * b[x * 5 * n + y]) / maximum[x * 5 + (y % 5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5 * n; ++y) {\n            host_maximum[x * 5 + (y % 5)] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], host_maximum[x * 5 + (y % 5)]);\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (fabs(host_maximum[x * 5 + y] - maximum[x * 5 + y]) > PRECISION) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            if (fabs(c[x * 5 * n + y] - ((a[x * 5 * n + y] * b[x * 5 * n + y]) / maximum[x * 5 + (y % 5)])) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_max_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * max = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n    real_t temp_max;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(max[0:10])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(max:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmax(a[x * n + y] * b[x * n + y], temp);\n            }\n            max[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp_max = 0;\n        for (int y = 0; y < n; ++y){\n            if (temp_max < a[x * n + y] * b[x * n + y]){\n                temp_max = a[x * n + y] * b[x * n + y];\n            }\n        }\n        if (fabs(temp_max - max[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * maximums = (real_t *)malloc(25 * sizeof(real_t));\n    real_t reduced[5];\n\n    for (int x = 0; x < 25 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    for (int x = 0; x < 25; ++x) {\n        maximums[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(maximums[0:25])\n    {\n        #pragma acc parallel loop private(reduced)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                reduced[y] = 0;\n            }\n            #pragma acc loop vector reduction(max:reduced)\n            for (int y = 0; y < 5 * n; ++y) {\n                reduced[y%5] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);\n            }\n            for (int y = 0; y < 5; ++y) {\n                maximums[x * 5 + y] = reduced[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            reduced[y] = 0;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            reduced[y%5] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (fabs(maximums[x * 5 + y] - reduced[y]) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_min_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t min = 1000.0;\n    int found = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(min)\n    {\n        #pragma acc parallel loop reduction(min:min)\n        for (int x = 0; x < n; ++x){\n            min = fmin(a[x] * b[x], min);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs((a[x] * b[x]) - (min + PRECISION)) < 0){\n            err = 1;\n        }\n        if (fabs(min - (a[x] * b[x])) < PRECISION){\n            found = 1;\n        }\n    }\n    if (found == 0){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t minimums[10];\n    real_t host_minimums[10];\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        minimums[x] = 1000;\n        host_minimums[x] = 1000;\n    }\n\n    printf(\"Here\");\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n])\n    {\n        #pragma acc parallel loop reduction(min:minimums)\n        for (int x = 0; x < 10 * n; ++x) {\n            minimums[x%10] = fmin(a[x] * b[x], minimums[x%10]);\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x) {\n        host_minimums[x%10] = fmin(a[x] * b[x], host_minimums[x%10]);\n    }\n    for (int x = 0; x < 10; ++x) {\n        if (fabs(minimums[x] - host_minimums[x]) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_min_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * minimum = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = 1 + rand() / (real_t)(RAND_MAX/10);\n        b[x] = 1 + rand() / (real_t)(RAND_MAX/10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], minimum[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1000;\n            #pragma acc loop reduction(min:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmin(a[x * n + y] * b[x * n + y], temp);\n            }\n            minimum[x] = temp;\n            #pragma acc loop\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / minimum[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 1000;\n        for (int y = 0; y < n; ++y){\n            temp = fmin(temp, a[x * n + y] * b[x * n + y]);\n        }\n        if (fabs(temp - minimum[x]) > PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x * n + y] - (a[x * n + y] * b[x * n + y] / minimum[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t minimums[25];\n    real_t host_minimums[25];\n    real_t reduced[5];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1 + rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 1 + rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(minimums[0:25], c[0:25*n])\n    {\n        #pragma acc parallel loop gang private(reduced)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                reduced[y] = 1000;\n            }\n            #pragma acc loop reduction(min:reduced)\n            for (int y = 0; y < 5 * n; ++y) {\n                reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);\n            }\n            for (int y = 0; y < 5; ++y) {\n                minimums[x * 5 + y] = reduced[y];\n            }\n            #pragma acc loop\n            for (int y = 0; y < 5 * n; ++y) {\n                c[x * 5 * n + y] = (a[x * 5 * n + y] * b[x * 5 * n + y]) / minimums[x * 5 + (y % 5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            reduced[y] = 1000;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);\n        }\n        for (int y = 0; y < 5; ++y) {\n            host_minimums[x * 5 + y] = reduced[y];\n            if (fabs(host_minimums[x * 5 + y] - minimums[x * 5 + y]) > PRECISION) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            if (fabs(c[x * 5 * n + y] - ((a[x * 5 * n + y] * b[x * 5 * n + y]) / minimums[x * 5 + (y % 5)])) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_min_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * min = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 100;\n    real_t temp_min;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(min[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 100;\n            #pragma acc loop vector reduction(min:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmin(a[x * n + y] * b[x * n + y], temp);\n            }\n            min[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp_min = 100;\n        for (int y = 0; y < n; ++y){\n            if (temp_min > a[x * n + y] * b[x * n + y]){\n                temp_min = a[x * n + y] * b[x * n + y];\n            }\n        }\n        if (fabs(temp_min - min[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * minimums = (real_t *)malloc(25 * sizeof(real_t));\n    real_t reduced[5];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(minimums[0:25])\n    {\n        #pragma acc parallel loop gang private(reduced)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                reduced[y] = 1000;\n            }\n            #pragma acc loop vector reduction(min:reduced)\n            for (int y = 0; y < 5 * n; ++y) {\n                reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y % 5]);\n            }\n            for (int y = 0; y < 5; ++y) {\n                minimums[x * 5 + y] = reduced[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            reduced[y] = 1000;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y % 5]);\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (fabs(reduced[y] - minimums[x * 5 + y]) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_multiply_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    int multiplicitive_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(multiplicitive_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(multiplicitive_n * sizeof(real_t));\n\n    real_t multiplied_total = 1.0;\n\n    for (int x = 0; x < multiplicitive_n; ++x){\n        a[x] = rand() / (real_t) RAND_MAX;\n        b[x] = rand() / (real_t) RAND_MAX;\n    }\n\n    #pragma acc data copyin(a[0:multiplicitive_n], b[0:multiplicitive_n]) copy(multiplied_total)\n    {\n        #pragma acc parallel loop reduction(*:multiplied_total)\n        for (int x = 0; x < multiplicitive_n; ++x){\n            multiplied_total *= a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < multiplicitive_n; ++x){\n        multiplied_total /= (a[x] + b[x]);\n    }\n    if (fabs(multiplied_total - 1) > PRECISION * (2 * multiplicitive_n - 1)){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    int m_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * m_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * m_n * sizeof(real_t));\n\n    real_t multiplicitive_total[10];\n\n    for (int x = 0; x < m_n; ++x){\n        a[x] = rand() / (real_t) RAND_MAX;\n        b[x] = rand() / (real_t) RAND_MAX;\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        multiplicitive_total[x] = 1.0;\n    }\n\n    #pragma acc data copyin(a[0:10*m_n], b[0:10*m_n])\n    {\n        #pragma acc parallel loop reduction(*:multiplicitive_total)\n        for (int x = 0; x < 10 * m_n; ++x) {\n            multiplicitive_total[x%10] = multiplicitive_total[x%10] * (a[x] + b[x]);\n        }\n    }\n\n    for (int x = 0; x < 10 * m_n; ++x) {\n        multiplicitive_total[x%10] /= (a[x] + b[x]);\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        if (fabs(multiplicitive_total[x]) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_multiply_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    int m_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * m_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * m_n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * m_n * sizeof(real_t));\n    real_t * totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < 10 * m_n; ++x){\n        a[x] = .05 + rand() / (real_t)(RAND_MAX);\n        b[x] = .05 + rand() / (real_t)(RAND_MAX);\n        c[x] = 0.0;\n    }\n\n\n    #pragma acc data copyin(a[0:10*m_n], b[0:10*m_n]) copyout(c[0:10*m_n], totals[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop worker reduction(*:temp)\n            for (int y = 0; y < m_n; ++y){\n                temp *= a[x * m_n + y] + b[x * m_n + y];\n            }\n            totals[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < m_n; ++y){\n                c[x * m_n + y] = (a[x * m_n + y] + b[x * m_n + y]) / totals[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 1;\n        for (int y = 0; y < m_n; ++y){\n            temp *= a[x * m_n + y] + b[x * m_n + y];\n        }\n        if (fabs(temp - totals[x]) > (temp / 2 + totals[x] / 2) * PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < m_n; ++y){\n            if (fabs(c[x * m_n + y] - ((a[x * m_n + y] + b[x * m_n + y]) / totals[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    int m_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(25 * m_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(25 * m_n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(25 * m_n * sizeof(real_t));\n\n    real_t * totals = (real_t *)malloc(25 * sizeof(real_t));\n    real_t reduced[5];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = .05 + rand() / (real_t)(RAND_MAX / 10);\n        b[x] = .05 + rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*m_n], b[0:25*m_n]) copyout(c[0:25*m_n], totals[0:25])\n    {\n        #pragma acc parallel loop gang private(reduced)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                reduced[y] = 1.0;\n            }\n            #pragma acc loop worker reduction(*:reduced)\n            for (int y = 0; y < 5 * m_n; ++y) {\n                reduced[y%5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                totals[x * 5 + y] = reduced[y];\n            }\n            for (int y = 0; y < 5 * m_n; ++y) {\n                c[x * 5 * m_n + y] = (a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[x * 5 + (y%5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            reduced[y] = 1;\n        }\n        for (int y = 0; y < 5 * m_n; ++y) {\n            reduced[y%5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (fabs(totals[x * 5 + y] - reduced[y]) > PRECISION) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5 * m_n; ++y) {\n            if (fabs(c[x * 5 * m_n + y] - ((a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[x * 5 + (y % 5)])) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_multiply_vector_loop.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1() {\n    int err = 0;\n    int multiplicitive_n = 128;\n    srand(SEED);\n    real_t* a = (real_t*)malloc(10 * multiplicitive_n * sizeof(real_t));\n    real_t* b = (real_t*)malloc(10 * multiplicitive_n * sizeof(real_t));\n    real_t* c = (real_t*)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < 10 * multiplicitive_n; ++x) {\n        a[x] = rand() / (real_t)RAND_MAX;\n        b[x] = rand() / (real_t)RAND_MAX;\n    }\n\n#pragma acc data copyin(a[0:10*multiplicitive_n], b[0:10*multiplicitive_n]) copyout(c[0:10])\n    {\n#pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x) {\n            temp = 1.0;\n#pragma acc loop vector reduction(*:temp)\n            for (int y = 0; y < multiplicitive_n; ++y) {\n                temp *= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];\n            }\n            c[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        for (int y = 0; y < multiplicitive_n; ++y) {\n            c[x] /= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];\n        }\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        if (fabs(c[x] - 1) > PRECISION* (4 * multiplicitive_n - 1)) {\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2() {\n    int err = 0;\n    int m_n = 128;\n    srand(SEED);\n    real_t* a = (real_t*)malloc(25 * m_n * sizeof(real_t));\n    real_t* b = (real_t*)malloc(25 * m_n * sizeof(real_t));\n    real_t* c = (real_t*)malloc(25 * m_n * sizeof(real_t));\n    real_t* totals = (real_t*)malloc(25 * sizeof(real_t));\n    real_t reduced[5];\n\n    for (int x = 0; x < n; ++x) {\n        a[x] = .05 + rand() / (real_t)(RAND_MAX / 10);\n        b[x] = .05 + rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*m_n], b[0:25*m_n]) copyout(c[0:25*m_n], totals[0:25])\n    {\n        #pragma acc parallel loop gang private(reduced)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                reduced[y] = 1.0;\n            }\n            #pragma acc loop worker reduction(*:reduced)\n            for (int y = 0; y < 5 * m_n; ++y) {\n                reduced[y % 5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                totals[x * 5 + y] = reduced[y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * m_n; ++y) {\n                c[x * 5 * m_n + y] = (a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[(x * 5) + (y % 5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            reduced[y] = 1;\n        }\n        for (int y = 0; y < 5 * m_n; ++y) {\n            reduced[y % 5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (fabs(totals[x * 5 + y] - reduced[y]) > PRECISION) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5 * m_n; ++y) {\n            if (fabs(c[x * 5 * m_n + y] - ((a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[x * 5 + (y % 5)])) > PRECISION){\n                err += 1;\n            }   \n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            ""
                        ],
                        "versions": []
                    }
                }
            },
            "parallel_loop_reduction_or_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char result = 0;\n    char found = 0;\n\n    for (int x = 0; x < n; ++x){\n        if(rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel loop reduction(||:result)\n        for (int x = 0; x < n; ++x){\n            result = result || a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (a[x] == 1){\n            found = 1;\n        }\n    }\n    if (found != result){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    char* a = (char *)malloc(5 * n * sizeof(char));\n    char result[5];\n    char host_result[5];\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 5; ++x) {\n        result[x] = 0;\n        host_result[x] = 0;\n    }\n\n    for (int x = 0; x < 5 * n; ++x) {\n        if (rand() / (real_t)(RAND_MAX) > false_margin) {\n            a[x] = 1;\n        }\n        else {\n            a[x] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:5*n])\n    {\n        #pragma acc parallel loop reduction(||:result)\n        for (int x = 0; x < 5 * n; ++x) {\n            result[x%5] = result[x%5] || a[x];\n        }\n    }\n\n    for (int x = 0; x < 5 * n; ++x) {\n        host_result[x%5] = host_result[x%5] || a[x];\n    }\n    \n    for (int x = 0; x < 5; ++x) {\n        if (host_result[x] != result[x]) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_or_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * a_copy = (char *)malloc(10 * n * sizeof(char));\n    char * results = (char *)malloc(10 * sizeof(char));\n    char temp = 0;\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 10 * n; ++x){\n        if (rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n            a_copy[x] = 1;\n        }\n        else{\n            a[x] = 0;\n            a_copy[x] = 0;\n        }\n    }\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(||:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp || a[x * n + y];\n            }\n            results[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                if(results[x] == 1){\n                    if (a[x * n + y] == 1){\n                        a[x * n + y] = 0;\n                    }\n                    else{\n                        a[x * n + y] = 1;\n                    }\n                }\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = temp || a_copy[x * n + y];\n        }\n        if (temp != results[x]) {\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (temp == 1){\n                if (a[x * n + y] == a_copy[x * n + y]){\n                    err += 1;\n                }\n            }\n            else {\n                if (a[x * n + y] != a_copy[x * n + y]){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_or_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char temp = 0;\n    char found;\n\n    for (int x = 0; x < 10 * n; ++x){\n        if(rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(||:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp || a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        found = 0;\n        for (int y = 0; y < n; ++y){\n            if (a[x * n + y] &! 0){\n                found = 1;\n            }\n        }\n        if (found != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_seq.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel loop seq\n        for (int x = 1; x < n; ++x){\n            b[x] = b[x-1] + a[x];\n        }\n    }\n\n    for (int x = 1; x < n; ++x){\n        temp += a[x];\n        if (fabs(b[x] - temp) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_tile.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,tile,reduction,combined-constructs,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));\n    real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copy(a[0:n], b[0:n], c[0:n], d2[0:n*n])\n    {\n        #pragma acc parallel loop tile(*, *) reduction(+:temp)\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                temp = 0;\n                for (int z = 0; z < n; ++z){\n                    temp += a[x] + b[y] + c[z];\n                }\n                d2[x * n + y] = temp;\n            }\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            temp = 0.0;\n            for (int z = 0; z < n; ++z){\n                temp += a[x] + b[y] + c[z];\n            }\n            if (fabs(temp - d2[x * n + y]) > PRECISION * n){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "tile",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,loop,tile,combined-constructs,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));\n    real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d3[0:n*n*n])\n    {\n        #pragma acc parallel loop tile(2, 4, 8)\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                for (int z = 0; z < n; ++z){\n                    d3[(n * n * x) + (n * y) + z] = a[x] + b[x] + c[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            for (int z = 0; z < n; ++z){\n                if (fabs(d3[(n * n * x) + (n * y) + z] - a[x] - b[x] - c[x]) > PRECISION * 2){\n                    err = 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "tile",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_vector.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,vector,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc parallel loop vector\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if(fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "vector",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_vector_blocking.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,V:1.0-2.7\nint test1(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t * c = (real_t *)malloc(n * sizeof(real_t));\n  real_t multiplyer = 1;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = 0.0;\n  }\n\n  #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n  {\n    #pragma acc parallel\n    {\n      #pragma acc loop vector\n      for (int x = 0; x < n; ++x){\n        c[x] = (a[x] + b[x]) * multiplyer;\n      }\n      multiplyer += 1;\n      #pragma acc loop vector\n      for (int x = 0; x < n; ++x){\n        c[x] += (a[x] + b[x]) * multiplyer;\n      }\n    }\n  }\n\n  for (int x = 0; x < n; ++x){\n    if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){\n      err + 1;\n      break;\n    }\n  }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_worker.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc parallel loop worker\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_worker_blocking.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t multiplyer = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n      #pragma acc parallel\n      {\n        #pragma acc loop worker\n        for (int x = 0; x < n; ++x){\n          c[x] = (a[x] + b[x]) * multiplyer;\n        }\n        multiplyer += 1;\n        #pragma acc loop worker\n        for (int x = 0; x < n; ++x){\n          c[x] += (a[x] + b[x]) * multiplyer;\n        }\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n      if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){\n        err + 1;\n        break;\n      }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,present,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "present"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_private.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,private,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x * n + y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x * n + y] = rand() / (real_t)(RAND_MAX / 10);\n            c[y] = 0.0;\n        }\n        d[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:10*n], b[0:10*n], d[0:10])\n    #pragma acc parallel num_gangs(10) private(c[0:n])\n    {\n        #pragma acc loop gang\n        for (int x = 0; x < 10; ++x){\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[y] = a[x * n + y] + b[x * n + y];\n            }\n            #pragma acc loop seq\n            for (int y = 0; y < n; ++y){\n                d[x] += c[y];\n            }\n        }\n    }\n    #pragma acc exit data copyout(d[0:10]) delete(a[0:10*n], b[0:10*n])\n\n    real_t temp;\n    for (int x = 0; x < 10; ++x){\n        temp = 0.0;\n        for (int y = 0; y < n; ++y){\n            temp += a[x * n + y] + b[x * n + y];\n        }\n        if (fabs(temp - d[x]) > (2 * PRECISION * n)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_reduction.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,reduction,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t reduction;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc parallel copyin(a[0:n]) reduction(+:reduction)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            reduction = reduction + a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        reduction = reduction - a[x];\n    }\n    if (fabs(reduction) > PRECISION){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_scalar_default_firstprivate.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,data-region,default-mapping,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t scalar = rand() / (real_t)(RAND_MAX / 10);\n    real_t scalar_copy = scalar;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + scalar;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + scalar_copy)) > PRECISION){\n            err += 1;\n        }\n    }\n    if (fabs(scalar_copy - scalar) > PRECISION){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region",
                            "default-mapping"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_switch.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,syntactic,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int * a = (int *)malloc(n * sizeof(int));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t tempc = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = floor(rand() / (real_t)(RAND_MAX / 10));\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        b_host[x] = b[x];\n        c[x] = 0.0;\n    }\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            switch(a[x]){\n                case 0:\n                    c[x] = b[x] * b[x];\n                    break;\n                case 1:\n                    c[x] = b[x] / b[x];\n                    break;\n                case 2:\n                    b[x] = b[x] / 2;\n                default:\n                    c[x] = a[x] + b[x];\n\n\n            }\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        switch(a[x]){\n            case 0:\n                tempc = b_host[x] * b_host[x];\n                break;\n            case 1:\n                tempc = b_host[x] / b_host[x];\n                break;\n            case 2:\n                b_host[x] = b_host[x] / 2;\n            default:\n                tempc = a[x] + b_host[x];\n        }\n        if (fabs(c[x] - tempc) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "syntactic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_wait.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,wait,async,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc enter data create(a[0:n])\n    #pragma acc update device(a[0:n]) async(1)\n    #pragma acc parallel present(a[0:n]) wait(1)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] += 1;\n        }\n    }\n    #pragma acc exit data copyout(a[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] + 1)) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "wait",
                            "async"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_while_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,syntactic,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t avg = 0.0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        avg += a[x]/(n * 10);\n    }\n\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc parallel\n        {\n            real_t avg = 0.0;\n            #pragma acc loop\n            for (int y = 0; y < 10; ++y){\n                avg = 0.0;\n                while (avg - 1000 < PRECISION * n){\n                    avg = 0.0;\n                    #pragma acc loop reduction(+:avg)\n                    for (int x = 0; x < n; ++x){\n                        a[n * y + x] *= 1.5;\n                        avg += a[n * y + x] / n;\n                    }\n                }\n            }\n        }\n    }\n\n    avg = 0.0;\n    for (int x = 0; x < n; ++x){\n        avg += a[x]/n;\n    }\n\n    if (avg < 1000 || avg > 1600){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "syntactic"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "routine_bind.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:routine,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t **a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int on_host = (acc_get_device_type() == acc_device_none);\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop gang worker vector\n            for (int x = 0; x < n; ++x){\n                b[x] = host_function_identifier_unnamed(a[x], n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if ((!on_host) && (fabs(host_function_identifier_unnamed(a[x], n) + b[x]) > PRECISION)){\n            err += 1;\n            return 1;\n        }\n        else if ((on_host) && (fabs(host_function_identifier_unnamed(a[x], n) - b[x]) > PRECISION)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:routine,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t **a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int on_host = (acc_get_device_type() == acc_device_none);\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop gang worker vector\n            for (int x = 0; x < n; ++x){\n                b[x] = host_function_string_unnamed(a[x], n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!on_host && fabs(host_function_string_unnamed(a[x], n) + b[x]) > PRECISION){\n            err += 1;\n        }\n        else if (on_host && fabs(host_function_string_unnamed(a[x], n) - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:routine,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t **a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int on_host = (acc_get_device_type() == acc_device_none);\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop gang worker vector\n            for (int x = 0; x < n; ++x){\n                b[x] = host_function_identifier_named(a[x], n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!on_host && fabs(host_function_identifier_named(a[x], n) + b[x]) > PRECISION){\n            err += 1;\n        }\n        else if (on_host && fabs(host_function_identifier_named(a[x], n) - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:routine,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t **a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int on_host = (acc_get_device_type() == acc_device_none);\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop gang worker vector\n            for (int x = 0; x < n; ++x){\n                b[x] = host_function_string_named(a[x], n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!on_host && fabs(host_function_string_named(a[x], n) + b[x]) > PRECISION){\n            err += 1;\n        }\n        else if (on_host && fabs(host_function_string_named(a[x], n) - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "routine_gang.c": {
                "num tests": 10,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:routine,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x)\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n              test_routine_gang_loop_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "10": {
                        "content": "#ifndef T10\n//T10:routine,construct-independent,V:2.0-2.7\nint test10(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_seq_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T10\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test10();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 9);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:routine,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_loop_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:routine,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_gang_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:routine,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_gang_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:routine,construct-independent,V:2.0-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_worker_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n//T6:routine,construct-independent,V:2.0-2.7\nint test6(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_worker_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T6\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test6();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 5);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "7": {
                        "content": "#ifndef T7\n//T7:routine,construct-independent,V:2.0-2.7\nint test7(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_vector_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T7\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test7();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 6);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "8": {
                        "content": "#ifndef T8\n//T8:routine,construct-independent,V:2.0-2.7\nint test8(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_vector_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T8\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test8();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 7);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "9": {
                        "content": "#ifndef T9\n//T9:routine,construct-independent,V:2.0-2.7\nint test9(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_seq_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T9\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test9();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 8);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "routine_nohost.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:routine,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t summation;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop gang\n            for (int x = 0; x < n; ++x){\n                b[x] = function(a[x], n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        summation = 0;\n        for (int y = 0; y < n; ++y){\n            summation += a[x][y];\n        }\n        if (fabs(summation - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "routine_seq.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:routine,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n              test_routine_seq_loop_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:routine,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_seq_loop_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:routine,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_seq_seq_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:routine,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_seq_seq_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "routine_vector.c": {
                "num tests": 6,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:routine,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n              test_routine_vector_loop_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:routine,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_vector_loop_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:routine,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_vector_vector_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:routine,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_vector_vector_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:routine,construct-independent,V:2.0-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_vector_seq_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n//T6:routine,construct-independent,V:2.0-2.7\nint test6(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_vector_seq_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T6\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test6();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 5);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "routine_worker.c": {
                "num tests": 8,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:routine,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n              test_routine_worker_loop_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:routine,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_loop_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:routine,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_worker_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:routine,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_worker_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:routine,construct-independent,V:2.0-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_vector_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n//T6:routine,construct-independent,V:2.0-2.7\nint test6(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_vector_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T6\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test6();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 5);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "7": {
                        "content": "#ifndef T7\n//T7:routine,construct-independent,V:2.0-2.7\nint test7(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_seq_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T7\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test7();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 6);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "8": {
                        "content": "#ifndef T8\n//T8:routine,construct-independent,V:2.0-2.7\nint test8(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_seq_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T8\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test8();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 7);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t* a = (real_t *) malloc(1024 * sizeof(real_t));\n    real_t* b = (real_t *) malloc(1024 * sizeof(real_t));\n    real_t* c = (real_t *) malloc(1024 * sizeof(real_t));\n\n    for(int x = 0; x < 1024; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:1024], b[0:1024]) copy(c[0:1024])\n    {\n        #pragma acc serial\n        {\n            #pragma acc loop\n            for (int _0 = 0; _0 < 2; ++_0){\n                #pragma acc loop\n                for (int _1 = 0; _1 < 2; ++_1){\n                    #pragma acc loop\n                    for (int _2 = 0; _2 < 2; ++_2){\n                        #pragma acc loop\n                        for (int _3 = 0; _3 < 2; ++_3){\n                            #pragma acc loop\n                            for (int _4 = 0; _4 < 2; ++_4){\n                                #pragma acc loop\n                                for (int _5 = 0; _5 < 2; ++_5){\n                                    #pragma acc loop\n                                    for (int _6 = 0; _6 < 2; ++_6){\n                                        #pragma acc loop\n                                        for (int _7 = 0; _7 < 2; ++_7){\n                                            #pragma acc loop\n                                            for (int _8 = 0; _8 < 2; ++_8){\n                                                #pragma acc loop\n                                                for (int _9 = 0; _9 < 2; ++_9){\n                                                    c[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] =\n                                                    a[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] +\n                                                    b[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9];\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 1024; ++x){\n        if(fabs(c[x] - (a[x] +b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,async,wait,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(n * sizeof(real_t));\n    real_t * e = (real_t *)malloc(n * sizeof(real_t));\n    real_t * f = (real_t *)malloc(n * sizeof(real_t));\n    real_t * g = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0.0;\n        g[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], c[0:n], f[0:n], g[0:n])\n    {\n        #pragma acc serial async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc serial async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        #pragma acc serial wait(1, 2) async(3)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                g[x] = c[x] + f[x];\n            }\n        }\n        #pragma acc update host(c[0:n]) async(1)\n        #pragma acc update host(f[0:n]) async(2)\n        #pragma acc update host(g[0:n]) async(3)\n\n        #pragma acc wait(1)\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n        #pragma acc wait(2)\n        for (int x = 0; x < n; ++x){\n            if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n                err += 1;\n            }\n        }\n        #pragma acc wait(3)\n        for (int x = 0; x < n; ++x){\n            if (fabs(g[x] - (a[x] + b[x] + d[x] + e[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "async",
                            "wait"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_copy.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_host[x] = a[x];\n    }\n\n    #pragma acc serial copy(a[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 2 * a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (2 * a_host[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_copyin.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int* hasDevice = (int *) malloc(sizeof(int));\n    hasDevice[0] = 1;\n    #pragma acc enter data copyin(hasDevice[0:1])\n    #pragma acc parallel present(hasDevice[0:1])\n    {\n      hasDevice[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_copy[x] = a[x];\n        b[x] = 0.0;\n    }\n\n    #pragma acc serial copyin(a[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 0.0;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (((fabs(a[x] - a_copy[x]) > PRECISION) && (hasDevice[0] == 1)) || ((hasDevice[0] == 0) && (fabs(a[x]) > PRECISION))){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,data,data-region,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copy(b[0:n])\n    {\n        #pragma acc serial copyin(a[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_copyout.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int* hasDevice = (int *) malloc(sizeof(int));\n    hasDevice[0] = 1;\n    #pragma acc enter data copyin(hasDevice[0:1])\n    #pragma acc serial present(hasDevice[0:1])\n    {\n      hasDevice[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc serial copyout(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,data,data-region,reference-counting,devonly,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int* hasDevice = (int *) malloc(sizeof(int));\n    hasDevice[0] = 1;\n    #pragma acc enter data copyin(hasDevice[0:1])\n    #pragma acc serial present(hasDevice[0:1])\n    {\n      hasDevice[0] = 0;\n    }\n\n    if (hasDevice[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = 0;\n        }\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc serial copyout(b[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n        for (int x = 0; x < n; ++x){\n            if (fabs(b[x]) > PRECISION){\n                err += 2;\n                break;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region",
                            "reference-counting",
                            "devonly"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:serial,data,data-region,reference-counting,V:2.6-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int* hasDevice = (int *) malloc(sizeof(int));\n    hasDevice[0] = 1;\n    #pragma acc enter data copyin(hasDevice[0:1])\n    #pragma acc serial present(hasDevice[0:1])\n    {\n      hasDevice[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc serial copyout(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n        #pragma acc update host(b[0:n])\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - a[x]) > PRECISION){\n            err += 4;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_create.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(c[0:n])\n    {\n        #pragma acc serial create(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - c[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_default_copy.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,default-mapping,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc serial\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region",
                            "default-mapping"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,data,data-region,default-mapping,devonly,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(real_t));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 1;\n        }\n\n        #pragma acc enter data copyin(c[0:n])\n        for (int x = 0; x < n; ++x){\n            c[x] = 0.0;\n        }\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc serial\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err += 1;\n            }\n        }\n\n        #pragma acc exit data copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region",
                            "default-mapping",
                            "devonly"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_default_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,default,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0.0;\n    }\n    #pragma acc enter data copyin(a[0:n])\n    #pragma acc serial default(present)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 1.0;\n        }\n    }\n    #pragma acc exit data copyout(a[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - 1.0) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region",
                            "default"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_deviceptr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n])\n    b = (real_t *) acc_deviceptr(a);\n    if (b == NULL){\n        err = 1;\n    }\n    else{\n        #pragma acc serial deviceptr(b)\n        {\n            #pragma acc loop\n            for (int x = 0; x < (int) n/2; ++x){\n                b[x] = 1;\n            }\n        }\n        #pragma acc exit data copyout(a[0:n])\n    }\n    for (int x = 0; x < n; ++x){\n        if (x < (int) n/2){\n            if (fabs(a[x] - 1) > PRECISION){\n                err = 1;\n            }\n        }\n        else {\n            if (fabs(a[x]) > PRECISION){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_firstprivate.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,firstprivate,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * c_copy = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10*n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        d[x] = 0.0;\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n        c_copy[x] = c[x];\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])\n    {\n        #pragma acc serial firstprivate(c[0:n])\n        {\n            #pragma acc loop gang\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop worker\n                for (int y = 0; y < 10; ++y){\n                    d[x * 10 + y] = a[x * 10 + y] + b[x * 10 + y] + c[y];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 10; ++y){\n            if (fabs(d[x * 10 + y] - (a[x * 10 + y] + b[x * 10 + y] + c_copy[y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "firstprivate"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,firstprivate,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * c_copy = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10*n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        d[x] = 0.0;\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])\n    {\n        #pragma acc serial firstprivate(c[0:n])\n        {\n            #pragma acc loop gang independent\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop worker independent\n                for (int y = 0; y < 10; ++y){\n                    c[y] = a[x * 10 + y] - b[x * 10 + y];\n                }\n                #pragma acc loop worker independent\n                for (int y = 0; y < 10; ++y){\n                    d[x * 10 + y] = a[x * 10 + y] + b[x * 10 + y] + c[y];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x){\n        if (fabs(d[x] - 2 * a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "firstprivate"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_if.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,if,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int accel = 1;\n    int host = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n    #pragma acc serial if(host)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "if"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,if,devonly,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int accel = 1;\n    int host = 0;\n    int * devtest = (int *)malloc(sizeof(int));\n    devtest[0] = 1;\n    #pragma acc data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n        #pragma acc serial if(host) present(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n        #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "if",
                            "devonly"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:serial,if,V:2.6-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int accel = 1;\n    int host = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc serial if(accel) present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] += a[x] + b[x];\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION * 2){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "if"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0;\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc serial loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 1.0;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - 1.0) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,loop,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n      a[x] = 0.0;\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copy(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc serial\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = b[x];\n            }\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] += c[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] + c[x])) > PRECISION * 2){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,async,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n\t\tint * errors = (int *)malloc(10 * sizeof(int));\n\n\t\tfor (int x = 0; x < 10; ++x){\n\t\t\terrors[x] = 0;\n\t\t}\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n        d[x] = a[x] + b[x];\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n], c[0:10*n], d[0:10*n]) copy(errors[0:10])\n    {\n        for (int x = 0; x < 10; ++x){\n            #pragma acc serial loop async(x)\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = a[x * n + y] + b[x * n + y];\n            }\n            #pragma acc serial loop async(x)\n            for (int y = 0; y < n; ++y){\n                if(c[x * n + y] - d[x * n + y] > PRECISION || d[x * n + y] - c[x * n + y] > PRECISION){\n                    errors[x] += 1;\n                }\n            }\n        }\n\t\t\t\t#pragma acc wait\n    }\n\n    for (int x = 0; x < 10; ++x){\n        err += errors[x];\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "async",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_auto.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,auto,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t rolling_total = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n      #pragma acc serial loop auto\n      for (int x = 0; x < n; ++x){\n        b[x] = a[x];\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n      if (fabs(b[x] - a[x]) > PRECISION){\n        err = 1;\n      }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "auto"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,loop,combined-constructs,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t rolling_total = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_copy[x] = a[x];\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n      #pragma acc serial loop auto\n      for (int x = 1; x < n; ++x){\n        a[x] = a[x - 1] + a[x];\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n      rolling_total += a_copy[x];\n      if (fabs(rolling_total - a[x]) > PRECISION){\n        err = 1;\n      }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_gang.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc serial loop gang\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_add_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc serial loop reduction(+:total)\n        for (int x = 0; x < n; ++x){\n            total += a[x] + b[x];\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        total -= a[x] + b[x];\n    }\n    if (fabs(total - 10) > PRECISION * (2 * n - 1)){ //199 = # of mathematical operations necessary\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_add_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t avg = 0.0;\n    real_t rolling_total = 0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) create(c[0:10*n]) copyout(d[0:10*n])\n    {\n        #pragma acc serial loop gang private(avg)\n        for (int x = 0; x < 10; ++x){\n            avg = 0;\n            #pragma acc loop worker reduction(+:avg)\n            for (int y = 0; y < n; ++y){\n                avg += c[x * n + y] = a[x * n + y] + b[x * n + y];\n            }\n            avg = avg / n;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                d[x * n + y] = c[x * n + y] - avg;\n            }\n        }\n    }\n\n\n    for (int x = 0; x < 10; ++x){\n        rolling_total = 0;\n        for (int y = 0; y < n; ++y){\n            rolling_total += a[x * n + y] + b[x * n + y];\n        }\n        rolling_total = rolling_total / n;\n        for (int y = 0; y < n; ++y){\n            if (fabs(d[x * n + y] - ((a[x * n + y] + b[x * n + y]) - rolling_total)) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_add_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for(int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0.0;\n            #pragma acc loop vector reduction(+:temp)\n            for (int y = 0; y < n; ++y){\n                temp += a[(x * n) + y] + b[(x * n) + y];\n            }\n            c[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            c[x] -= a[(x * n) + y] + b[(x * n) + y];\n        }\n        if (fabs(c[x]) > PRECISION * (2 * n - 1)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_and_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char result = 1;\n    char found = 0;\n\n    for (int x = 0; x < n; ++x){\n        if(rand() / (real_t)(RAND_MAX) < false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc serial loop reduction(&&:result)\n        for (int x = 0; x < n; ++x){\n            result = result && a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (a[x] == 0){\n            found = 1;\n            break;\n        }\n    }\n    if (found == result){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_and_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * a_copy = (char *)malloc(10 * n * sizeof(char));\n    char * has_false = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char temp = 1;\n\n    for (int x = 0; x < 10; ++x){\n        has_false[x] = 0;\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (rand() / (real_t)(RAND_MAX) < false_margin){\n                a[x * n + y] = 1;\n                a_copy[x * n + y] = 1;\n            }\n            else {\n                a[x * n + y] = 0;\n                a_copy[x * n + y] = 0;\n                has_false[x] = 1;\n            }\n        }\n    }\n\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop worker reduction(&&:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp && a[x * n + y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                if(temp == 1){\n                    if  (a[x * n + y] == 1){\n                        a[x * n + y] = 0;\n                    }\n                    else {\n                        a[x * n + y] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){\n                err = 1;\n            }\n            else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_and_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * sizeof(char));\n    char * has_false = (char *)malloc(10 * sizeof(char));\n    char temp = 1;\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 10; ++x){\n        has_false[x] = 0;\n    }\n    for (int x = 0; x < 10 * n; ++x){\n        if(rand() / (real_t)(RAND_MAX) < false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n            has_false[x/n] = 1;\n        }\n    }\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop vector reduction(&&:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp && a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (has_false[x] == b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitand_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    n = 10;\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int b = 0;\n    unsigned int host_b;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    for (int x = 0; x < 16; ++x){\n        temp = 1;\n        for (int y = 0; y < x; ++y){\n            temp *= 2;\n        }\n        b += temp;\n    }\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc serial loop reduction(&:b)\n        for (int x = 0; x < n; ++x){\n            b = b & a[x];\n        }\n    }\n\n    host_b = a[0];\n    for (int x = 1; x < n; ++x){\n        host_b = host_b & a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitand_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int* host_c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < 10 * n; ++x){\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    #pragma acc data copyin(a[0:10 * n]) copy(b[0:10 * n], c[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int y = 0; y < 10; ++y){\n            temp = a[y * n];\n            #pragma acc loop worker reduction(&:temp)\n            for (int x = 1; x < n; ++x){\n                temp = temp & a[y * n + x];\n            }\n            c[y] = temp;\n            #pragma acc loop worker\n            for (int x = 0; x < n; ++x){\n                b[y * n + x] = b[y * n + x] + c[y];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        host_c[x] = a[x * n];\n        for (int y = 1; y < n; ++y){\n            host_c[x] = host_c[x] & a[x * n + y];\n        }\n        if (host_c[x] != c[x]){\n          err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + c[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitand_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int b_host;\n    unsigned int c = 0;\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < 10 * n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc serial loop private(c)\n        for (int x = 0; x < 10; ++x){\n            c = a[x * n];\n            #pragma acc loop vector reduction(&:c)\n            for (int y = 1; y < n; ++y){\n                c = c & a[x * n + y];\n            }\n            b[x] = c;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host & a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitor_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    unsigned int b = 0;\n    unsigned int host_b;\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX > false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc serial loop reduction(|:b)\n        for (int x = 0; x < n; ++x){\n            b = b | a[x];\n        }\n    }\n\n    host_b = a[0];\n    for (int x = 1; x < n; ++x){\n        host_b = host_b | a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitor_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int host_c;\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            b[x * n + y] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n            b_copy[x * n + y] = b[x * n + y];\n            for (int z = 0; z < 16; ++z){\n                if (rand() / (real_t) RAND_MAX > false_margin){\n                    temp = 1;\n                    for (int i = 0; i < z; ++i){\n                        temp = temp * 2;\n                    }\n                    a[x * n + y] += temp;\n                }\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(|:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp | a[x * n + y];\n            }\n            c[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                b[x * n + y] = b[x * n + y] + c[x];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        host_c = a[x * n];\n        for (int y = 1; y < n; ++y){\n            host_c = host_c | a[x * n + y];\n        }\n        if (host_c != c[x]){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + host_c){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitor_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int b_host;\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < 10 * n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX > false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    temp = 0;\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(|:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp | a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host | a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitxor_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    unsigned int host_b;\n    unsigned int b = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc serial loop reduction(^:b)\n        for (int x = 0; x < n; ++x){\n            b = b ^ a[x];\n        }\n    }\n\n    host_b = a[0];\n\n    for (int x = 1; x < n; ++x){\n        host_b = host_b ^ a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitxor_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int temp = 0;\n\n    for (int x = 0; x < 10*n; ++x){\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(^:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp ^ a[x * n + y];\n            }\n            c[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                b[x * n + y] = b[x * n + y] + c[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = temp ^ a[x * n + y];\n        }\n        if (temp != c[x]){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + c[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitxor_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int temp = 0;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(^:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp ^ a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host ^ a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_max_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t max = 0.0;\n    int found = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(max)\n    {\n        #pragma acc serial loop reduction(max:max)\n        for (int x = 0; x < n; ++x){\n            max = fmax(a[x] * b[x], max);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(max - (a[x] * b[x] + PRECISION)) < 0){\n            err = 1;\n        }\n        if (fabs(max - (a[x] * b[x] - PRECISION)) > 0){\n            found = 1;\n        }\n    }\n    if (found = 0){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_max_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * maximum = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n    real_t max = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n        c[x] = 0.0;\n    }\n    for (int x = 0; x < 10; ++x){\n        maximum[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], maximum[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(max:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmax(a[x * n + y] * b[x * n + y], temp);\n            }\n            maximum[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / maximum[x];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = fmax(temp, a[x * n + y] * b[x * n + y]);\n        }\n        if (fabs(temp - maximum[x]) > PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (c[x * n + y] > 1){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_max_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * max = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n    real_t temp_max;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(max[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(max:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmax(a[x * n + y] * b[x * n + y], temp);\n            }\n            max[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp_max = 0;\n        for (int y = 0; y < n; ++y){\n            if (temp_max < a[x * n + y] * b[x * n + y]){\n                temp_max = a[x * n + y] * b[x * n + y];\n            }\n        }\n        if (fabs(temp_max - max[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_min_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t min = 1000.0;\n    int found = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(min)\n    {\n        #pragma acc serial loop reduction(min:min)\n        for (int x = 0; x < n; ++x){\n            min = fmin(a[x] * b[x], min);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs((a[x] * b[x]) - (min + PRECISION)) < 0){\n            err = 1;\n        }\n        if (fabs(min - (a[x] * b[x])) < PRECISION){\n            found = 1;\n        }\n    }\n    if (found == 0){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_min_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * minimum = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = 1 + rand() / (real_t)(RAND_MAX/10);\n        b[x] = 1 + rand() / (real_t)(RAND_MAX/10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], minimum[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1000;\n            #pragma acc loop reduction(min:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmin(a[x * n + y] * b[x * n + y], temp);\n            }\n            minimum[x] = temp;\n            #pragma acc loop\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / minimum[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 1000;\n        for (int y = 0; y < n; ++y){\n            temp = fmin(temp, a[x * n + y] * b[x * n + y]);\n        }\n        if (fabs(temp - minimum[x]) > PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x * n + y] - (a[x * n + y] * b[x * n + y] / minimum[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_min_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * min = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 100;\n    real_t temp_min;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(min[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 100;\n            #pragma acc loop vector reduction(min:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmin(a[x * n + y] * b[x * n + y], temp);\n            }\n            min[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp_min = 100;\n        for (int y = 0; y < n; ++y){\n            if (temp_min > a[x * n + y] * b[x * n + y]){\n                temp_min = a[x * n + y] * b[x * n + y];\n            }\n        }\n        if (fabs(temp_min - min[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_multiply_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    int multiplicitive_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(multiplicitive_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(multiplicitive_n * sizeof(real_t));\n\n    real_t multiplied_total = 1.0;\n\n    for (int x = 0; x < multiplicitive_n; ++x){\n        a[x] = rand() / (real_t) RAND_MAX;\n        b[x] = rand() / (real_t) RAND_MAX;\n    }\n\n    #pragma acc data copyin(a[0:multiplicitive_n], b[0:multiplicitive_n]) copy(multiplied_total)\n    {\n        #pragma acc serial loop reduction (*:multiplied_total)\n        for (int x = 0; x < multiplicitive_n; ++x){\n            multiplied_total *= a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < multiplicitive_n; ++x){\n        multiplied_total /= (a[x] + b[x]);\n    }\n    if (fabs(multiplied_total - 1) > PRECISION * (2 * multiplicitive_n - 1)){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_multiply_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;\n        b[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;\n        c[x] = 0.0;\n    }\n\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10*n]) copy(totals[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop worker reduction(*:temp)\n            for (int y = 0; y < n; ++y){\n                temp *= a[x * n + y] + b[x * n + y];\n            }\n            totals[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] + b[x * n + y]) / totals[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 1;\n        for (int y = 0; y < n; ++y){\n            temp *= a[x * n + y] + b[x * n + y];\n        }\n        if (fabs(temp - totals[x]) > (temp / 2 + totals[x] / 2) * PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x * n + y] - ((a[x * n + y] + b[x * n + y]) / totals[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_multiply_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    int multiplicitive_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < 10 * multiplicitive_n; ++x){\n        a[x] = rand() / (real_t) RAND_MAX;\n        b[x] = rand() / (real_t) RAND_MAX;\n    }\n\n    #pragma acc data copyin(a[0:10*multiplicitive_n], b[0:10*multiplicitive_n]) copyout(c[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1.0;\n            #pragma acc loop vector reduction(*:temp)\n            for (int y = 0; y < multiplicitive_n; ++y){\n                temp *= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];\n            }\n            c[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < multiplicitive_n; ++y){\n            c[x] /= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        if (fabs(c[x] - 1) > PRECISION * (4 * multiplicitive_n - 1)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_or_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char result = 0;\n    char found = 0;\n\n    for (int x = 0; x < n; ++x){\n        if(rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc serial loop reduction(||:result)\n        for (int x = 0; x < n; ++x){\n            result = result || a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (a[x] == 1){\n            found = 1;\n        }\n    }\n    if (found != result){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_or_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * a_copy = (char *)malloc(10 * n * sizeof(char));\n    char * results = (char *)malloc(10 * sizeof(char));\n    char temp = 0;\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 10 * n; ++x){\n        if (rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n            a_copy[x] = 1;\n        }\n        else{\n            a[x] = 0;\n            a_copy[x] = 0;\n        }\n    }\n    #pragma acc data copy(a[0:10*n]) copyout(results[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(||:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp || a[x * n + y];\n            }\n            results[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                if(results[x] == 1){\n                    if (a[x * n + y] == 1){\n                        a[x * n + y] = 0;\n                    }\n                    else{\n                        a[x * n + y] = 1;\n                    }\n                }\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = temp || a_copy[x * n + y];\n        }\n        if (temp != results[x]) {\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (temp == 1){\n                if (a[x * n + y] == a_copy[x * n + y]){\n                    err += 1;\n                }\n            }\n            else {\n                if (a[x * n + y] != a_copy[x * n + y]){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_or_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char temp = 0;\n    char found;\n\n    for (int x = 0; x < 10 * n; ++x){\n        if(rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(||:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp || a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        found = 0;\n        for (int y = 0; y < n; ++y){\n            if (a[x * n + y] &! 0){\n                found = 1;\n            }\n        }\n        if (found != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_seq.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(b[0:n])\n    {\n        #pragma acc serial loop seq\n        for (int x = 1; x < n; ++x){\n            b[x] = b[x-1] + a[x];\n        }\n    }\n\n    for (int x = 1; x < n; ++x){\n        temp += a[x];\n        if (fabs(b[x] - temp) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_tile.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,tile,combined-constructs,syntactic,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));\n    real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copy(a[0:n], b[0:n], c[0:n], d2[0:n*n])\n    {\n        #pragma acc serial loop tile(*, *) reduction(+:temp)\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                temp = 0;\n                for (int z = 0; z < n; ++z){\n                    temp += a[x] + b[y] + c[z];\n                }\n                d2[x * n + y] = temp;\n            }\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            temp = 0.0;\n            for (int z = 0; z < n; ++z){\n                temp += a[x] + b[y] + c[z];\n            }\n            if (fabs(temp - d2[x * n + y]) > PRECISION * n){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "tile",
                            "combined-constructs",
                            "syntactic"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,loop,combined-constructs,tile,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));\n    real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d3[0:n*n*n])\n    {\n        #pragma acc serial loop tile(2, 4, 8)\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                for (int z = 0; z < n; ++z){\n                    d3[(n * n * x) + (n * y) + z] = a[x] + b[x] + c[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            for (int z = 0; z < n; ++z){\n                if (fabs(d3[(n * n * x) + (n * y) + z] - a[x] - b[x] - c[x]) > PRECISION * 2){\n                    err = 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs",
                            "tile"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_vector.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc serial loop vector\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if(fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_vector_blocking.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,V:2.6-2.7\nint test1(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t * c = (real_t *)malloc(n * sizeof(real_t));\n  real_t multiplyer = 1;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = 0.0;\n  }\n\n  #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n  {\n    #pragma acc serial\n    {\n      #pragma acc loop vector\n      for (int x = 0; x < n; ++x){\n        c[x] = (a[x] + b[x]) * multiplyer;\n      }\n      multiplyer += 1;\n      #pragma acc loop vector\n      for (int x = 0; x < n; ++x){\n        c[x] += (a[x] + b[x]) * multiplyer;\n      }\n    }\n  }\n\n  for (int x = 0; x < n; ++x){\n    if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){\n      err + 1;\n      break;\n    }\n  }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_worker.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc serial loop worker\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_worker_blocking.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t multiplyer = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n      #pragma acc serial\n      {\n        #pragma acc loop worker\n        for (int x = 0; x < n; ++x){\n          c[x] = (a[x] + b[x]) * multiplyer;\n        }\n        multiplyer += 1;\n        #pragma acc loop worker\n        for (int x = 0; x < n; ++x){\n          c[x] += (a[x] + b[x]) * multiplyer;\n        }\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n      if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){\n        err + 1;\n        break;\n      }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,present,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n])\n    #pragma acc serial present(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "present"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_private.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,private,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    n = 10;\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x * n + y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x * n + y] = rand() / (real_t)(RAND_MAX / 10);\n            c[y] = 0.0;\n        }\n        d[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:10*n], b[0:10*n], d[0:10])\n    #pragma acc serial private(c[0:n])\n    {\n        #pragma acc loop gang\n        for (int x = 0; x < 10; ++x){\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[y] = a[x * n + y] + b[x * n + y];\n            }\n            #pragma acc loop seq\n            for (int y = 0; y < n; ++y){\n                d[x] += c[y];\n            }\n        }\n    }\n    #pragma acc exit data copyout(d[0:10]) delete(a[0:10*n], b[0:10*n])\n\n    for (int x = 0; x < 10; ++x){\n        temp = 0.0;\n        for (int y = 0; y < n; ++y){\n            temp += a[x * n + y] + b[x * n + y];\n        }\n        if (fabs(temp - d[x]) > (2 * PRECISION * n)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "private"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_reduction.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,reduction,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t reduction;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc serial copyin(a[0:n]) reduction(+:reduction)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            reduction = reduction + a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        reduction = reduction - a[x];\n    }\n    if (fabs(reduction) > PRECISION){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_scalar_default_firstprivate.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,default-mapping,serial,firstprivate,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t scalar = rand() / (real_t)(RAND_MAX / 10);\n    real_t scalar_copy = scalar;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc serial\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + scalar;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + scalar_copy)) > PRECISION){\n            err += 1;\n        }\n    }\n    if (fabs(scalar_copy - scalar) > PRECISION){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "default-mapping",
                            "serial",
                            "firstprivate"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_switch.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int * a = (int *)malloc(n * sizeof(int));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = floor(rand() / (real_t)(RAND_MAX / 10));\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        b_host[x] = b[x];\n        c[x] = 0.0;\n    }\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc serial present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            switch(a[x]){\n                case 0:\n                    c[x] = b[x] * b[x];\n                    break;\n                case 1:\n                    c[x] = b[x] / b[x];\n                    break;\n                case 2:\n                    b[x] = b[x] / 2;\n                default:\n                    c[x] = a[x] + b[x];\n\n\n            }\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n    real_t tempc = 0.0;\n    for (int x = 0; x < n; ++x){\n        switch(a[x]){\n            case 0:\n                tempc = b_host[x] * b_host[x];\n                break;\n            case 1:\n                tempc = b_host[x] / b_host[x];\n                break;\n            case 2:\n                b_host[x] = b_host[x] / 2;\n            default:\n                tempc = a[x] + b_host[x];\n        }\n        if (fabs(c[x] - tempc) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_wait.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,executable-data,async,wait,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc enter data create(a[0:n])\n    #pragma acc update device(a[0:n]) async(1)\n    #pragma acc serial present(a[0:n]) wait(1)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] += 1;\n        }\n    }\n    #pragma acc exit data copyout(a[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] + 1)) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "executable-data",
                            "async",
                            "wait"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_while_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,reduction,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t avg = 0.0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc serial\n        {\n            #pragma acc loop\n            for (int y = 0; y < 10; ++y){\n                avg = 0.0;\n                while (avg - 1000 < PRECISION * n){\n                    avg = 0.0;\n                    #pragma acc loop reduction(+:avg)\n                    for (int x = 0; x < n; ++x){\n                        a[n * y + x] *= 1.5;\n                        avg += a[n * y + x] / n;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int y = 0 y < 10; ++y){\n        avg = 0.0;\n        for (int x = 0; x < n; ++x){\n            avg += a[y * n + x]/n;\n        }\n\n        if (avg < 1000 || avg > 1500){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "set_default_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:async,set,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        a_host[x] = a[x];\n        b_host[x] = b[x];\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc set default_async(1)\n        #pragma acc parallel async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] * a[x];\n            }\n        }\n        #pragma acc set default_async(2)\n        #pragma acc parallel async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] * b[x];\n            }\n        }\n        #pragma acc parallel async(1) wait(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc wait(1)\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4*PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "set",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "set_device_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:set,devonly,runtime,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n\n    if (acc_get_device_type() != acc_device_none){\n        real_t **host_copy = (real_t **)malloc(acc_get_num_devices(acc_get_device_type()) * sizeof(real_t *));\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            host_copy[x] = (real_t *)malloc(n * sizeof(real_t));\n        }\n        real_t *a = (real_t *)malloc(n * sizeof(real_t));\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            for (int y = 0; y < n; ++y){\n                a[y] = rand() / (real_t)(RAND_MAX / 10);\n                host_copy[x][y] = a[y];\n            }\n            #pragma acc set device_num(x)\n            #pragma acc enter data copyin(a[0:n])\n        }\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            #pragma acc set device_num(x)\n            #pragma acc data present(a[0:n])\n            {\n                #pragma acc parallel\n                {\n                    #pragma acc loop\n                    for (int y = 0; y < n; ++y){\n                        a[y] = a[y] + 1;\n                    }\n                }\n            }\n        }\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            #pragma acc set device_num(x)\n            #pragma acc exit data copyout(a[0:n])\n            for (int y = 0; y < n; ++y){\n                if (fabs(a[y] - (host_copy[x][y] + 1)) > PRECISION){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "set",
                            "devonly",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "set_device_type.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:set,runtime,syntactic,V:2.5-2.7\nint test1(){\n    int err = 0;\n\n    int device_type = acc_get_device_type();\n\n    #pragma acc set device_type(device_type)\n    if (acc_get_device_type() != device_type){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "set",
                            "runtime",
                            "syntactic"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:shutdown,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    #pragma acc shutdown\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "shutdown"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown_device_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:shutdown,runtime,syntactic,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int device_num;\n\n    device_num = acc_get_device_num(acc_get_device_type());\n    #pragma acc shutdown device_num(device_num)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "shutdown",
                            "runtime",
                            "syntactic"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown_device_type.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:shutdown,runtime,syntactic,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int device_type; \n\n    device_type = acc_get_device_type();\n    #pragma acc shutdown device_type(device_type)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "shutdown",
                            "runtime",
                            "syntactic"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown_device_type_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:shutdown,runtime,syntactic,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int device_type\n    int device_num\n\n    device_type = acc_get_device_type();\n    device_num = acc_get_device_num(device_type);\n    #pragma acc shutdown device_type(device_type) device_num(device_num)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "shutdown",
                            "runtime",
                            "syntactic"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            }
        }
    ]
}
